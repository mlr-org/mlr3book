<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>4&nbsp; Hyperparameter Optimization – Applied Machine Learning Using mlr3 in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" rel="next">
<link href="../../chapters/chapter3/evaluation_and_benchmarking.html" rel="prev">
<link href="../../Figures/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-0d45b1ff1595a53868627e64e30aef28.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-54b1fec74e0844836633235e285d9714.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html">Tuning and Feature Selection</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Applied Machine Learning Using mlr3 in R</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mlr-org/mlr3book/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../Applied-Machine-Learning-Using-mlr3-in-R.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/introduction_and_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction and Overview</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/data_and_basic_modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data and Basic Modeling</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Tuning and Feature Selection</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter4/hyperparameter_optimization.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter6/feature_selection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false">
 <span class="menu-text">Pipelines and Preprocessing</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter7/sequential_pipelines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter9/preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Preprocessing</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">Advanced Topics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter10/advanced_technical_aspects_of_mlr3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Advanced Technical Aspects of mlr3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter11/large-scale_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Large-Scale Benchmarking</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter12/model_interpretation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Model Interpretation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter13/beyond_regression_and_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Beyond Regression and Classification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter14/algorithmic_fairness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Algorithmic Fairness</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter15/predsets_valid_inttune.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Predict Sets, Validation and Internal Tuning (+)</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/solutions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Solutions to exercises</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/tasks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Tasks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/overview-tables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Overview Tables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/errata.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Errata</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/session_info.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Session Info</span></span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Table of contents</h2>
   
  <ul>
<li>
<a href="#sec-model-tuning" id="toc-sec-model-tuning" class="nav-link active" data-scroll-target="#sec-model-tuning"><span class="header-section-number">4.1</span> Model Tuning</a>
  <ul class="collapse">
<li><a href="#sec-learner-search-space" id="toc-sec-learner-search-space" class="nav-link" data-scroll-target="#sec-learner-search-space"><span class="header-section-number">4.1.1</span> Learner and Search Space</a></li>
  <li><a href="#sec-terminator" id="toc-sec-terminator" class="nav-link" data-scroll-target="#sec-terminator"><span class="header-section-number">4.1.2</span> Terminator</a></li>
  <li><a href="#sec-tuning-instance" id="toc-sec-tuning-instance" class="nav-link" data-scroll-target="#sec-tuning-instance"><span class="header-section-number">4.1.3</span> Tuning Instance with <code>ti</code></a></li>
  <li><a href="#sec-tuner" id="toc-sec-tuner" class="nav-link" data-scroll-target="#sec-tuner"><span class="header-section-number">4.1.4</span> Tuner</a></li>
  <li><a href="#sec-logarithmic-transformations" id="toc-sec-logarithmic-transformations" class="nav-link" data-scroll-target="#sec-logarithmic-transformations"><span class="header-section-number">4.1.5</span> Logarithmic Transformations</a></li>
  <li><a href="#sec-analyzing-result" id="toc-sec-analyzing-result" class="nav-link" data-scroll-target="#sec-analyzing-result"><span class="header-section-number">4.1.6</span> Analyzing and Using the Result</a></li>
  </ul>
</li>
  <li><a href="#sec-autotuner" id="toc-sec-autotuner" class="nav-link" data-scroll-target="#sec-autotuner"><span class="header-section-number">4.2</span> Convenient Tuning with <code>tune</code> and <code>auto_tuner</code></a></li>
  <li>
<a href="#sec-nested-resampling" id="toc-sec-nested-resampling" class="nav-link" data-scroll-target="#sec-nested-resampling"><span class="header-section-number">4.3</span> Nested Resampling</a>
  <ul class="collapse">
<li><a href="#nested-resampling-with-an-autotuner" id="toc-nested-resampling-with-an-autotuner" class="nav-link" data-scroll-target="#nested-resampling-with-an-autotuner"><span class="header-section-number">4.3.1</span> Nested Resampling with an <code>AutoTuner</code></a></li>
  <li><a href="#sec-resample-overfitting" id="toc-sec-resample-overfitting" class="nav-link" data-scroll-target="#sec-resample-overfitting"><span class="header-section-number">4.3.2</span> The Right (and Wrong) Way to Estimate Performance</a></li>
  </ul>
</li>
  <li>
<a href="#sec-defining-search-spaces" id="toc-sec-defining-search-spaces" class="nav-link" data-scroll-target="#sec-defining-search-spaces"><span class="header-section-number">4.4</span> More Advanced Search Spaces</a>
  <ul class="collapse">
<li><a href="#scalar-parameter-tuning" id="toc-scalar-parameter-tuning" class="nav-link" data-scroll-target="#scalar-parameter-tuning"><span class="header-section-number">4.4.1</span> Scalar Parameter Tuning</a></li>
  <li><a href="#sec-tune-ps" id="toc-sec-tune-ps" class="nav-link" data-scroll-target="#sec-tune-ps"><span class="header-section-number">4.4.2</span> Defining Search Spaces with <code>ps</code></a></li>
  <li><a href="#sec-tune-trafo" id="toc-sec-tune-trafo" class="nav-link" data-scroll-target="#sec-tune-trafo"><span class="header-section-number">4.4.3</span> Transformations and Tuning Over Vectors</a></li>
  <li><a href="#sec-optimization-depends" id="toc-sec-optimization-depends" class="nav-link" data-scroll-target="#sec-optimization-depends"><span class="header-section-number">4.4.4</span> Hyperparameter Dependencies</a></li>
  <li><a href="#sec-tuning-spaces" id="toc-sec-tuning-spaces" class="nav-link" data-scroll-target="#sec-tuning-spaces"><span class="header-section-number">4.4.5</span> Recommended Search Spaces with <code>mlr3tuningspaces</code></a></li>
  </ul>
</li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">4.5</span> Conclusion</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">4.6</span> Exercises</a></li>
  <li><a href="#citation" id="toc-citation" class="nav-link" data-scroll-target="#citation"><span class="header-section-number">4.7</span> Citation</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter4/hyperparameter_optimization.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter4/hyperparameter_optimization.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html">Tuning and Feature Selection</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></a></li></ol></nav><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-optimization" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><p><strong>Marc Becker</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML)</em></p>
<p><strong>Lennart Schneider</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML)</em></p>
<p><strong>Sebastian Fischer</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML)</em> <br><br></p>
<div class="page-columns page-full"><p>Machine learning algorithms usually include parameters and hyperparameters. Parameters are the model coefficients or weights or other information that are determined by the learning algorithm based on the training data. In contrast, hyperparameters, are configured by the user and determine how the model will fit its parameters, i.e., how the model is built. Examples include setting the number of trees in a random forest, penalty settings in support vector machines, or the learning rate in a neural network.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Hyperparameters</span></div></div>
<div class="page-columns page-full"><p>The goal of hyperparameter optimization (HPO) or model tuning is to find the optimal configuration of hyperparameters of a machine learning algorithm for a given task. There is no closed-form mathematical representation (nor analytic gradient information) for model-agnostic HPO. Instead, we follow a black box optimization approach: a machine learning algorithm is configured with values chosen for one or more hyperparameters, this algorithm is then evaluated (using a resampling method) and its performance is measured. This process is repeated with multiple configurations and finally, the configuration with the best performance is selected (<a href="#fig-optimization-loop-basic" class="quarto-xref">Figure&nbsp;<span>4.1</span></a>). HPO closely relates to model evaluation (<a href="../chapter3/evaluation_and_benchmarking.html" class="quarto-xref"><span>Chapter 3</span></a>) as the objective is to find a hyperparameter configuration that optimizes the generalization performance. Broadly speaking, we could think of finding the optimal model configuration in the same way as selecting a model from a benchmark experiment, where in this case each model in the experiment is the same algorithm but with different hyperparameter configurations. For example, we could benchmark three support vector machines (SVMs) with three different <code>cost</code> values. However, human trial-and-error is time-consuming, subjective and often biased, error-prone, and computationally inefficient. Instead, many sophisticated hyperparameter optimization methods (or ‘tuners’, see <a href="#sec-tuner" class="quarto-xref"><span>Section 4.1.4</span></a>) have been developed over the past few decades for robust and efficient HPO. Besides simple approaches such as a random search or grid search, most hyperparameter optimization methods employ iterative techniques that propose different configurations over time, often exhibiting adaptive behavior guided towards potentially optimal hyperparameter configurations. These methods continually propose new configurations until a termination criterion is met, at which point the best configuration so far is returned (<a href="#fig-optimization-loop-basic" class="quarto-xref">Figure&nbsp;<span>4.1</span></a>). For more general details on HPO and more theoretical background, we recommend <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="../references.html#ref-hpo_practical" role="doc-biblioref">2023</a>)</span> and <span class="citation" data-cites="hpo_automl">Feurer and Hutter (<a href="../references.html#ref-hpo_automl" role="doc-biblioref">2019</a>)</span>.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Hyperparameter Optimization</span></div></div>
<p>Note that <code>mlr3</code> never does any automatic hyperparameter optimization that the user did not explicitly request.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-optimization-loop-basic" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Diagram showing 13 boxes representing model-agnostic HPO.  On the top are two boxes, one that says  &quot;Search Space&quot; (dark blue) and the other &quot;Tuner&quot; (green), these are connected by a line to &quot;Propose Hyperparameter Configurations&quot; (purple). That box has an arrow pointing towards another box &quot;Evaluate by Resampling&quot; (purple), which has a line to a blue-green box &quot;Objective&quot;, which has four blue boxes connected toit  &quot;Task&quot;, &quot;Learner&quot;, &quot;Resampling&quot;, and &quot;Measure&quot;. &quot;Evaluate by Resampling&quot; also has one line to the right connected to &quot;Archive&quot; (blue-green) which has an arrow to &quot;Terminator&quot; (blue) and &quot;Update Tuner&quot; (purple). &quot;Terminator&quot; has an arrow to &quot;Optimal Hyperparameter Configuration&quot; (purple) and &quot;Update Tuner&quot; has an arrow back to &quot;Propose Hyperparameter Configurations&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-optimization-loop-basic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-9.svg" class="img-fluid figure-img" style="width:80.0%" alt="Diagram showing 13 boxes representing model-agnostic HPO.  On the top are two boxes, one that says  &quot;Search Space&quot; (dark blue) and the other &quot;Tuner&quot; (green), these are connected by a line to &quot;Propose Hyperparameter Configurations&quot; (purple). That box has an arrow pointing towards another box &quot;Evaluate by Resampling&quot; (purple), which has a line to a blue-green box &quot;Objective&quot;, which has four blue boxes connected toit  &quot;Task&quot;, &quot;Learner&quot;, &quot;Resampling&quot;, and &quot;Measure&quot;. &quot;Evaluate by Resampling&quot; also has one line to the right connected to &quot;Archive&quot; (blue-green) which has an arrow to &quot;Terminator&quot; (blue) and &quot;Update Tuner&quot; (purple). &quot;Terminator&quot; has an arrow to &quot;Optimal Hyperparameter Configuration&quot; (purple) and &quot;Update Tuner&quot; has an arrow back to &quot;Propose Hyperparameter Configurations&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-optimization-loop-basic-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.1: Representation of the hyperparameter optimization loop in mlr3tuning. Blue - Hyperparameter optimization loop. Purple - Objects of the tuning instance supplied by the user. Blue-Green - Internally created objects of the tuning instance. Green - Optimization Algorithm.
</figcaption></figure>
</div>
</div>
</div>
<section id="sec-model-tuning" class="level2 page-columns page-full" data-number="4.1"><h2 data-number="4.1" class="anchored" data-anchor-id="sec-model-tuning">
<span class="header-section-number">4.1</span> Model Tuning</h2>
<p><a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a> is the hyperparameter optimization package of the <code>mlr3</code> ecosystem. At the heart of the package are the R6 classes</p>
<ul>
<li>
<a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceBatchSingleCrit.html"><code>TuningInstanceBatchSingleCrit</code></a>, a tuning ‘instance’ that describes the optimization problem and store the results; and</li>
<li>
<a href="https://mlr3tuning.mlr-org.com/reference/TunerBatch.html"><code>TunerBatch</code></a> which is used to configure and run optimization algorithms.</li>
</ul>
<p>In this section, we will cover these classes as well as other supporting functions and classes. Throughout this section, we will look at optimizing an SVM classifier from <a href="https://cran.r-project.org/package=e1071"><code>e1071</code></a> on <code>tsk("sonar")</code> as a running example.</p>
<section id="sec-learner-search-space" class="level3 page-columns page-full" data-number="4.1.1"><h3 data-number="4.1.1" class="anchored" data-anchor-id="sec-learner-search-space">
<span class="header-section-number">4.1.1</span> Learner and Search Space</h3>
<p>The tuning process begins by deciding which hyperparameters to tune and what range to tune them over. The first place to start is therefore picking a learner and looking at the possible hyperparameters to tune with <code>$param_set</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">)</span><span class="op">[</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">id</span>, <span class="va">class</span>, <span class="va">lower</span>, <span class="va">upper</span>, <span class="va">nlevels</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>               id    class lower upper nlevels
 1:     cachesize ParamDbl  -Inf   Inf     Inf
 2: class.weights ParamUty    NA    NA     Inf
 3:         coef0 ParamDbl  -Inf   Inf     Inf
 4:          cost ParamDbl     0   Inf     Inf
 5:         cross ParamInt     0   Inf     Inf
---                                           
12:            nu ParamDbl  -Inf   Inf     Inf
13:         scale ParamUty    NA    NA     Inf
14:     shrinking ParamLgl    NA    NA       2
15:     tolerance ParamDbl     0   Inf     Inf
16:          type ParamFct    NA    NA       2</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>Given infinite resources, we could tune all hyperparameters jointly, but in reality that is not possible (or maybe necessary), so usually only a subset of hyperparameters can be tuned. This subset of possible hyperparameter values to tune over is referred to as the search space or tuning space. In this example we will tune the numeric regularization and kernel width hyperparameters, <code>cost</code> and <code>gamma</code>; see the help page for <a href="https://www.rdocumentation.org/packages/e1071/topics/svm"><code>svm()</code></a> for details. In practice, search spaces are usually more complex and can require expert knowledge to define them. <a href="#sec-defining-search-spaces" class="quarto-xref"><span>Section 4.4</span></a> provides more detailed insight into the creation of tuning spaces, including using <a href="https://mlr3tuningspaces.mlr-org.com"><code>mlr3tuningspaces</code></a> to load predefined search spaces.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Search Space</span></div></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Untunable Hyperparameters
</div>
</div>
<div class="callout-body-container callout-body">
<p>In rare cases, parameter sets may include hyperparameters that should not be tuned. These will usually be ‘technical’ (or ‘control’) parameters that <em>provide information</em> about how the model is being fit but do not control the training process itself, for example, the <code>verbose</code> hyperparameter in <code>lrn("classif.ranger")</code> controls how much information is displayed to the user during training.</p>
</div>
</div>
<p>For numeric hyperparameters (we will explore others later) one must specify the bounds to tune over. We do this by constructing a learner and using <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a> to set the lower and upper limits for the parameters we want to tune. This function allows us to <em>mark</em> the hyperparameter as requiring tuning in the specified range.</p>
<div class="cell">
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  type  <span class="op">=</span> <span class="st">"C-classification"</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">learner</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;LearnerClassifSVM&gt; (classif.svm): Support Vector Machine ────────────
• Model: -
• Parameters: cost=&lt;RangeTuneToken&gt;, gamma=&lt;RangeTuneToken&gt;,
kernel=radial, type=C-classification
• Packages: mlr3, mlr3learners, and e1071
• Predict Types: [response] and prob
• Feature Types: logical, integer, and numeric
• Encapsulation: none (fallback: -)
• Properties: multiclass and twoclass
• Other settings: use_weights = 'error'</code></pre>
</div>
</div>
<p>Here we have constructed a classification SVM, <code>lrn("classif.svm")</code>, selected the type of model as <code>"C-classification"</code>, set the kernel to <code>"radial"</code>, and specified that we plan to tune the <code>cost</code> and <code>gamma</code> parameters over the range <span class="math inline">\([0.1, 10^5]\)</span> and <span class="math inline">\([0.1, 1]\)</span> respectively (though these are usually tuned on a log scale, see <a href="#sec-logarithmic-transformations" class="quarto-xref"><span>Section 4.1.5</span></a>). Note that calling <code>$train()</code> on a learner with a tune token (e.g., <code>cost=&lt;RangeTuneToken&gt;</code>) will throw an error.</p>
<p>Now we have decided which hyperparameters to tune, we specify when to stop the tuning process.</p>
</section><section id="sec-terminator" class="level3 page-columns page-full" data-number="4.1.2"><h3 data-number="4.1.2" class="anchored" data-anchor-id="sec-terminator">
<span class="header-section-number">4.1.2</span> Terminator</h3>
<div class="page-columns page-full"><p><code>mlr3tuning</code> includes many methods to specify when to terminate an algorithm (<a href="#tbl-terms" class="quarto-xref">Table&nbsp;<span>4.1</span></a>), which are implemented in <a href="https://bbotk.mlr-org.com/reference/Terminator.html"><code>Terminator</code></a> classes. Terminators are stored in the <a href="https://bbotk.mlr-org.com/reference/mlr_terminators.html"><code>mlr_terminators</code></a> dictionary and are constructed with the sugar function <a href="https://bbotk.mlr-org.com/reference/trm.html"><code>trm()</code></a>.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>Terminator</code></span><span class="margin-aside"><code><a href="https://bbotk.mlr-org.com/reference/trm.html">trm()</a></code></span></div></div>
<div id="tbl-terms" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-terms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.1: Terminators available in <code>mlr3tuning</code> at the time of publication, their function call and default parameters. A complete and up-to-date list can be found at <a href="https://mlr-org.com/terminators.html">https://mlr-org.com/terminators.html</a>.
</figcaption><div aria-describedby="tbl-terms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 67%">
</colgroup>
<thead><tr class="header">
<th>Terminator</th>
<th>Function call and default parameters</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Clock Time</td>
<td><code>trm("clock_time")</code></td>
</tr>
<tr class="even">
<td>Combo</td>
<td><code>trm("combo", any = TRUE)</code></td>
</tr>
<tr class="odd">
<td>None</td>
<td><code>trm("none")</code></td>
</tr>
<tr class="even">
<td>Number of Evaluations</td>
<td><code>trm("evals", n_evals = 100, k = 0)</code></td>
</tr>
<tr class="odd">
<td>Performance Level</td>
<td><code>trm("perf_reached", level = 0.1)</code></td>
</tr>
<tr class="even">
<td>Run Time</td>
<td><code>trm("run_time", secs = 30)</code></td>
</tr>
<tr class="odd">
<td>Stagnation</td>
<td><code>trm("stagnation", iters = 10, threshold = 0)</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The most commonly used terminators are those that stop the tuning after a certain time (<code>trm("run_time")</code>) or a given number of evaluations (<code>trm("evals")</code>). Choosing a runtime is often based on practical considerations and intuition. Using a time limit can be important on compute clusters where a maximum runtime for a compute job may need to be specified. <code>trm("perf_reached")</code> stops the tuning when a specified performance level is reached, which can be helpful if a certain performance is seen as sufficient for the practical use of the model, however, if this is set too optimistically the tuning may never terminate. <code>trm("stagnation")</code> stops when no progress greater than the <code>threshold</code> has been made for a set number of <code>iterations</code>. The threshold can be difficult to select as the optimization could stop too soon for complex search spaces despite room for (possibly significant) improvement. <code>trm("none")</code> is used for tuners that control termination themselves and so this terminator does nothing. Finally, any of these terminators can be freely combined by using <code>trm("combo")</code>, which can be used to specify if HPO finishes when any (<code>any = TRUE</code>) terminator is triggered or when all (<code>any = FALSE</code>) are triggered.</p>
</section><section id="sec-tuning-instance" class="level3" data-number="4.1.3"><h3 data-number="4.1.3" class="anchored" data-anchor-id="sec-tuning-instance">
<span class="header-section-number">4.1.3</span> Tuning Instance with <code>ti</code>
</h3>
<p>The tuning instance collects the tuner-agnostic information required to optimize a model, i.e., all information about the tuning process, except for the tuning algorithm itself. This includes the task to tune over, the learner to tune, the resampling method and measure used to analytically compare hyperparameter optimization configurations, and the terminator to determine when the measure has been optimized ‘enough’. This implicitly defines a “black box” objective function, mapping hyperparameter configurations to (stochastic) performance values, to be optimized. This concept will be revisited in <a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="quarto-xref"><span>Chapter 5</span></a>.</p>
<p>A tuning instance can be constructed explicitly with the <a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a> function, or we can tune a learner with the <a href="https://mlr3tuning.mlr-org.com/reference/tune.html"><code>tune()</code></a> function, which implicitly creates a tuning instance, as shown in <a href="#sec-autotuner" class="quarto-xref"><span>Section 4.2</span></a>. We cover the <code><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti()</a></code> approach first as this allows finer control of tuning and a more nuanced discussion about the design and use of <code>mlr3tuning</code>.</p>
<p>Continuing our example, we will construct a single-objective tuning problem (i.e., tuning over <em>one</em> measure) by using the <code><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti()</a></code> function to create a <a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceBatchSingleCrit.html"><code>TuningInstanceBatchSingleCrit</code></a>, we will return to multi-objective tuning in <a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-multi-metrics-tuning" class="quarto-xref"><span>Section 5.2</span></a>.</p>
<p>For this example, we will use three-fold CV and optimize the classification error measure. Note that in the next section, we will continue our example with a grid search tuner, so we select <code>trm("none")</code> below as we will want to iterate over the full grid without stopping too soon.</p>
<div class="cell">
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_sonar</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">ti</span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">learner</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu">trm</span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;TuningInstanceBatchSingleCrit&gt; ──────────────────────────────────────
• State: Not optimized
• Objective: &lt;ObjectiveTuningBatch&gt;
• Search Space:
      id    class lower upper nlevels
1:  cost ParamDbl   0.1 1e+05     Inf
2: gamma ParamDbl   0.1 1e+00     Inf
• Terminator: &lt;TerminatorNone&gt;</code></pre>
</div>
</div>
</section><section id="sec-tuner" class="level3 page-columns page-full" data-number="4.1.4"><h3 data-number="4.1.4" class="anchored" data-anchor-id="sec-tuner">
<span class="header-section-number">4.1.4</span> Tuner</h3>
<div class="page-columns page-full"><p>With all the pieces of our tuning problem assembled, we can now decide <em>how</em> to tune our model. There are multiple <a href="https://mlr3tuning.mlr-org.com/reference/Tuner.html"><code>Tuner</code></a> classes in <code>mlr3tuning</code>, which implement different HPO (or more generally speaking black box optimization) algorithms (<a href="#tbl-tuners" class="quarto-xref">Table&nbsp;<span>4.2</span></a>).</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>Tuner</code></span></div></div>
<div id="tbl-tuners" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tuners-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.2: Tuning algorithms available in <code>mlr3tuning</code>, their function call and the package in which the algorithm is implemented. A complete and up-to-date list can be found at <a href="https://mlr-org.com/tuners.html">https://mlr-org.com/tuners.html</a>.
</figcaption><div aria-describedby="tbl-tuners-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead><tr class="header">
<th>Tuner</th>
<th>Function call</th>
<th>Package</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Random Search</td>
<td><code>tnr("random_search")</code></td>
<td><a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a></td>
</tr>
<tr class="even">
<td>Grid Search</td>
<td><code>tnr("grid_search")</code></td>
<td><a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a></td>
</tr>
<tr class="odd">
<td>Bayesian Optimization</td>
<td><code>tnr("mbo")</code></td>
<td><a href="https://mlr3mbo.mlr-org.com"><code>mlr3mbo</code></a></td>
</tr>
<tr class="even">
<td>CMA-ES</td>
<td><code>tnr("cmaes")</code></td>
<td><a href="https://cran.r-project.org/package=adagio"><code>adagio</code></a></td>
</tr>
<tr class="odd">
<td>Iterated Racing</td>
<td><code>tnr("irace")</code></td>
<td><a href="https://cran.r-project.org/package=irace"><code>irace</code></a></td>
</tr>
<tr class="even">
<td>Hyperband</td>
<td><code>tnr("hyperband")</code></td>
<td><a href="https://mlr3hyperband.mlr-org.com"><code>mlr3hyperband</code></a></td>
</tr>
<tr class="odd">
<td>Generalized Simulated Annealing</td>
<td><code>tnr("gensa")</code></td>
<td><a href="https://cran.r-project.org/package=GenSA"><code>GenSA</code></a></td>
</tr>
<tr class="even">
<td>Nonlinear Optimization</td>
<td><code>tnr("nloptr")</code></td>
<td><a href="https://cran.r-project.org/package=nloptr"><code>nloptr</code></a></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="search-strategies" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="search-strategies">Search strategies</h4>
<p>Grid search and random search <span class="citation" data-cites="bergstra2012">(<a href="../references.html#ref-bergstra2012" role="doc-biblioref">Bergstra and Bengio 2012</a>)</span> are the most basic algorithms and are often selected first in initial experiments. The idea of grid search is to exhaustively evaluate every possible combination of given hyperparameter values. Categorical hyperparameters are usually evaluated over all possible values they can take. Numeric and integer hyperparameter values are then spaced equidistantly in their box constraints (upper and lower bounds) according to a given resolution, which is the number of distinct values to try per hyperparameter. Random search involves randomly selecting values for each hyperparameter independently from a pre-specified distribution, usually uniform. Both methods are non-adaptive, which means each proposed configuration ignores the performance of previous configurations. Due to their simplicity, both grid search and random search can handle mixed search spaces (i.e., hyperparameters can be numeric, integer, or categorical) as well as hierarchical search spaces (<a href="#sec-defining-search-spaces" class="quarto-xref"><span>Section 4.4</span></a>).</p>
</section><section id="adaptive-algorithms" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="adaptive-algorithms">Adaptive algorithms</h4>
<p>Adaptive algorithms learn from previously evaluated configurations to find good configurations quickly, examples in <a href="https://mlr3.mlr-org.com"><code>mlr3</code></a> include Bayesian optimization (also called model-based optimization), Covariance Matrix Adaptation Evolution Strategy (CMA-ES), Iterated Racing, and Hyperband.</p>
<p>Bayesian optimization <span class="citation" data-cites="Snoek2012">(e.g., <a href="../references.html#ref-Snoek2012" role="doc-biblioref">Snoek, Larochelle, and Adams 2012</a>)</span> describes a family of iterative optimization algorithms that use a surrogate model to approximate the unknown function that is to be optimized – in HPO this would be the mapping from a hyperparameter configuration to the estimated generalization performance. If a suitable surrogate model is chosen, e.g.&nbsp;a random forest, Bayesian optimization can be quite flexible and even handle mixed and hierarchical search spaces. Bayesian optimization is discussed in full detail in <a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-bayesian-optimization" class="quarto-xref"><span>Section 5.4</span></a>.</p>
<p>CMA-ES <span class="citation" data-cites="hansen2011">(<a href="../references.html#ref-hansen2011" role="doc-biblioref">Hansen and Auger 2011</a>)</span> is an evolutionary strategy that maintains a probability distribution over candidate points, with the distribution represented by a mean vector and covariance matrix. A new set of candidate points is generated by sampling from this distribution, with the probability of each candidate being proportional to its performance. The covariance matrix is adapted over time to reflect the performance landscape. Further evolutionary strategies are available in <code>mlr3</code> via the <a href="https://cran.r-project.org/package=miesmuschel"><code>miesmuschel</code></a> package, however, these will not be covered in this book.</p>
<p>Racing algorithms work by iteratively discarding configurations that show poor performance, as determined by statistical tests. Iterated Racing <span class="citation" data-cites="lopez2016">(<a href="../references.html#ref-lopez2016" role="doc-biblioref">López-Ibáñez et al. 2016</a>)</span> starts by ‘racing’ down an initial population of randomly sampled configurations from a parameterized density and then uses the surviving configurations of the race to stochastically update the density of the subsequent race to focus on promising regions of the search space, and so on.</p>
<p>Multi-fidelity HPO is an adaptive method that leverages the predictive power of computationally cheap lower fidelity evaluations (i.e., poorer quality predictions such as those arising from neural networks with a small number of epochs) to improve the overall optimization efficiency. This concept is used in Hyperband <span class="citation" data-cites="li_2018">(<a href="../references.html#ref-li_2018" role="doc-biblioref">Li et al. 2018</a>)</span>, a popular multi-fidelity hyperparameter optimization algorithm that dynamically allocates increasingly more resources to promising configurations and terminates low-performing ones. Hyperband is discussed in full detail in <a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-hyperband" class="quarto-xref"><span>Section 5.3</span></a>.</p>
<p>Other implemented algorithms for numeric search spaces are Generalized Simulated Annealing <span class="citation" data-cites="xiang2013 tsallis1996">(<a href="../references.html#ref-xiang2013" role="doc-biblioref">Xiang et al. 2013</a>; <a href="../references.html#ref-tsallis1996" role="doc-biblioref">Tsallis and Stariolo 1996</a>)</span> and various nonlinear optimization algorithms.</p>
</section><section id="choosing-strategies" class="level4 unnumbered unlisted page-columns page-full"><h4 class="unnumbered unlisted anchored" data-anchor-id="choosing-strategies">Choosing strategies</h4>
<p>As a rule of thumb, if the search space is small or does not have a complex structure, grid search may be able to exhaustively evaluate the entire search space in a reasonable time. However, grid search is generally not recommended due to the curse of dimensionality – the grid size ‘blows up’ very quickly as the number of parameters to tune increases – and insufficient coverage of numeric search spaces. By construction, grid search cannot evaluate a large number of unique values per hyperparameter, which is suboptimal when some hyperparameters have minimal impact on performance while others do. In such scenarios, random search is often a better choice as it considers more unique values per hyperparameter compared to grid search.</p>
<p>For higher-dimensional search spaces or search spaces with more complex structure, more guided optimization algorithms such as evolutionary strategies or Bayesian optimization tend to perform better and are more likely to result in peak performance. When choosing between evolutionary strategies and Bayesian optimization, the cost of function evaluation is highly relevant. If hyperparameter configurations can be evaluated quickly, evolutionary strategies often work well. On the other hand, if model evaluations are time-consuming and the optimization budget is limited, Bayesian optimization is usually preferred, as it is quite sample efficient compared to other algorithms, i.e., less function evaluations are needed to find good configurations. Hence, Bayesian optimization is usually recommended for HPO. While the optimization overhead of Bayesian optimization is comparably large (e.g., in each iteration, training of the surrogate model and optimizing the acquisition function), this has less of an impact in the context of relatively costly function evaluations such as resampling of ML models.</p>
<p>Finally, in cases where the hyperparameter optimization problem involves a meaningful fidelity parameter (e.g., number of epochs, number of trees, number of boosting rounds) and where the optimization budget needs to be spent efficiently, multi-fidelity hyperparameter optimization algorithms like Hyperband may be worth considering. For further details on different tuners and practical recommendations, we refer to <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="../references.html#ref-hpo_practical" role="doc-biblioref">2023</a>)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<code>$param_classes</code> and <code>$properties</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <code>$param_classes</code> and <code>$properties</code> fields of a <code>Tuner</code> respectively provide information about which classes of hyperparameters can be handled and what properties the tuner can handle (e.g., hyperparameter dependencies, which are shown in <a href="#sec-defining-search-spaces" class="quarto-xref"><span>Section 4.4</span></a>, or multicriteria optimization, which is presented in <a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-multi-metrics-tuning" class="quarto-xref"><span>Section 5.2</span></a>):</p>
<div class="cell">
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span><span class="op">$</span><span class="va">param_classes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "ParamLgl" "ParamInt" "ParamDbl" "ParamFct"</code></pre>
</div>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span><span class="op">$</span><span class="va">properties</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "dependencies" "single-crit"  "multi-crit"  </code></pre>
</div>
</div>
</div>
</div>
<p>For our SVM example, we will use a grid search with a resolution of five for runtime reasons here (in practice a larger resolution would be preferred). The resolution is the number of distinct values to try <em>per hyperparameter</em>, which means in our example the tuner will construct a 5x5 grid of 25 configurations of equally spaced points between the specified upper and lower bounds. All configurations will be tried by the tuner (in random order) until either all configurations are evaluated or the terminator (<a href="#sec-terminator" class="quarto-xref"><span>Section 4.1.2</span></a>) signals that the budget is exhausted. For grid and random search tuners, the <code>batch_size</code> parameter controls how many configurations are evaluated at the same time when parallelization is enabled (see <a href="../chapter10/advanced_technical_aspects_of_mlr3.html#sec-parallel-tuning" class="quarto-xref"><span>Section 10.1.3</span></a>), and also determines how many configurations should be applied before the terminator should check if the termination criterion has been reached.</p>
<div class="cell">
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tuner</span> <span class="op">=</span> <span class="fu">tnr</span><span class="op">(</span><span class="st">"grid_search"</span>, resolution <span class="op">=</span> <span class="fl">5</span>, batch_size <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">tuner</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;TunerBatchGridSearch&gt;: Grid Search ──────────────────────────────────
• Parameters: batch_size=10, resolution=5
• Parameter classes: &lt;ParamLgl&gt;, &lt;ParamInt&gt;, &lt;ParamDbl&gt;, and &lt;ParamFct&gt;
• Properties: dependencies, single-crit, and multi-crit
• Packages: mlr3tuning and bbotk</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>The <code>resolution</code> and <code>batch_size</code> parameters are termed control parameters of the tuner, and other tuners will have other control parameters that can be set, as with learners these are accessible with <code>$param_set</code>.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Control Parameters</span></div></div>
<div class="cell">
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tuner</span><span class="op">$</span><span class="va">param_set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(3)&gt;
                  id    class lower upper nlevels        default  value
1:        batch_size ParamInt     1   Inf     Inf &lt;NoDefault[0]&gt;     10
2:        resolution ParamInt     1   Inf     Inf &lt;NoDefault[0]&gt;      5
3: param_resolutions ParamUty    NA    NA     Inf &lt;NoDefault[0]&gt; [NULL]</code></pre>
</div>
</div>
<p>While changing the control parameters of the tuner can improve optimal performance, we have to take care that is likely the default settings will fit most needs. While it is not possible to cover all application cases, <code>mlr3tuning</code>’s defaults were chosen to work well in most cases. However, some control parameters like <code>batch_size</code> often interact with the parallelization setup (further described in <a href="../chapter10/advanced_technical_aspects_of_mlr3.html#sec-parallel-tuning" class="quarto-xref"><span>Section 10.1.3</span></a>) and may need to be adjusted accordingly.</p>
</section><section id="triggering-the-tuning-process" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="triggering-the-tuning-process">Triggering the tuning process</h4>
<p>Now that we have introduced all our components, we can start the tuning process. To do this we simply pass the constructed <a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceBatchSingleCrit.html"><code>TuningInstanceBatchSingleCrit</code></a> to the <code>$optimize()</code> method of the initialized <a href="https://mlr3tuning.mlr-org.com/reference/TunerBatch.html"><code>TunerBatch</code></a>, which triggers the hyperparameter optimization loop (<a href="#fig-optimization-loop-basic" class="quarto-xref">Figure&nbsp;<span>4.1</span></a>).</p>
<div class="cell">
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tuner</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost gamma learner_param_vals  x_domain classif.ce
1: 25000   0.1          &lt;list[4]&gt; &lt;list[2]&gt;     0.2687</code></pre>
</div>
</div>
<p>The optimizer returns the best hyperparameter configuration and the corresponding performance, this information is also stored in <code>instance$result</code>. The first columns (here <code>cost</code> and <code>gamma</code>) will be named after the tuned hyperparameters and show the optimal values from the searched tuning spaces. The <code>$learner_param_vals</code> field of the <code>$result</code> lists the optimal hyperparameters from tuning, as well as the values of any other hyperparameters that were set, this is useful for onward model use (<a href="#sec-analyzing-result" class="quarto-xref"><span>Section 4.1.6</span></a>).</p>
<div class="cell">
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">$</span><span class="va">learner_param_vals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[[1]]$kernel
[1] "radial"

[[1]]$type
[1] "C-classification"

[[1]]$cost
[1] 25000

[[1]]$gamma
[1] 0.1</code></pre>
</div>
</div>
<p>The <code>$x_domain</code> field is most useful in the context of hyperparameter transformations, which we will briefly turn to next.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Overconfident Performance Estimates
</div>
</div>
<div class="callout-body-container callout-body">
<p>A common mistake when tuning is to report the performance estimated on the resampling sets on which the tuning was performed (<code>instance$result$classif.ce</code>) as an unbiased estimate of the model’s performance and to ignore its optimistic bias. The correct method is to test the model on more unseen data, which can be efficiently performed with nested resampling, we will discuss this in <a href="#sec-resample-overfitting" class="quarto-xref"><span>Section 4.3.2</span></a>.</p>
</div>
</div>
</section></section><section id="sec-logarithmic-transformations" class="level3" data-number="4.1.5"><h3 data-number="4.1.5" class="anchored" data-anchor-id="sec-logarithmic-transformations">
<span class="header-section-number">4.1.5</span> Logarithmic Transformations</h3>
<p>For many non-negative hyperparameters that have a large upper bound, tuning on a logarithmic scale can be more efficient than tuning on a linear scale. By example, consider sampling uniformly in the interval <span class="math inline">\([\log(1e-5), \log(1e5)]\)</span> and then exponentiating the outcome, the histograms in <a href="#fig-logscale" class="quarto-xref">Figure&nbsp;<span>4.2</span></a> show how we are initially sampling within a narrow range (<span class="math inline">\([-11.5, 11.5]\)</span>) but then exponentiating results in the majority of points being relatively small but a few being very large.</p>
<div class="cell">
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">cost</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1e-5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1e5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">exp_cost</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">cost</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-logscale" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-logscale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-logscale" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-logscale-1" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] with roughly equal length bars. Right plot shows values between [1e-5, 1e5] with the vast majority close to 0 and very few at other points.">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-logscale-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="hyperparameter_optimization_files/figure-html/fig-logscale-1.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-logscale" alt="Left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] with roughly equal length bars. Right plot shows values between [1e-5, 1e5] with the vast majority close to 0 and very few at other points.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-logscale-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Linear scale sampled by the tuner.
</figcaption></figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-logscale" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-logscale-2" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] with roughly equal length bars. Right plot shows values between [1e-5, 1e5] with the vast majority close to 0 and very few at other points.">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-logscale-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="hyperparameter_optimization_files/figure-html/fig-logscale-2.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-logscale" alt="Left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] with roughly equal length bars. Right plot shows values between [1e-5, 1e5] with the vast majority close to 0 and very few at other points.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-logscale-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Logarithmic scale seen by the learner.
</figcaption></figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-logscale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.2: Histograms of uniformly sampled values from the interval <span class="math inline">\([\log(1e-5), \log(1e5)]\)</span> before (left) and after (right) exponentiation.
</figcaption></figure>
</div>
<p>To add this transformation to a hyperparameter we simply pass <code>logscale = TRUE</code> to <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">ti</span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">learner</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu">trm</span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">tuner</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost  gamma learner_param_vals  x_domain classif.ce
1: 5.756 -5.756          &lt;list[4]&gt; &lt;list[2]&gt;     0.1925</code></pre>
</div>
</div>
<p>We can see from this example that using the log transformation improved the hyperparameter search, as <code>classif.ce</code> is smaller.</p>
<p>Note that the fields <code>cost</code> and <code>gamma</code> show the optimal values <em>before</em> transformation, whereas <code>x_domain</code> and <code>learner_param_vals</code> contain optimal values <em>after</em> transformation, it is these latter fields you would take forward for future model use.</p>
<div class="cell">
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">$</span><span class="va">x_domain</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[[1]]$cost
[1] 316.2

[[1]]$gamma
[1] 0.003162</code></pre>
</div>
</div>
<p>In <a href="#sec-defining-search-spaces" class="quarto-xref"><span>Section 4.4</span></a> we will look at how to implement more complex, custom transformations for any hyperparameter or combination of hyperparameters. Now we will look at how to put everything into practice so we can make use of the tuned model (and the transformed hyperparameters).</p>
</section><section id="sec-analyzing-result" class="level3" data-number="4.1.6"><h3 data-number="4.1.6" class="anchored" data-anchor-id="sec-analyzing-result">
<span class="header-section-number">4.1.6</span> Analyzing and Using the Result</h3>
<p>Independently of whether you use <a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/tune.html"><code>tune()</code></a>, or if you include transformations or not, the created objects and the output are structurally the same and the instance’s archive lists all evaluated hyperparameter configurations:</p>
<div class="cell">
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fu">.</span><span class="op">(</span><span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     cost   gamma classif.ce
1: -11.51 -11.513     0.5621
2: -11.51  -5.756     0.5621
3: -11.51  11.513     0.5621</code></pre>
</div>
</div>
<p>Each row of the archive is a different evaluated configuration. The columns show the tested configurations (before transformation) and the chosen performance measure. We can also manually inspect the archive to determine other important features such as time of evaluation, model runtime, and any errors or warnings that occurred during tuning.</p>
<div class="cell">
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">timestamp</span>, <span class="va">runtime_learners</span>, <span class="va">errors</span>, <span class="va">warnings</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             timestamp runtime_learners errors warnings
1: 2025-10-07 07:29:46            0.239      0        0
2: 2025-10-07 07:29:46            0.034      0        0
3: 2025-10-07 07:29:46            0.038      0        0</code></pre>
</div>
</div>
<p>Another powerful feature of the instance is that we can score the internal <a href="https://mlr3.mlr-org.com/reference/ResampleResult.html"><code>ResampleResult</code></a>s on a different performance measure, for example looking at false negative rate and false positive rate as well as classification error:</p>
<div class="cell">
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msrs</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.fpr"</span>, <span class="st">"classif.fnr"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span> ,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span>, <span class="va">classif.fpr</span>, <span class="va">classif.fnr</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     cost   gamma classif.ce classif.fpr classif.fnr
1: -11.51 -11.513     0.5621      0.6667      0.3333
2: -11.51  -5.756     0.5621      0.6667      0.3333
3: -11.51  11.513     0.5621      0.6667      0.3333
4:   0.00 -11.513     0.5621      0.6667      0.3333
5:   0.00  -5.756     0.2695      0.3392      0.1655</code></pre>
</div>
</div>
<p>You can access all the resamplings combined in a <a href="https://mlr3.mlr-org.com/reference/BenchmarkResult.html"><code>BenchmarkResult</code></a> object with <code>instance$archive$benchmark_result</code>.</p>
<p>Finally, to visualize the results, you can use <a href="https://mlr3viz.mlr-org.com/reference/autoplot.TuningInstanceBatchSingleCrit.html"><code>autoplot.TuningInstanceBatchSingleCrit</code></a> (<a href="#fig-surface" class="quarto-xref">Figure&nbsp;<span>4.3</span></a>). In this example we can observe one of the flaws (by design) in grid search, despite testing 25 configurations, we only saw five unique values for each hyperparameter.</p>
<div class="cell">
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">instance</span>, type <span class="op">=</span> <span class="st">"surface"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-surface" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Heatmap showing model performance during HPO. y-axis is 'gamma' parameter between (-10,10) and x-axis is 'cost' parameter between (-10,10). The heatmap shows squares covering all points on the plot and circular points indicating configurations tried in our optimization. The top-left quadrant is all yellow indicating poor performance when gamma is high and cost is low. The bottom-right is dark blue indicating good performance when cost is high and gamma is low.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-surface-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="hyperparameter_optimization_files/figure-html/fig-surface-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Heatmap showing model performance during HPO. y-axis is 'gamma' parameter between (-10,10) and x-axis is 'cost' parameter between (-10,10). The heatmap shows squares covering all points on the plot and circular points indicating configurations tried in our optimization. The top-left quadrant is all yellow indicating poor performance when gamma is high and cost is low. The bottom-right is dark blue indicating good performance when cost is high and gamma is low.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-surface-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.3: Model performance with different configurations for <code>cost</code> and <code>gamma</code>. Bright yellow regions represent the model performing worse and dark blue performing better. We can see that high <code>cost</code> values and low <code>gamma</code> values achieve the best performance. Note that we should not directly infer the performance of new unseen values from the heatmap since it is only an interpolation based on a surrogate model (<code>regr.ranger</code>). However, we can see the general interaction between the hyperparameters.
</figcaption></figure>
</div>
</div>
</div>
<section id="training-an-optimized-model" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="training-an-optimized-model">Training an optimized model</h4>
<p>Once we found good hyperparameters for our learner through tuning, we can use them to train a final model on the whole data. To do this we simply construct a new learner with the same underlying algorithm and set the learner hyperparameters to the optimal configuration:</p>
<div class="cell">
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_svm_tuned</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span><span class="op">)</span></span>
<span><span class="va">lrn_svm_tuned</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span> <span class="op">=</span> <span class="va">instance</span><span class="op">$</span><span class="va">result_learner_param_vals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can train the learner on the full dataset and we are ready to make predictions.</p>
<div class="cell">
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_svm_tuned</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_sonar</span><span class="op">)</span><span class="op">$</span><span class="va">model</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
svm.default(x = data, y = task$truth(), type = "C-classification", 
    kernel = "radial", gamma = 0.00316227766016838, cost = 316.227766016838, 
    probability = (self$predict_type == "prob"))


Parameters:
   SVM-Type:  C-classification 
 SVM-Kernel:  radial 
       cost:  316.2 

Number of Support Vectors:  93</code></pre>
</div>
</div>
</section></section></section><section id="sec-autotuner" class="level2" data-number="4.2"><h2 data-number="4.2" class="anchored" data-anchor-id="sec-autotuner">
<span class="header-section-number">4.2</span> Convenient Tuning with <code>tune</code> and <code>auto_tuner</code>
</h2>
<p>In the previous section, we looked at constructing and manually putting together the components of HPO by creating a tuning instance using <a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a>, passing this to the tuner, and then calling <code>$optimize()</code> to start the tuning process. <code>mlr3tuning</code> includes two helper methods to simplify this process further.</p>
<p>The first helper function is <a href="https://mlr3tuning.mlr-org.com/reference/tune.html"><code>tune()</code></a>, which creates the tuning instance and calls <code>$optimize()</code> for you. You may prefer the manual method with <code><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti()</a></code> if you want to view and make changes to the instance before tuning.</p>
<div class="cell">
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tnr_grid_search</span> <span class="op">=</span> <span class="fu">tnr</span><span class="op">(</span><span class="st">"grid_search"</span>, resolution <span class="op">=</span> <span class="fl">5</span>, batch_size <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">lrn_svm</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">rsmp_cv3</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">msr_ce</span> <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">tune</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_grid_search</span>,</span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_svm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_cv3</span>,</span>
<span>  measures <span class="op">=</span> <span class="va">msr_ce</span></span>
<span><span class="op">)</span></span>
<span><span class="va">instance</span><span class="op">$</span><span class="va">result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   cost  gamma learner_param_vals  x_domain classif.ce
1:    0 -5.756          &lt;list[4]&gt; &lt;list[2]&gt;     0.2117</code></pre>
</div>
</div>
<p>The other helper function is <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html"><code>auto_tuner</code></a>, which creates an object of class <a href="https://mlr3tuning.mlr-org.com/reference/AutoTuner.html"><code>AutoTuner</code></a> (<a href="#fig-auto-tuner" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>). The <code>AutoTuner</code> inherits from the <a href="https://mlr3.mlr-org.com/reference/Learner.html"><code>Learner</code></a> class and wraps all the information needed for tuning, which means you can treat a learner waiting to be optimized just like any other learner. Under the hood, the <code>AutoTuner</code> essentially runs <code><a href="https://mlr3tuning.mlr-org.com/reference/tune.html">tune()</a></code> on the data that is passed to the model when <code>$train()</code> is called and then sets the learner parameters to the optimal configuration.</p>
<div class="cell">
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_grid_search</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_svm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_cv3</span>,</span>
<span>  measure <span class="op">=</span> <span class="va">msr_ce</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">at</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;AutoTuner&gt; (classif.svm.tuned) ──────────────────────────────────────
• Model: -
• Parameters: list()
• Packages: mlr3, mlr3tuning, mlr3learners, and e1071
• Predict Types: [response] and prob
• Feature Types: logical, integer, and numeric
• Encapsulation: none (fallback: -)
• Properties: multiclass and twoclass
• Other settings: use_weights = 'error'
• Search Space:
      id    class  lower upper nlevels
1:  cost ParamDbl -11.51 11.51     Inf
2: gamma ParamDbl -11.51 11.51     Inf</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-auto-tuner" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Flow diagram. Top box &quot;Input: Training Data, Learner, Performance Metric, Resampling Strategy, Search Space&quot;. This has an arrow to &quot;Auto-Tuner&quot; which is a box containing &quot;Tuning&quot;, which has three arrows pointing at each other in a circle representing the tuning process, and &quot;Final Model Fit: Fit Learner with Optimal Hyperparameters on Dtrain&quot;. &quot;Auto-Tuner&quot; then points to &quot;Return: Model, Optimal Hyperparameters&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-auto-tuner-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-12.svg" class="img-fluid figure-img" style="width:60.0%" alt="Flow diagram. Top box &quot;Input: Training Data, Learner, Performance Metric, Resampling Strategy, Search Space&quot;. This has an arrow to &quot;Auto-Tuner&quot; which is a box containing &quot;Tuning&quot;, which has three arrows pointing at each other in a circle representing the tuning process, and &quot;Final Model Fit: Fit Learner with Optimal Hyperparameters on Dtrain&quot;. &quot;Auto-Tuner&quot; then points to &quot;Return: Model, Optimal Hyperparameters&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-auto-tuner-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.4: Illustration of an Auto-Tuner.
</figcaption></figure>
</div>
</div>
</div>
<p>And we can now call <code>$train()</code>, which will first tune the hyperparameters in the search space listed above before fitting the optimal model.</p>
<div class="cell">
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">split</span> <span class="op">=</span> <span class="fu">partition</span><span class="op">(</span><span class="va">tsk_sonar</span><span class="op">)</span></span>
<span><span class="va">at</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_sonar</span>, row_ids <span class="op">=</span> <span class="va">split</span><span class="op">$</span><span class="va">train</span><span class="op">)</span></span>
<span><span class="va">at</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span><span class="va">tsk_sonar</span>, row_ids <span class="op">=</span> <span class="va">split</span><span class="op">$</span><span class="va">test</span><span class="op">)</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
    0.2029 </code></pre>
</div>
</div>
<p>The <code>AutoTuner</code> contains a tuning instance that can be analyzed like any other instance.</p>
<div class="cell">
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span><span class="op">$</span><span class="va">tuning_instance</span><span class="op">$</span><span class="va">result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost  gamma learner_param_vals  x_domain classif.ce
1: 5.756 -5.756          &lt;list[4]&gt; &lt;list[2]&gt;     0.1509</code></pre>
</div>
</div>
<p>We could also pass the <code>AutoTuner</code> to <a href="https://mlr3.mlr-org.com/reference/resample.html"><code>resample()</code></a> and <a href="https://mlr3.mlr-org.com/reference/benchmark.html"><code>benchmark()</code></a>, which would result in a nested resampling, discussed next.</p>
</section><section id="sec-nested-resampling" class="level2 page-columns page-full" data-number="4.3"><h2 data-number="4.3" class="anchored" data-anchor-id="sec-nested-resampling">
<span class="header-section-number">4.3</span> Nested Resampling</h2>
<p>HPO requires additional resampling to reduce bias when estimating the performance of a model. If the same data is used for determining the optimal configuration and the evaluation of the resulting model itself, the actual performance estimate might be biased <span class="citation" data-cites="Simon2007">(<a href="../references.html#ref-Simon2007" role="doc-biblioref">Simon 2007</a>)</span>. This is analogous to optimism of the training error described in <span class="citation" data-cites="james_introduction_2014">James et al. (<a href="../references.html#ref-james_introduction_2014" role="doc-biblioref">2014</a>)</span>, which occurs when training error is taken as an estimate of out-of-sample performance.</p>
<p>Nested resampling separates model optimization from the process of estimating the performance of the tuned model by adding an additional resampling, i.e., while model performance is estimated using a resampling method in the ‘usual way’, tuning is then performed by resampling the resampled data (<a href="#fig-nested-resampling" class="quarto-xref">Figure&nbsp;<span>4.5</span></a>). For more details and a formal introduction to nested resampling the reader is referred to <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="../references.html#ref-hpo_practical" role="doc-biblioref">2023</a>)</span> and <span class="citation" data-cites="Simon2007">Simon (<a href="../references.html#ref-Simon2007" role="doc-biblioref">2007</a>)</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-nested-resampling" class="quarto-float quarto-figure quarto-figure-center anchored" alt="The image shows three rows of large blocks representing three-fold CV for the outer resampling. Below the blocks are four further rows of small blocks representing four-fold CV for the inner resampling. Text annotations highlight how tuned parameters from the inner resampling are passed to the outer resampling.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-nested-resampling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-11.svg" class="img-fluid figure-img" style="width:80.0%" alt="The image shows three rows of large blocks representing three-fold CV for the outer resampling. Below the blocks are four further rows of small blocks representing four-fold CV for the inner resampling. Text annotations highlight how tuned parameters from the inner resampling are passed to the outer resampling.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-nested-resampling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.5: An illustration of nested resampling. The large blocks represent three-fold CV for the outer resampling for model evaluation and the small blocks represent four-fold CV for the inner resampling for HPO. The light blue blocks are the training sets and the dark blue blocks are the test sets.
</figcaption></figure>
</div>
</div>
</div>
<p><a href="#fig-nested-resampling" class="quarto-xref">Figure&nbsp;<span>4.5</span></a> represents the following example of nested resampling:</p>
<ol type="1">
<li>Outer resampling start – Instantiate three-fold CV to create different testing and training datasets.</li>
<li>Inner resampling – Within the outer training data instantiate four-fold CV to create different inner testing and training datasets.</li>
<li>HPO – Tune the hyperparameters on the outer training set (large, light blue blocks) using the inner data splits.</li>
<li>Training – Fit the learner on the outer training dataset using the optimal hyperparameter configuration obtained from the inner resampling (small blocks).</li>
<li>Evaluation – Evaluate the performance of the learner on the outer testing data (large, dark blue block).</li>
<li>Outer resampling repeats – Repeat (2)-(5) for each of the three outer folds.</li>
<li>Aggregation – Take the sample mean of the three performance values for an unbiased performance estimate.</li>
</ol>
<p>The inner resampling produces generalization performance estimates for each configuration and selects the optimal configuration to be evaluated on the outer resampling. The outer resampling then produces generalization estimates for these optimal configurations. The result from the outer resampling can be used for comparison to other models trained and tested on the same outer folds.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nested Resampling and Parallelization
</div>
</div>
<div class="callout-body-container callout-body">
<p>Nested resampling is computationally expensive, three outer folds and four inner folds with a grid search of resolution five used to tune two parameters, results in <span class="math inline">\(3*4*5^2 = 300\)</span> iterations of model training/testing. If you have the resources we recommend utilizing parallelization when tuning (<a href="../chapter10/advanced_technical_aspects_of_mlr3.html#sec-parallelization" class="quarto-xref"><span>Section 10.1</span></a>).</p>
</div>
</div>
<p>A common mistake is to think of nested resampling as a method to select optimal model configurations. Nested resampling is a method to compare models and to estimate the generalization performance of a tuned model, however, this is the performance based on multiple different configurations (one from each outer fold) and not performance based on a <em>single</em> configuration (<a href="#sec-resample-overfitting" class="quarto-xref"><span>Section 4.3.2</span></a>). If you are interested in identifying optimal configurations, then use <a href="https://mlr3tuning.mlr-org.com/reference/tune.html"><code>tune()</code></a>/<a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html"><code>auto_tuner()</code></a> with <code>$train()</code> on the complete dataset.</p>
<section id="nested-resampling-with-an-autotuner" class="level3" data-number="4.3.1"><h3 data-number="4.3.1" class="anchored" data-anchor-id="nested-resampling-with-an-autotuner">
<span class="header-section-number">4.3.1</span> Nested Resampling with an <code>AutoTuner</code>
</h3>
<p>While the theory of nested resampling may seem complicated, it is all automated in <code>mlr3tuning</code> by simply passing an <code>AutoTuner</code> to <a href="https://mlr3.mlr-org.com/reference/resample.html"><code>resample()</code></a> or <a href="https://mlr3.mlr-org.com/reference/benchmark.html"><code>benchmark()</code></a>. Continuing with our previous example, we will use the auto-tuner to resample a support vector classifier with three-fold CV in the outer resampling and four-fold CV in the inner resampling.</p>
<div class="cell">
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_grid_search</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_svm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">4</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="va">msr_ce</span>,</span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">rr</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_sonar</span>, <span class="va">at</span>, <span class="va">rsmp_cv3</span>, store_models <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rr</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;ResampleResult&gt; with 3 resampling iterations ────────────────────────
 task_id        learner_id resampling_id iteration     prediction_test
   sonar classif.svm.tuned            cv         1 &lt;PredictionClassif&gt;
   sonar classif.svm.tuned            cv         2 &lt;PredictionClassif&gt;
   sonar classif.svm.tuned            cv         3 &lt;PredictionClassif&gt;
2 variables not shown: [warnings, errors]</code></pre>
</div>
</div>
<p>Note that we set <code>store_models = TRUE</code> so that the <code>AutoTuner</code> models (fitted on the outer training data) are stored, which also enables investigation of the inner tuning instances. While we used k-fold CV for both the inner and outer resampling strategy, you could use different resampling strategies (<a href="../chapter3/evaluation_and_benchmarking.html#sec-resampling" class="quarto-xref"><span>Section 3.2</span></a>) and also different parallelization methods (<a href="../chapter10/advanced_technical_aspects_of_mlr3.html#sec-nested-resampling-parallelization" class="quarto-xref"><span>Section 10.1.4</span></a>).</p>
<p>The estimated performance of a tuned model is reported as the aggregated performance of all outer resampling iterations, which is a less biased estimate of future model performance.</p>
<div class="cell">
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
    0.2017 </code></pre>
</div>
</div>
<p>In addition to the methods described in <a href="../chapter3/evaluation_and_benchmarking.html#sec-resampling" class="quarto-xref"><span>Section 3.2</span></a>, <a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_results.html"><code>extract_inner_tuning_results()</code></a> and <a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_archives.html"><code>extract_inner_tuning_archives()</code></a> return the optimal configurations (across all outer folds) and full tuning archives, respectively.</p>
<div class="cell">
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">extract_inner_tuning_results</span><span class="op">(</span><span class="va">rr</span><span class="op">)</span><span class="op">[</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">iteration</span>, <span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   iteration   cost   gamma classif.ce
1:         1 11.513  -5.756     0.1655
2:         2  5.756  -5.756     0.2013
3:         3 11.513 -11.513     0.2027</code></pre>
</div>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">extract_inner_tuning_archives</span><span class="op">(</span><span class="va">rr</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">iteration</span>, <span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   iteration  cost   gamma classif.ce
1:         1 0.000 -11.513     0.4321
2:         1 0.000   5.756     0.4679
3:         1 5.756   5.756     0.4679</code></pre>
</div>
</div>
</section><section id="sec-resample-overfitting" class="level3 page-columns page-full" data-number="4.3.2"><h3 data-number="4.3.2" class="anchored" data-anchor-id="sec-resample-overfitting">
<span class="header-section-number">4.3.2</span> The Right (and Wrong) Way to Estimate Performance</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<div class="page-columns page-full"><p>In this short section we will empirically demonstrate that directly reporting tuning performance without nested resampling results in optimistically biased performance estimates. In this experiment we tune several parameters from <code>lrn("classif.xgboost")</code>. To best estimate the generalization performance we make use of the <code>"moons"</code> <a href="https://mlr3.mlr-org.com/reference/TaskGenerator.html"><code>TaskGenerator</code></a>. The <code>TaskGenerator</code> class is used when you want to simulate data for use in experiments, these are very useful in cases such as this experiment when you need access to an infinite number of data points to estimate quantities such as the generalization error.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>TaskGenerator</code></span></div></div>
<p>We begin by loading our learner, task generator, and generating 100 training data points and 1,000,000 testing data points.</p>
<div class="cell">
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">lrn_xgboost</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.xgboost"</span>,</span>
<span>  eta               <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-4</span>, <span class="fl">1</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  max_depth         <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>,</span>
<span>  colsample_bytree  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  colsample_bylevel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  lambda            <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-3</span>, <span class="fl">1e3</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  alpha             <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-3</span>, <span class="fl">1e3</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  subsample         <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">tsk_moons</span> <span class="op">=</span> <span class="fu">tgen</span><span class="op">(</span><span class="st">"moons"</span><span class="op">)</span></span>
<span><span class="va">tsk_moons_train</span> <span class="op">=</span> <span class="va">tsk_moons</span><span class="op">$</span><span class="fu">generate</span><span class="op">(</span><span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">tsk_moons_test</span> <span class="op">=</span> <span class="va">tsk_moons</span><span class="op">$</span><span class="fu">generate</span><span class="op">(</span><span class="fl">1000000</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we will tune the learner with respect to the classification error, using holdout resampling and random search with 700 evaluations. We then report the tuning performance without nested resampling.</p>
<div class="cell">
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tnr_random</span> <span class="op">=</span> <span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span></span>
<span><span class="va">rsmp_holdout</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span></span>
<span><span class="va">trm_evals700</span> <span class="op">=</span> <span class="fu">trm</span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">700</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">tune</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_random</span>,</span>
<span>  task <span class="op">=</span> <span class="va">tsk_moons_train</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_xgboost</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_holdout</span>,</span>
<span>  measures <span class="op">=</span> <span class="va">msr_ce</span>,</span>
<span>  terminator <span class="op">=</span> <span class="va">trm_evals700</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">insample</span> <span class="op">=</span> <span class="va">instance</span><span class="op">$</span><span class="va">result_y</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we estimate generalization error by nested resampling (below we use an outer five-fold CV), using an <code>AutoTuner</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># same setup as above</span></span>
<span><span class="va">at</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_random</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_xgboost</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_holdout</span>,</span>
<span>  measure <span class="op">=</span> <span class="va">msr_ce</span>,</span>
<span>  terminator <span class="op">=</span> <span class="va">trm_evals700</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">rsmp_cv5</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outsample</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_moons_train</span>, <span class="va">at</span>, <span class="va">rsmp_cv5</span><span class="op">)</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And finally, we estimate the generalization error by training the tuned learner (i.e., using the values from the <code>instance</code> above) on the full training data again and predicting on the test data.</p>
<div class="cell">
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_xgboost_tuned</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.xgboost"</span><span class="op">)</span></span>
<span><span class="va">lrn_xgboost_tuned</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span></span>
<span>  .values <span class="op">=</span> <span class="va">instance</span><span class="op">$</span><span class="va">result_learner_param_vals</span><span class="op">)</span></span>
<span><span class="va">generalization</span> <span class="op">=</span> <span class="va">lrn_xgboost_tuned</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_moons_train</span><span class="op">)</span><span class="op">$</span></span>
<span>  <span class="fu">predict</span><span class="op">(</span><span class="va">tsk_moons_test</span><span class="op">)</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can compare these three values:</p>
<div class="cell">
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>true_generalization <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">generalization</span><span class="op">)</span>,</span>
<span>  without_nested_resampling <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">insample</span><span class="op">)</span>,</span>
<span>  with_nested_resampling <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">outsample</span><span class="op">)</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      true_generalization without_nested_resampling 
                     0.10                      0.06 
   with_nested_resampling 
                     0.09 </code></pre>
</div>
</div>
<p>We find that the performance estimate from unnested tuning optimistically overestimates the true performance (which could indicate ‘meta-overfitting’ to the specific inner holdout-splits), while the outer estimate from nested resampling works much better.</p>
</section></section><section id="sec-defining-search-spaces" class="level2" data-number="4.4"><h2 data-number="4.4" class="anchored" data-anchor-id="sec-defining-search-spaces">
<span class="header-section-number">4.4</span> More Advanced Search Spaces</h2>
<p>Up until now, we have only considered tuning simple search spaces limited to a few numeric hyperparameters. In this section, we will first look at how to tune different scalar parameter classes with <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a>, and then how to define your own search space with <a href="https://paradox.mlr-org.com/reference/ParamSet.html"><code>ParamSet</code></a> to create more advanced search spaces that may include tuning over vectors, transformations, and handling parameter dependencies. Finally, we will consider how to access a database of standardized search spaces from the literature.</p>
<section id="scalar-parameter-tuning" class="level3" data-number="4.4.1"><h3 data-number="4.4.1" class="anchored" data-anchor-id="scalar-parameter-tuning">
<span class="header-section-number">4.4.1</span> Scalar Parameter Tuning</h3>
<p>The <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a> function can be used to tune parameters of any class, whether they are scalar or vectors. To best understand this function, we will consider what is happening behind the scenes. When <code>to_tune()</code> is used in a learner, implicitly a <a href="https://paradox.mlr-org.com/reference/ParamSet.html"><code>ParamSet</code></a> is created just for the tuning search space:</p>
<div class="cell">
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(2)&gt;
      id    class lower upper nlevels        default  value
1:  cost ParamDbl   0.1 1e+05     Inf &lt;NoDefault[0]&gt; [NULL]
2: gamma ParamDbl   0.1 1e+00     Inf &lt;NoDefault[0]&gt; [NULL]</code></pre>
</div>
</div>
<p>Recall from <a href="../chapter2/data_and_basic_modeling.html#sec-param-set" class="quarto-xref"><span>Section 2.2.3</span></a>, that the <code>class</code> field corresponds to the hyperparameter class as defined in <a href="https://paradox.mlr-org.com"><code>paradox</code></a>. In this example, we can see that <code>gamma</code> hyperparameter has class <code>ParamDbl</code>, with <code>lower = 0.1</code> and <code>upper = 1</code>, which was automatically created by <code>to_tune()</code> as we passed two numeric values to this function. If we wanted to tune over a non-numeric hyperparameter, we can still use <code>to_tune()</code>, which will infer the correct class to construct in the resulting parameter set. For example, say we wanted to tune the numeric <code>cost</code>, factor <code>kernel</code>, and logical <code>scale</code> hyperparameter in our SVM:</p>
<div class="cell">
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"radial"</span>, <span class="st">"linear"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  shrinking <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="op">)</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(3)&gt;
          id    class lower upper nlevels        default  value
1:      cost ParamDbl   0.1 1e+05     Inf &lt;NoDefault[0]&gt; [NULL]
2:    kernel ParamFct    NA    NA       2 &lt;NoDefault[0]&gt; [NULL]
3: shrinking ParamLgl    NA    NA       2           TRUE [NULL]</code></pre>
</div>
</div>
<p>Here the <code>kernel</code> hyperparameter is a factor, so we simply pass in a vector corresponding to the levels we want to tune over. The <code>shrinking</code> hyperparameter is a logical, there are only two possible values this could take so we do not need to pass anything to <code>to_tune()</code>, it will automatically recognize this is a logical from <code>learner$param_set</code> and passes this detail to <code>learner$param_set$search_space()</code>. Similarly, for factor parameters, we could also use <code>to_tune()</code> without any arguments if we want to tune over all possible values. Finally, we can use <code>to_tune()</code> to treat numeric parameters as factors if we want to discretize them over a small subset of possible values, for example, if we wanted to find the optimal number of trees in a random forest we might only consider three scenarios: 100, 200, or 400 trees:</p>
<div class="cell">
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.ranger"</span>, num.trees <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">200</span>, <span class="fl">400</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Before we look at tuning over vectors, we must first learn how to create parameter sets from scratch.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Ordered Hyperparameters
</div>
</div>
<div class="callout-body-container callout-body">
<p>Treating an integer as a factor for tuning results in “unordered” hyperparameters. Therefore algorithms that make use of ordering information will perform worse when ordering is ignored. For these algorithms, it would make more sense to define a <code>ParamDbl</code> or <code>ParamInt</code> (<a href="#sec-tune-ps" class="quarto-xref"><span>Section 4.4.2</span></a>) with a custom transformation (<a href="#sec-tune-trafo" class="quarto-xref"><span>Section 4.4.3</span></a>).</p>
</div>
</div>
</section><section id="sec-tune-ps" class="level3" data-number="4.4.2"><h3 data-number="4.4.2" class="anchored" data-anchor-id="sec-tune-ps">
<span class="header-section-number">4.4.2</span> Defining Search Spaces with <code>ps</code>
</h3>
<p>As we have seen, <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a> is a helper function that creates a parameter set that will go on to be used by <a href="https://mlr3tuning.mlr-org.com/reference/tune.html"><code>tune()</code></a>, <a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a>, or <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html"><code>auto_tuner()</code></a> during the tuning process. However, there will be use cases where you will need to create a parameter set manually using <a href="https://paradox.mlr-org.com/reference/ps.html"><code>ps()</code></a>. This function takes named arguments of class <a href="https://paradox.mlr-org.com/reference/Domain.html"><code>Domain</code></a>, which can be created using the sugar functions in <a href="#tbl-paradox-define" class="quarto-xref">Table&nbsp;<span>4.3</span></a>.</p>
<div id="tbl-paradox-define" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-paradox-define-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.3: <a href="https://paradox.mlr-org.com/reference/Domain.html"><code>Domain</code></a> Constructors and their resulting <a href="https://paradox.mlr-org.com/reference/Domain.html"><code>Domain</code></a>.
</figcaption><div aria-describedby="tbl-paradox-define-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead><tr class="header">
<th>Constructor</th>
<th>Description</th>
<th>Underlying Class</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html"><code>p_dbl</code></a></td>
<td>Real valued parameter (“double”)</td>
<td><code>ParamDbl</code></td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html"><code>p_int</code></a></td>
<td>Integer parameter</td>
<td><code>ParamInt</code></td>
</tr>
<tr class="odd">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html"><code>p_fct</code></a></td>
<td>Discrete valued parameter (“factor”)</td>
<td><code>ParamFct</code></td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html"><code>p_lgl</code></a></td>
<td>Logical / Boolean parameter</td>
<td><code>ParamLgl</code></td>
</tr>
<tr class="odd">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html"><code>p_uty</code></a></td>
<td>Untyped parameter</td>
<td><code>ParamUty</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>As a simple example, let us look at how to create a search space to tune <code>cost</code> and <code>gamma</code> again:</p>
<div class="cell">
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  cost  <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">1e-1</span>, upper <span class="op">=</span> <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"radial"</span>, <span class="st">"linear"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  shrinking <span class="op">=</span> <span class="fu">p_lgl</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This search space would then be passed to the <code>search_space</code> argument in <code><a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html">auto_tuner()</a></code>:</p>
<div class="cell">
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ti</span><span class="op">(</span><span class="va">tsk_sonar</span>, <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>, type <span class="op">=</span> <span class="st">"C-classification"</span><span class="op">)</span>, <span class="va">rsmp_cv3</span>,</span>
<span>  <span class="va">msr_ce</span>, <span class="fu">trm</span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span>, search_space <span class="op">=</span> <span class="va">search_space</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;TuningInstanceBatchSingleCrit&gt; ──────────────────────────────────────
• State: Not optimized
• Objective: &lt;ObjectiveTuningBatch&gt;
• Search Space:
          id    class lower upper nlevels
1:      cost ParamDbl   0.1 1e+05     Inf
2:    kernel ParamFct    NA    NA       2
3: shrinking ParamLgl    NA    NA       2
• Terminator: &lt;TerminatorNone&gt;</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Bounded Search Spaces
</div>
</div>
<div class="callout-body-container callout-body">
<p>When manually creating search spaces, make sure all numeric hyperparameters in your search space are bounded, e.g., if you are trying to tune a hyperparameter that could take any value in <span class="math inline">\((-\infty, \infty)\)</span> then the tuning process will throw an error for nearly all tuners if you do not pass lower and upper limits to <code>p_dbl()</code> or <code>p_int()</code>. You can use <code>$is_bounded</code> on the constructed <a href="https://paradox.mlr-org.com/reference/ParamSet.html"><code>ParamSet</code></a> if you are unsure:</p>
<div class="cell">
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">0.1</span>, upper <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">is_bounded</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>cost 
TRUE </code></pre>
</div>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">0.1</span>, upper <span class="op">=</span> <span class="cn">Inf</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">is_bounded</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> cost 
FALSE </code></pre>
</div>
</div>
</div>
</div>
</section><section id="sec-tune-trafo" class="level3" data-number="4.4.3"><h3 data-number="4.4.3" class="anchored" data-anchor-id="sec-tune-trafo">
<span class="header-section-number">4.4.3</span> Transformations and Tuning Over Vectors</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>In <a href="#sec-logarithmic-transformations" class="quarto-xref"><span>Section 4.1.5</span></a> we saw how to quickly apply log transformations with <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a>. As you now know, <code>to_tune()</code> is just a wrapper that creates <a href="https://paradox.mlr-org.com/reference/ParamSet.html"><code>ParamSet</code></a> objects, so let us look at what is taking place when we set <code>logscale = TRUE</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>, cost <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span><span class="op">$</span></span>
<span>  <span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(1)&gt;
     id    class  lower upper nlevels        default  value
1: cost ParamDbl -11.51 11.51     Inf &lt;NoDefault[0]&gt; [NULL]
Trafo is set.</code></pre>
</div>
</div>
<p>Notice that now the <code>lower</code> and <code>upper</code> fields correspond to the transformed bounds, i.e.&nbsp;<span class="math inline">\([\log(1e-5), \log(1e5)]\)</span>. To manually create the same transformation, we can pass the transformation to the <code>trafo</code> argument in <code>p_dbl()</code> and set the bounds:</p>
<div class="cell">
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1e-5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="co"># alternatively: 'trafo = exp'</span></span>
<span><span class="va">search_space</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(1)&gt;
     id    class  lower upper nlevels        default  value
1: cost ParamDbl -11.51 11.51     Inf &lt;NoDefault[0]&gt; [NULL]
Trafo is set.</code></pre>
</div>
</div>
<p>We can confirm it is correctly set by making use of the <code>$trafo()</code> method, which takes a named list and applies the specified transformations</p>
<div class="cell">
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 2.718</code></pre>
</div>
</div>
<p>Where transformations become the most powerful is in the ability to pass arbitrary functions that can act on single parameters or even the entire parameter set. As an example, consider a simple transformation to add ‘2’ to our range:</p>
<div class="cell">
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span> <span class="op">+</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 3</code></pre>
</div>
</div>
<p>Simple transformations such as this can even be added directly to a learner by passing a <code>Param</code> object to <code>to_tune()</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu">p_dbl</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span> <span class="op">+</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>More complex transformations that require multiple arguments should be passed to the <code>.extra_trafo</code> parameter in <code>ps()</code>. <code>.extra_trafo</code> takes a function with parameters <code>x</code> and <code>param_set</code> where, during tuning, <code>x</code> will be a list containing the configuration being tested, and <code>param_set</code> is the whole parameter set. Below we first exponentiate the value of <code>cost</code> and then add ‘2’ if the <code>kernel</code> is <code>"polynomial"</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  .extra_trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">param_set</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">x</span><span class="op">$</span><span class="va">kernel</span> <span class="op">==</span> <span class="st">"polynomial"</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">x</span><span class="op">$</span><span class="va">cost</span> <span class="op">=</span> <span class="va">x</span><span class="op">$</span><span class="va">cost</span> <span class="op">+</span> <span class="fl">2</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">x</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span>
<span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span>, kernel <span class="op">=</span> <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 2.718

$kernel
[1] "radial"</code></pre>
</div>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span>, kernel <span class="op">=</span> <span class="st">"polynomial"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 4.718

$kernel
[1] "polynomial"</code></pre>
</div>
</div>
<section id="vector-transformations" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="vector-transformations">Vector transformations</h4>
<p>Any function can be passed to <code>trafo</code> and <code>.extra_trafo</code>, which enables tuning of ‘untyped’ parameters of class <code>ParamUty</code> that could be vectors, functions, or any non-atomic class. By example, consider the <code>class.weights</code> parameter of the SVM, which takes a named vector of class weights with one entry for each target class. To tune this parameter we could tune a scalar and then transform this to a vector. The code below would result in a value, <code>x</code>, between <code>0.1</code> and <code>0.9</code> being sampled, the result is then transformed to (<code>x</code>, <code>1 - x</code>) and is then passed to the <code>Learner</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  class.weights <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">0.1</span>, upper <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>    trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>M <span class="op">=</span> <span class="va">x</span>, R <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In other cases, we may need to tune two or more ‘pseudoparameters’ that do not exist in our learner’s parameter set but are required to tune a vector parameter. For example, say we want to tune the architecture of a neural network, in which we need to decide the number of layers and the number of nodes in each layer, this is the case in the <code>num_nodes</code> hyperparameter in <code>lrn("surv.coxtime")</code> (we use this learner as it provides a useful template for this sort of transformation, interested readers can read about survival analysis in <a href="../chapter13/beyond_regression_and_classification.html#sec-survival" class="quarto-xref"><span>Section 13.2</span></a>). In this case, the learner expects a vector where each element of the vector corresponds to the number of nodes in a layer and the length of the vector is the number of layers. We could then tune this as follows:</p>
<div class="cell">
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  num_layers <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">1</span>, upper <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>,</span>
<span>  num_nodes_per_layer <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span><span class="fl">4</span>, <span class="fl">64</span><span class="op">)</span>,</span>
<span>  .extra_trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">param_set</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">x</span><span class="op">$</span><span class="va">num_nodes</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="va">x</span><span class="op">$</span><span class="va">num_nodes_per_layer</span>, <span class="va">x</span><span class="op">$</span><span class="va">num_layers</span><span class="op">)</span></span>
<span>    <span class="va">x</span><span class="op">$</span><span class="va">num_layers</span> <span class="op">=</span> <span class="cn">NULL</span></span>
<span>    <span class="va">x</span><span class="op">$</span><span class="va">num_nodes_per_layer</span> <span class="op">=</span> <span class="cn">NULL</span></span>
<span>    <span class="va">x</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here we are tuning the pseudo-parameter <code>num_layers</code> between <code>1</code> and <code>20</code>, then tuning the pseudo-parameter <code>num_nodes_per_layer</code> between <code>4</code> and <code>64</code>, then combining these into a vector called <code>num_nodes</code> (the real hyperparameter) and removing the pseudo-parameters.</p>
<div class="cell">
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>num_layers <span class="op">=</span> <span class="fl">4</span>, num_nodes_per_layer <span class="op">=</span> <span class="fl">12</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$num_nodes
[1] 12 12 12 12</code></pre>
</div>
</div>
<p>Even though this transformation looks complex, it only affects one of the hyperparameters (and does not need access to others), so we could include it in the learner using <code>to_tune()</code> by passing the whole <code>ParamSet</code> object:</p>
<div class="cell">
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"surv.coxtime"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Package 'survivalmodels,reticulate' required but not installed
for Learner 'surv.coxtime'</code></pre>
</div>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span>num_nodes <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="va">search_space</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(2)&gt;
                    id    class lower upper nlevels        default
1:          num_layers ParamInt     1    20      20 &lt;NoDefault[0]&gt;
2: num_nodes_per_layer ParamInt     4    64      61 &lt;NoDefault[0]&gt;
1 variable not shown: [value]
Trafo is set.</code></pre>
</div>
</div>
</section></section><section id="sec-optimization-depends" class="level3" data-number="4.4.4"><h3 data-number="4.4.4" class="anchored" data-anchor-id="sec-optimization-depends">
<span class="header-section-number">4.4.4</span> Hyperparameter Dependencies</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Hyperparameter dependencies occur when a hyperparameter should only be set if another hyperparameter has a particular value. For example, the <code>degree</code> parameter in SVM is only valid when <code>kernel</code> is <code>"polynomial"</code>. In the <a href="https://paradox.mlr-org.com/reference/ps.html"><code>ps()</code></a> function, we specify this using the <code>depends</code> argument, which takes a named argument of the form <code>&lt;param&gt; == value</code> or <code>&lt;param&gt; %in% &lt;vector&gt;</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ps</span><span class="op">(</span></span>
<span>  kernel <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  degree <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, depends <span class="op">=</span> <span class="op">(</span><span class="va">kernel</span> <span class="op">==</span> <span class="st">"polynomial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>,</span>
<span>    depends <span class="op">=</span> <span class="op">(</span><span class="va">kernel</span> <span class="op"><a href="https://rdrr.io/r/base/match.html">%in%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(3)&gt;
       id    class lower upper nlevels        default parents  value
1: degree ParamInt 1e+00 3e+00       3 &lt;NoDefault[0]&gt;  kernel [NULL]
2:  gamma ParamDbl 1e-05 1e+05     Inf &lt;NoDefault[0]&gt;  kernel [NULL]
3: kernel ParamFct    NA    NA       2 &lt;NoDefault[0]&gt;  [NULL] [NULL]</code></pre>
</div>
</div>
<p>Above we have said that <code>degree</code> should only be set if <code>kernel</code> is (<code>==</code>) <code>"polynomial"</code>, and <code>gamma</code> should only be set if <code>kernel</code> is one of (<code>%in%</code>) <code>"polynomial"</code> or <code>"radial"</code>. In practice, some underlying implementations ignore unused parameters and others throw errors, either way, this is problematic during tuning if, for example, we were wasting time trying to tune <code>degree</code> when the kernel was not polynomial. Hence setting the dependency tells the tuning process to tune <code>degree</code> if <code>kernel</code> is <code>"polynomial"</code> and to ignore it otherwise.</p>
<p>Dependencies can also be passed straight into a learner using <a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a>:</p>
<div class="cell">
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  degree <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu">p_int</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, depends <span class="op">=</span> <span class="op">(</span><span class="va">kernel</span> <span class="op">==</span> <span class="st">"polynomial"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(2)&gt;
       id    class lower upper nlevels        default       parents
1: degree ParamInt     1     3       3 &lt;NoDefault[0]&gt; kernel,kernel
2: kernel ParamFct    NA    NA       2 &lt;NoDefault[0]&gt;        [NULL]
1 variable not shown: [value]</code></pre>
</div>
</div>
</section><section id="sec-tuning-spaces" class="level3" data-number="4.4.5"><h3 data-number="4.4.5" class="anchored" data-anchor-id="sec-tuning-spaces">
<span class="header-section-number">4.4.5</span> Recommended Search Spaces with <code>mlr3tuningspaces</code>
</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Selected search spaces can require a lot of background knowledge or expertise. The package <a href="https://mlr3tuningspaces.mlr-org.com"><code>mlr3tuningspaces</code></a> tries to make HPO more accessible by providing implementations of published search spaces for many popular machine learning algorithms, the hope is that these search spaces are applicable to a wide range of datasets. The search spaces are stored in the dictionary <a href="https://mlr3tuningspaces.mlr-org.com/reference/mlr_tuning_spaces.html"><code>mlr_tuning_spaces</code></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3tuningspaces.mlr-org.com">mlr3tuningspaces</a></span><span class="op">)</span></span>
<span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">mlr_tuning_spaces</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fu">.</span><span class="op">(</span><span class="va">key</span>, <span class="va">label</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                      key                             label
1: classif.glmnet.default   Classification GLM with Default
2:    classif.glmnet.rbv1 Classification GLM with RandomBot
3:    classif.glmnet.rbv2 Classification GLM with RandomBot</code></pre>
</div>
</div>
<p>The tuning spaces are named according to the scheme <code>{learner-id}.{tuning-space-id}</code>. The <code>default</code> tuning spaces are published in <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="../references.html#ref-hpo_practical" role="doc-biblioref">2023</a>)</span>, other tuning spaces are part of the random bot experiments <code>rbv1</code> and <code>rbv2</code> published in <span class="citation" data-cites="kuehn_2018">Kuehn et al. (<a href="../references.html#ref-kuehn_2018" role="doc-biblioref">2018</a>)</span> and <span class="citation" data-cites="binder2020">Binder, Pfisterer, and Bischl (<a href="../references.html#ref-binder2020" role="doc-biblioref">2020</a>)</span>. The sugar function <a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html"><code>lts()</code></a> (learner tuning space) is used to retrieve a <a href="https://mlr3tuningspaces.mlr-org.com/reference/TuningSpace.html"><code>TuningSpace</code></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lts_rpart</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html">lts</a></span><span class="op">(</span><span class="st">"classif.rpart.default"</span><span class="op">)</span></span>
<span><span class="va">lts_rpart</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;TuningSpace&gt; (classif.rpart.default): Classification Rpart with Defau
          id lower upper levels logscale
1:  minsplit 2e+00 128.0 [NULL]     TRUE
2: minbucket 1e+00  64.0 [NULL]     TRUE
3:        cp 1e-04   0.1 [NULL]     TRUE</code></pre>
</div>
</div>
<p>A tuning space can be passed to <a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html"><code>auto_tuner()</code></a> as the <code>search_space</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti</a></span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>,</span>
<span>  search_space <span class="op">=</span> <span class="va">lts_rpart</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Alternatively, as loaded search spaces are just a collection of tune tokens, we could also pass these straight to a learner:</p>
<div class="cell">
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">vals</span> <span class="op">=</span> <span class="va">lts_rpart</span><span class="op">$</span><span class="va">values</span></span>
<span><span class="va">vals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$minsplit
Tuning over:
range [2, 128] (log scale)


$minbucket
Tuning over:
range [1, 64] (log scale)


$cp
Tuning over:
range [1e-04, 0.1] (log scale)</code></pre>
</div>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span>.values <span class="op">=</span> <span class="va">vals</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet(10)&gt;
                id    class lower upper nlevels        default
 1:             cp ParamDbl     0     1     Inf           0.01
 2:     keep_model ParamLgl    NA    NA       2          FALSE
 3:     maxcompete ParamInt     0   Inf     Inf              4
 4:       maxdepth ParamInt     1    30      30             30
 5:   maxsurrogate ParamInt     0   Inf     Inf              5
 6:      minbucket ParamInt     1   Inf     Inf &lt;NoDefault[0]&gt;
 7:       minsplit ParamInt     1   Inf     Inf             20
 8: surrogatestyle ParamInt     0     1       2              0
 9:   usesurrogate ParamInt     0     2       3              2
10:           xval ParamInt     0   Inf     Inf             10
1 variable not shown: [value]</code></pre>
</div>
</div>
<p>Note how we used the <code>.values</code> parameter of <code>$set_values()</code>, which allows us to safely pass a list to the <code>ParamSet</code> without accidentally overwriting any other hyperparameter values (<a href="../chapter2/data_and_basic_modeling.html#sec-param-set" class="quarto-xref"><span>Section 2.2.3</span></a>).</p>
<p>We could also apply the default search spaces from <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="../references.html#ref-hpo_practical" role="doc-biblioref">2023</a>)</span> by passing the learner to <a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html"><code>lts()</code></a>:</p>
<div class="cell">
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html">lts</a></span><span class="op">(</span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;LearnerClassifRpart&gt; (classif.rpart): Classification Tree ───────────
• Model: -
• Parameters: cp=&lt;RangeTuneToken&gt;, minbucket=&lt;RangeTuneToken&gt;,
minsplit=&lt;RangeTuneToken&gt;, xval=0
• Packages: mlr3 and rpart
• Predict Types: [response] and prob
• Feature Types: logical, integer, numeric, factor, and ordered
• Encapsulation: none (fallback: -)
• Properties: importance, missings, multiclass, selected_features,
twoclass, and weights
• Other settings: use_weights = 'use'</code></pre>
</div>
</div>
<p>Finally, it is possible to overwrite a predefined tuning space in construction, for example, changing the range of the <code>maxdepth</code> hyperparameter in a decision tree:</p>
<div class="cell">
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html">lts</a></span><span class="op">(</span><span class="st">"classif.rpart.rbv2"</span>, maxdepth <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
── &lt;TuningSpace&gt; (classif.rpart.rbv2): Classification Rpart with RandomBo
          id lower upper levels logscale
1:        cp 1e-04     1 [NULL]     TRUE
2:  maxdepth 1e+00    20 [NULL]    FALSE
3: minbucket 1e+00   100 [NULL]    FALSE
4:  minsplit 1e+00   100 [NULL]    FALSE</code></pre>
</div>
</div>
</section></section><section id="conclusion" class="level2" data-number="4.5"><h2 data-number="4.5" class="anchored" data-anchor-id="conclusion">
<span class="header-section-number">4.5</span> Conclusion</h2>
<p>In this chapter, we learned how to optimize a model using tuning instances, about different tuners and terminators, search spaces and transformations, how to make use of convenience methods for quicker implementation in larger experiments, and the importance of nested resampling.</p>
<div id="tbl-api-optimization" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-api-optimization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.4: Important classes and functions covered in this chapter with underlying class (if applicable), class constructor or function, and important class fields and methods (if applicable).
</figcaption><div aria-describedby="tbl-api-optimization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead><tr class="header">
<th>Class</th>
<th>Constructor/Function</th>
<th>Fields/Methods</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://bbotk.mlr-org.com/reference/Terminator.html"><code>Terminator</code></a></td>
<td><a href="https://bbotk.mlr-org.com/reference/trm.html"><code>trm()</code></a></td>
<td>-</td>
</tr>
<tr class="even">
<td>
<a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceBatchSingleCrit.html"><code>TuningInstanceBatchSingleCrit</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceBatchMultiCrit.html"><code>TuningInstanceBatchMultiCrit</code></a>
</td>
<td>
<a href="https://mlr3tuning.mlr-org.com/reference/ti.html"><code>ti()</code></a>/<a href="https://mlr3tuning.mlr-org.com/reference/tune.html"><code>tune()</code></a>
</td>
<td>
<code>$result</code>; <code>$archive</code>
</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3tuning.mlr-org.com/reference/TunerBatch.html"><code>TunerBatch</code></a></td>
<td><a href="https://mlr3tuning.mlr-org.com/reference/tnr.html"><code>tnr()</code></a></td>
<td><code>$optimize()</code></td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/TuneToken.html"><code>TuneToken</code></a></td>
<td><a href="https://paradox.mlr-org.com/reference/to_tune.html"><code>to_tune()</code></a></td>
<td>-</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3tuning.mlr-org.com/reference/AutoTuner.html"><code>AutoTuner</code></a></td>
<td><a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html"><code>auto_tuner()</code></a></td>
<td>
<code>$train()</code>; <code>$predict()</code>; <code>$tuning_instance</code>
</td>
</tr>
<tr class="even">
<td>-</td>
<td><a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_results.html"><code>extract_inner_tuning_results()</code></a></td>
<td></td>
</tr>
<tr class="odd">
<td>-</td>
<td><a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_archives.html"><code>extract_inner_tuning_archives()</code></a></td>
<td></td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/ParamSet.html"><code>ParamSet</code></a></td>
<td><a href="https://paradox.mlr-org.com/reference/ps.html"><code>ps()</code></a></td>
<td>-</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3tuningspaces.mlr-org.com/reference/TuningSpace.html"><code>TuningSpace</code></a></td>
<td><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html"><code>lts()</code></a></td>
<td><code>$values</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section><section id="exercises" class="level2" data-number="4.6"><h2 data-number="4.6" class="anchored" data-anchor-id="exercises">
<span class="header-section-number">4.6</span> Exercises</h2>
<ol type="1">
<li>Tune the <code>mtry</code>, <code>sample.fraction</code>, and <code>num.trees</code> hyperparameters of <code>lrn("regr.ranger")</code> on <code>tsk("mtcars")</code>. Use a simple random search with 50 evaluations. Evaluate with a three-fold CV and the root mean squared error. Visualize the effects that each hyperparameter has on the performance via simple marginal plots, which plot a single hyperparameter versus the cross-validated MSE.</li>
<li>Evaluate the performance of the model created in Exercise 1 with nested resampling. Use a holdout validation for the inner resampling and a three-fold CV for the outer resampling.</li>
<li>Tune and benchmark an XGBoost model against a logistic regression (without tuning the latter) and determine which has the best Brier score. Use <code>mlr3tuningspaces</code> and nested resampling, try to pick appropriate inner and outer resampling strategies that balance computational efficiency vs.&nbsp;stability of the results.</li>
<li>(*) Write a function that implements an iterated random search procedure that drills down on the optimal configuration by applying random search to iteratively smaller search spaces. Your function should have seven inputs: <code>task</code>, <code>learner</code>, <code>search_space</code>, <code>resampling</code>, <code>measure</code>, <code>random_search_stages</code>, and <code>random_search_size</code>. You should only worry about programming this for fully numeric and bounded search spaces that have no dependencies. In pseudo-code:
<ol type="1">
<li>Create a random design of size <code>random_search_size</code> from the given search space and evaluate the learner on it.</li>
<li>Identify the best configuration.</li>
<li>Create a smaller search space around this best config, where you define the new range for each parameter as: <code>new_range[i] = (best_conf[i] - 0.25 * current_range[i], best_conf[i] + 0.25*current_range[i])</code>. Ensure that this <code>new_range</code> respects the initial bound of the original <code>search_space</code> by taking the <code><a href="https://rdrr.io/r/base/Extremes.html">max()</a></code> of the new and old lower bound, and the <code><a href="https://rdrr.io/r/base/Extremes.html">min()</a></code> of the new and the old upper bound (“clipping”).</li>
<li>Iterate the previous steps <code>random_search_stages</code> times and at the end return the best configuration you have ever evaluated. As a stretch goal, look into <code>mlr3tuning</code>’s internal source code and turn your function into an R6 class inheriting from the <code>TunerBatch</code> class – test it out on a learner of your choice.</li>
</ol>
</li>
</ol></section><section id="citation" class="level2" data-number="4.7"><h2 data-number="4.7" class="anchored" data-anchor-id="citation">
<span class="header-section-number">4.7</span> Citation</h2>
<p>Please cite this chapter as:</p>
<p>Becker M, Schneider L, Fischer S. (2024). Hyperparameter Optimization. In Bischl B, Sonabend R, Kotthoff L, Lang M, (Eds.), <em>Applied Machine Learning Using mlr3 in R</em>. CRC Press. https://mlr3book.mlr-org.com/hyperparameter_optimization.html.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode bibtex code-with-copy"><code class="sourceCode bibtex"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="va">@incollection</span>{<span class="ot">citekey</span>, </span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">author</span> = "<span class="st">Marc Becker and Lennart Schneider and Sebastian Fischer</span>", </span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">title</span> = "<span class="st">Hyperparameter Optimization</span>",</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">booktitle</span> = "<span class="st">Applied Machine Learning Using {m}lr3 in {R}</span>",</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">publisher</span> = "<span class="st">CRC Press</span>", <span class="st">year</span> = "<span class="st">2024</span>",</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">editor</span> = "<span class="st">Bernd Bischl and Raphael Sonabend and Lars Kotthoff and Michel Lang</span>", </span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">url</span> = "<span class="st">https://mlr3book.mlr-org.com/hyperparameter_optimization.html</span>"</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-bergstra2012" class="csl-entry" role="listitem">
Bergstra, James, and Yoshua Bengio. 2012. <span>“Random Search for Hyper-Parameter Optimization.”</span> <em>Journal of Machine Learning Research</em> 13: 281–305. <a href="https://jmlr.org/papers/v13/bergstra12a.html">https://jmlr.org/papers/v13/bergstra12a.html</a>.
</div>
<div id="ref-binder2020" class="csl-entry" role="listitem">
Binder, Martin, Florian Pfisterer, and Bernd Bischl. 2020. <span>“Collecting Empirical Data about Hyperparameters for Data Driven AutoML.”</span> In <em>Proceedings of the 7th ICML Workshop on Automated Machine Learning (AutoML 2020)</em>. <a href="https://www.automl.org/wp-content/uploads/2020/07/AutoML_2020_paper_63.pdf">https://www.automl.org/wp-content/uploads/2020/07/AutoML_2020_paper_63.pdf</a>.
</div>
<div id="ref-hpo_practical" class="csl-entry" role="listitem">
Bischl, Bernd, Martin Binder, Michel Lang, Tobias Pielok, Jakob Richter, Stefan Coors, Janek Thomas, et al. 2023. <span>“Hyperparameter Optimization: Foundations, Algorithms, Best Practices, and Open Challenges.”</span> <em>Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery</em>, e1484. <a href="https://doi.org/10.1002/widm.1484">https://doi.org/10.1002/widm.1484</a>.
</div>
<div id="ref-hpo_automl" class="csl-entry" role="listitem">
Feurer, Matthias, and Frank Hutter. 2019. <span>“Hyperparameter Optimization.”</span> In <em>Automated Machine Learning: Methods, Systems, Challenges</em>, edited by Frank Hutter, Lars Kotthoff, and Joaquin Vanschoren, 3–33. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-05318-5_1">https://doi.org/10.1007/978-3-030-05318-5_1</a>.
</div>
<div id="ref-hansen2011" class="csl-entry" role="listitem">
Hansen, Nikolaus, and Anne Auger. 2011. <span>“CMA-ES: Evolution Strategies and Covariance Matrix Adaptation.”</span> In <em>Proceedings of the 13th Annual Conference Companion on Genetic and Evolutionary Computation</em>, 991–1010. <a href="https://doi.org/10.1145/2001858.2002123">https://doi.org/10.1145/2001858.2002123</a>.
</div>
<div id="ref-james_introduction_2014" class="csl-entry" role="listitem">
James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2014. <em>An Introduction to Statistical Learning: With Applications in <span>R</span></em>. Springer Publishing Company, Incorporated. <a href="https://doi.org/10.1007/978-1-4614-7138-7">https://doi.org/10.1007/978-1-4614-7138-7</a>.
</div>
<div id="ref-kuehn_2018" class="csl-entry" role="listitem">
Kuehn, Daniel, Philipp Probst, Janek Thomas, and Bernd Bischl. 2018. <span>“Automatic Exploration of Machine Learning Experiments on OpenML.”</span> <a href="https://arxiv.org/abs/1806.10961">https://arxiv.org/abs/1806.10961</a>.
</div>
<div id="ref-li_2018" class="csl-entry" role="listitem">
Li, Lisha, Kevin Jamieson, Giulia DeSalvo, Afshin Rostamizadeh, and Ameet Talwalkar. 2018. <span>“Hyperband: A Novel Bandit-Based Approach to Hyperparameter Optimization.”</span> <em>Journal of Machine Learning Research</em> 18 (185): 1–52. <a href="https://jmlr.org/papers/v18/16-558.html">https://jmlr.org/papers/v18/16-558.html</a>.
</div>
<div id="ref-lopez2016" class="csl-entry" role="listitem">
López-Ibáñez, Manuel, Jérémie Dubois-Lacoste, Leslie Pérez Cáceres, Mauro Birattari, and Thomas Stützle. 2016. <span>“The <span class="nocase">irace</span> Package: Iterated Racing for Automatic Algorithm Configuration.”</span> <em>Operations Research Perspectives</em> 3: 43–58. <a href="https://doi.org/10.1016/j.orp.2016.09.002">https://doi.org/10.1016/j.orp.2016.09.002</a>.
</div>
<div id="ref-Simon2007" class="csl-entry" role="listitem">
Simon, Richard. 2007. <span>“Resampling Strategies for Model Assessment and Selection.”</span> In <em>Fundamentals of Data Mining in Genomics and Proteomics</em>, edited by Werner Dubitzky, Martin Granzow, and Daniel Berrar, 173–86. <span>Boston, MA</span>: <span>Springer US</span>. <a href="https://doi.org/10.1007/978-0-387-47509-7_8">https://doi.org/10.1007/978-0-387-47509-7_8</a>.
</div>
<div id="ref-Snoek2012" class="csl-entry" role="listitem">
Snoek, Jasper, Hugo Larochelle, and Ryan P Adams. 2012. <span>“Practical Bayesian Optimization of Machine Learning Algorithms.”</span> In <em>Advances in Neural Information Processing Systems</em>, edited by F. Pereira, C. J. Burges, L. Bottou, and K. Q. Weinberger. Vol. 25. <a href="https://proceedings.neurips.cc/paper_files/paper/2012/file/05311655a15b75fab86956663e1819cd-Paper.pdf">https://proceedings.neurips.cc/paper_files/paper/2012/file/05311655a15b75fab86956663e1819cd-Paper.pdf</a>.
</div>
<div id="ref-tsallis1996" class="csl-entry" role="listitem">
Tsallis, Constantino, and Daniel A Stariolo. 1996. <span>“Generalized Simulated Annealing.”</span> <em>Physica A: Statistical Mechanics and Its Applications</em> 233 (1-2): 395–406. <a href="https://doi.org/10.1016/S0378-4371(96)00271-3">https://doi.org/10.1016/S0378-4371(96)00271-3</a>.
</div>
<div id="ref-xiang2013" class="csl-entry" role="listitem">
Xiang, Yang, Sylvain Gubian, Brian Suomela, and Julia Hoeng. 2013. <span>“Generalized Simulated Annealing for Global Optimization: The GenSA Package.”</span> <em><span>R</span> Journal</em> 5 (1): 13. <a href="https://doi.org/10.32614/RJ-2013-002">https://doi.org/10.32614/RJ-2013-002</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="pagination-link" aria-label="Evaluation and Benchmarking">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="pagination-link" aria-label="Advanced Tuning Methods and Black Box Optimization">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb107" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="an">aliases:</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="co">  - "/hyperparameter_optimization.html"</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="fu"># Hyperparameter Optimization {#sec-optimization}</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_setup.qmd &gt;}}</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a><span class="in">`r chapter = "Hyperparameter Optimization"`</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a><span class="in">`r authors(chapter)`</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>Machine learning algorithms usually include <span class="in">`r index("parameters")`</span> and <span class="in">`r index("hyperparameters", aside = TRUE)`</span>.</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>Parameters are the <span class="in">`r index('model coefficients', see = "parameters")`</span> or weights or other information that are determined by the learning algorithm based on the training data.</span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>In contrast, hyperparameters, are configured by the user and determine how the model will fit its parameters, i.e., how the model is built.</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>Examples include setting the number of trees in a random forest, penalty settings in support vector machines, or the learning rate in a neural network.</span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>The goal of <span class="in">`r index("hyperparameter optimization", "HPO", aside = TRUE)`</span>\index{hyperparameter optimization|see{HPO}} (HPO) or model <span class="in">`r index("tuning")`</span> is to find the optimal configuration of hyperparameters of a machine learning algorithm for a given task.</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>There is no closed-form mathematical representation (nor analytic gradient information) for model-agnostic HPO.</span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>Instead, we follow a <span class="in">`r index('black box optimization')`</span> approach: a machine learning algorithm is configured with values chosen for one or more hyperparameters, this algorithm is then evaluated (using a resampling method) and its performance is measured.</span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>This process is repeated with multiple configurations and finally, the configuration with the best performance is selected (@fig-optimization-loop-basic).</span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>HPO closely relates to <span class="in">`r index('model evaluation')`</span> (@sec-performance) as the objective is to find a hyperparameter configuration that optimizes the generalization performance.</span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>Broadly speaking, we could think of finding the optimal model configuration in the same way as selecting a model from a benchmark experiment, where in this case each model in the experiment is the same algorithm but with different hyperparameter configurations.</span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>For example, we could benchmark three <span class="in">`r index("support vector machines", "support vector machine")`</span> (SVMs) with three different <span class="in">`cost`</span> values.</span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a>However, human trial-and-error is time-consuming, subjective and often biased, error-prone, and computationally inefficient.</span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a>Instead, many sophisticated hyperparameter optimization methods (or '<span class="in">`r index('tuners')`</span>', see @sec-tuner) have been developed over the past few decades for robust and efficient HPO.</span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>Besides simple approaches such as a <span class="in">`r index('random search')`</span> or <span class="in">`r index('grid search')`</span>, most hyperparameter optimization methods employ iterative techniques that propose different configurations over time, often exhibiting adaptive behavior guided towards potentially optimal hyperparameter configurations.</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a>These methods continually propose new configurations until a termination criterion is met, at which point the best configuration so far is returned (@fig-optimization-loop-basic).</span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a>For more general details on HPO and more theoretical background, we recommend @hpo_practical and @hpo_automl.</span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>Note that <span class="in">`mlr3`</span> never does any automatic hyperparameter optimization that the user did not explicitly request.</span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-001, echo = FALSE, out.width = "80%"}</span></span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-optimization-loop-basic</span></span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Representation of the hyperparameter optimization loop in mlr3tuning. Blue - Hyperparameter optimization loop. Purple - Objects of the tuning instance supplied by the user. Blue-Green - Internally created objects of the tuning instance. Green - Optimization Algorithm.</span></span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Diagram showing 13 boxes representing model-agnostic HPO.  On the top are two boxes, one that says  "Search Space" (dark blue) and the other "Tuner" (green), these are connected by a line to "Propose Hyperparameter Configurations" (purple). That box has an arrow pointing towards another box "Evaluate by Resampling" (purple), which has a line to a blue-green box "Objective", which has four blue boxes connected toit  "Task", "Learner", "Resampling", and "Measure". "Evaluate by Resampling" also has one line to the right connected to "Archive" (blue-green) which has an arrow to "Terminator" (blue) and "Update Tuner" (purple). "Terminator" has an arrow to "Optimal Hyperparameter Configuration" (purple) and "Update Tuner" has an arrow back to "Propose Hyperparameter Configurations".</span></span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-9"</span>)</span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model Tuning {#sec-model-tuning}</span></span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a><span class="in">`r mlr3tuning`</span> is the hyperparameter optimization package of the <span class="in">`mlr3`</span> ecosystem.</span>
<span id="cb107-43"><a href="#cb107-43" aria-hidden="true" tabindex="-1"></a>At the heart of the package are the R6 classes</span>
<span id="cb107-44"><a href="#cb107-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-45"><a href="#cb107-45" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r ref("TuningInstanceBatchSingleCrit")`</span>, a tuning 'instance' that describes the optimization problem and store the results; and</span>
<span id="cb107-46"><a href="#cb107-46" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r ref("TunerBatch")`</span> which is used to configure and run optimization algorithms.</span>
<span id="cb107-47"><a href="#cb107-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-48"><a href="#cb107-48" aria-hidden="true" tabindex="-1"></a>In this section, we will cover these classes as well as other supporting functions and classes.</span>
<span id="cb107-49"><a href="#cb107-49" aria-hidden="true" tabindex="-1"></a>Throughout this section, we will look at optimizing an SVM classifier\index{support vector machine} from <span class="in">`r ref_pkg("e1071")`</span> on <span class="in">`tsk("sonar")`</span> as a running example.</span>
<span id="cb107-50"><a href="#cb107-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-51"><a href="#cb107-51" aria-hidden="true" tabindex="-1"></a><span class="fu">### Learner and Search Space {#sec-learner-search-space}</span></span>
<span id="cb107-52"><a href="#cb107-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-53"><a href="#cb107-53" aria-hidden="true" tabindex="-1"></a>The tuning process begins by deciding which hyperparameters to tune and what range to tune them over.</span>
<span id="cb107-54"><a href="#cb107-54" aria-hidden="true" tabindex="-1"></a>The first place to start is therefore picking a learner and looking at the possible hyperparameters to tune with <span class="in">`$param_set`</span>:</span>
<span id="cb107-55"><a href="#cb107-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-56"><a href="#cb107-56" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-002}</span></span>
<span id="cb107-57"><a href="#cb107-57" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(<span class="fu">lrn</span>(<span class="st">"classif.svm"</span>)<span class="sc">$</span>param_set)[,</span>
<span id="cb107-58"><a href="#cb107-58" aria-hidden="true" tabindex="-1"></a>  .(id, class, lower, upper, nlevels)]</span>
<span id="cb107-59"><a href="#cb107-59" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-60"><a href="#cb107-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-61"><a href="#cb107-61" aria-hidden="true" tabindex="-1"></a>Given infinite resources, we could tune all hyperparameters jointly, but in reality that is not possible (or maybe necessary), so usually only a subset of hyperparameters can be tuned.</span>
<span id="cb107-62"><a href="#cb107-62" aria-hidden="true" tabindex="-1"></a>This subset of possible hyperparameter values to tune over is referred to as the <span class="in">`r index("search space", aside = TRUE)`</span> or <span class="in">`r index("tuning space", see = "search space")`</span>.</span>
<span id="cb107-63"><a href="#cb107-63" aria-hidden="true" tabindex="-1"></a>In this example we will tune the numeric regularization and kernel width hyperparameters, <span class="in">`cost`</span> and <span class="in">`gamma`</span>; see the help page for <span class="in">`r ref("e1071::svm()")`</span> for details.</span>
<span id="cb107-64"><a href="#cb107-64" aria-hidden="true" tabindex="-1"></a>In practice, search spaces are usually more complex and can require expert knowledge to define them.</span>
<span id="cb107-65"><a href="#cb107-65" aria-hidden="true" tabindex="-1"></a>@sec-defining-search-spaces provides more detailed insight into the creation of tuning spaces, including using <span class="in">`r mlr3tuningspaces`</span> to load predefined search spaces.</span>
<span id="cb107-66"><a href="#cb107-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-67"><a href="#cb107-67" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb107-68"><a href="#cb107-68" aria-hidden="true" tabindex="-1"></a><span class="fu">## Untunable Hyperparameters</span></span>
<span id="cb107-69"><a href="#cb107-69" aria-hidden="true" tabindex="-1"></a>In rare cases, parameter sets may include hyperparameters that should not be tuned.</span>
<span id="cb107-70"><a href="#cb107-70" aria-hidden="true" tabindex="-1"></a>These will usually be 'technical' (or 'control') parameters that *provide information* about how the model is being fit but do not control the training process itself, for example, the <span class="in">`verbose`</span> hyperparameter in <span class="in">`lrn("classif.ranger")`</span> controls how much information is displayed to the user during training.</span>
<span id="cb107-71"><a href="#cb107-71" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb107-72"><a href="#cb107-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-73"><a href="#cb107-73" aria-hidden="true" tabindex="-1"></a>For numeric hyperparameters (we will explore others later) one must specify the bounds to tune over.</span>
<span id="cb107-74"><a href="#cb107-74" aria-hidden="true" tabindex="-1"></a>We do this by constructing a learner and using <span class="in">`r ref("to_tune()")`</span> to set the lower and upper limits for the parameters we want to tune.</span>
<span id="cb107-75"><a href="#cb107-75" aria-hidden="true" tabindex="-1"></a>This function allows us to *mark* the hyperparameter as requiring tuning in the specified range.</span>
<span id="cb107-76"><a href="#cb107-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-77"><a href="#cb107-77" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-003}</span></span>
<span id="cb107-78"><a href="#cb107-78" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-79"><a href="#cb107-79" aria-hidden="true" tabindex="-1"></a>  <span class="at">type  =</span> <span class="st">"C-classification"</span>,</span>
<span id="cb107-80"><a href="#cb107-80" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb107-81"><a href="#cb107-81" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb107-82"><a href="#cb107-82" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>)</span>
<span id="cb107-83"><a href="#cb107-83" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-84"><a href="#cb107-84" aria-hidden="true" tabindex="-1"></a>learner</span>
<span id="cb107-85"><a href="#cb107-85" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-86"><a href="#cb107-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-87"><a href="#cb107-87" aria-hidden="true" tabindex="-1"></a>Here we have constructed a classification SVM, <span class="in">`lrn("classif.svm")`</span>, selected the type of model as <span class="in">`"C-classification"`</span>, set the kernel to <span class="in">`"radial"`</span>, and specified that we plan to tune the <span class="in">`cost`</span> and <span class="in">`gamma`</span> parameters over the range $<span class="co">[</span><span class="ot">0.1, 10^5</span><span class="co">]</span>$ and $<span class="co">[</span><span class="ot">0.1, 1</span><span class="co">]</span>$ respectively (though these are usually tuned on a log scale, see @sec-logarithmic-transformations).</span>
<span id="cb107-88"><a href="#cb107-88" aria-hidden="true" tabindex="-1"></a>Note that calling <span class="in">`$train()`</span> on a learner with a tune token (e.g., <span class="in">`cost=&lt;RangeTuneToken&gt;`</span>) will throw an error.</span>
<span id="cb107-89"><a href="#cb107-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-90"><a href="#cb107-90" aria-hidden="true" tabindex="-1"></a>Now we have decided which hyperparameters to tune, we specify when to stop the tuning process.</span>
<span id="cb107-91"><a href="#cb107-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-92"><a href="#cb107-92" aria-hidden="true" tabindex="-1"></a><span class="fu">### Terminator {#sec-terminator}</span></span>
<span id="cb107-93"><a href="#cb107-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-94"><a href="#cb107-94" aria-hidden="true" tabindex="-1"></a><span class="in">`mlr3tuning`</span> includes many methods to specify when to terminate an algorithm (@tbl-terms), which are implemented in <span class="in">`r ref("Terminator", aside = TRUE)`</span> classes.</span>
<span id="cb107-95"><a href="#cb107-95" aria-hidden="true" tabindex="-1"></a>Terminators are stored in the <span class="in">`r ref('mlr_terminators')`</span> dictionary and are constructed with the sugar function <span class="in">`r ref('trm()', aside = TRUE)`</span>.</span>
<span id="cb107-96"><a href="#cb107-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-97"><a href="#cb107-97" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Terminator            <span class="pp">|</span> Function call and default parameters           <span class="pp">|</span></span>
<span id="cb107-98"><a href="#cb107-98" aria-hidden="true" tabindex="-1"></a><span class="pp">|-----------------------|------------------------------------------------|</span></span>
<span id="cb107-99"><a href="#cb107-99" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Clock Time            <span class="pp">|</span> <span class="in">`trm("clock_time")`</span>                            <span class="pp">|</span></span>
<span id="cb107-100"><a href="#cb107-100" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Combo                 <span class="pp">|</span> <span class="in">`trm("combo", any = TRUE)`</span>                     <span class="pp">|</span></span>
<span id="cb107-101"><a href="#cb107-101" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> None                  <span class="pp">|</span> <span class="in">`trm("none")`</span>                                  <span class="pp">|</span></span>
<span id="cb107-102"><a href="#cb107-102" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Number of Evaluations <span class="pp">|</span> <span class="in">`trm("evals", n_evals = 100, k = 0)`</span>           <span class="pp">|</span></span>
<span id="cb107-103"><a href="#cb107-103" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Performance Level     <span class="pp">|</span> <span class="in">`trm("perf_reached", level = 0.1)`</span>             <span class="pp">|</span></span>
<span id="cb107-104"><a href="#cb107-104" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Run Time              <span class="pp">|</span> <span class="in">`trm("run_time", secs = 30)`</span>                   <span class="pp">|</span></span>
<span id="cb107-105"><a href="#cb107-105" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Stagnation            <span class="pp">|</span> <span class="in">`trm("stagnation", iters = 10, threshold = 0)`</span> <span class="pp">|</span></span>
<span id="cb107-106"><a href="#cb107-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-107"><a href="#cb107-107" aria-hidden="true" tabindex="-1"></a>: Terminators available in <span class="in">`mlr3tuning`</span> at the time of publication, their function call and default parameters. A complete and up-to-date list can be found at <span class="in">`r link("https://mlr-org.com/terminators.html")`</span>. {#tbl-terms}</span>
<span id="cb107-108"><a href="#cb107-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-109"><a href="#cb107-109" aria-hidden="true" tabindex="-1"></a>The most commonly used terminators are those that stop the tuning after a certain time (<span class="in">`trm("run_time")`</span>) or a given number of evaluations (<span class="in">`trm("evals")`</span>).</span>
<span id="cb107-110"><a href="#cb107-110" aria-hidden="true" tabindex="-1"></a>Choosing a runtime is often based on practical considerations and intuition.</span>
<span id="cb107-111"><a href="#cb107-111" aria-hidden="true" tabindex="-1"></a>Using a time limit can be important on compute clusters where a maximum runtime for a compute job may need to be specified.</span>
<span id="cb107-112"><a href="#cb107-112" aria-hidden="true" tabindex="-1"></a><span class="in">`trm("perf_reached")`</span> stops the tuning when a specified performance level is reached, which can be helpful if a certain performance is seen as sufficient for the practical use of the model, however, if this is set too optimistically the tuning may never terminate.</span>
<span id="cb107-113"><a href="#cb107-113" aria-hidden="true" tabindex="-1"></a><span class="in">`trm("stagnation")`</span> stops when no progress greater than the <span class="in">`threshold`</span> has been made for a set number of <span class="in">`iterations`</span>.</span>
<span id="cb107-114"><a href="#cb107-114" aria-hidden="true" tabindex="-1"></a>The threshold can be difficult to select as the optimization could stop too soon for complex search spaces despite room for (possibly significant) improvement.</span>
<span id="cb107-115"><a href="#cb107-115" aria-hidden="true" tabindex="-1"></a><span class="in">`trm("none")`</span> is used for tuners that control termination themselves and so this terminator does nothing.</span>
<span id="cb107-116"><a href="#cb107-116" aria-hidden="true" tabindex="-1"></a>Finally, any of these terminators can be freely combined by using <span class="in">`trm("combo")`</span>, which can be used to specify if HPO finishes when any (<span class="in">`any = TRUE`</span>) terminator is triggered or when all (<span class="in">`any = FALSE`</span>) are triggered.</span>
<span id="cb107-117"><a href="#cb107-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-118"><a href="#cb107-118" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Instance with `ti` {#sec-tuning-instance}</span></span>
<span id="cb107-119"><a href="#cb107-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-120"><a href="#cb107-120" aria-hidden="true" tabindex="-1"></a>The tuning instance collects the tuner-agnostic information required to optimize a model, i.e., all information about the tuning process, except for the tuning algorithm itself.</span>
<span id="cb107-121"><a href="#cb107-121" aria-hidden="true" tabindex="-1"></a>This includes the task to tune over, the learner to tune, the resampling method and measure used to analytically compare hyperparameter optimization configurations, and the terminator to determine when the measure has been optimized 'enough'.</span>
<span id="cb107-122"><a href="#cb107-122" aria-hidden="true" tabindex="-1"></a>This implicitly defines a "black box" objective function, mapping hyperparameter configurations to (stochastic) performance values, to be optimized.</span>
<span id="cb107-123"><a href="#cb107-123" aria-hidden="true" tabindex="-1"></a>This concept will be revisited in @sec-optimization-advanced.</span>
<span id="cb107-124"><a href="#cb107-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-125"><a href="#cb107-125" aria-hidden="true" tabindex="-1"></a>A <span class="in">`r index("tuning instance")`</span> can be constructed explicitly with the <span class="in">`r ref("ti()")`</span> function, or we can tune a learner with the <span class="in">`r ref("tune()")`</span> function, which implicitly creates a tuning instance, as shown in @sec-autotuner.</span>
<span id="cb107-126"><a href="#cb107-126" aria-hidden="true" tabindex="-1"></a>We cover the <span class="in">`ti()`</span> approach first as this allows finer control of tuning and a more nuanced discussion about the design and use of <span class="in">`mlr3tuning`</span>.</span>
<span id="cb107-127"><a href="#cb107-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-128"><a href="#cb107-128" aria-hidden="true" tabindex="-1"></a>Continuing our example, we will construct a <span class="in">`r index("single-objective")`</span> tuning problem (i.e., tuning over *one* measure) by using the <span class="in">`ti()`</span> function to create a <span class="in">`r ref("TuningInstanceBatchSingleCrit")`</span>, we will return to <span class="in">`r index('multi-objective tuning')`</span> in @sec-multi-metrics-tuning.</span>
<span id="cb107-129"><a href="#cb107-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-130"><a href="#cb107-130" aria-hidden="true" tabindex="-1"></a>For this example, we will use three-fold CV and optimize the classification error measure.</span>
<span id="cb107-131"><a href="#cb107-131" aria-hidden="true" tabindex="-1"></a>Note that in the next section, we will continue our example with a grid search tuner, so we select <span class="in">`trm("none")`</span> below as we will want to iterate over the full grid without stopping too soon.</span>
<span id="cb107-132"><a href="#cb107-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-133"><a href="#cb107-133" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-004}</span></span>
<span id="cb107-134"><a href="#cb107-134" aria-hidden="true" tabindex="-1"></a>tsk_sonar <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"sonar"</span>)</span>
<span id="cb107-135"><a href="#cb107-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-136"><a href="#cb107-136" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-137"><a href="#cb107-137" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb107-138"><a href="#cb107-138" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb107-139"><a href="#cb107-139" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb107-140"><a href="#cb107-140" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb107-141"><a href="#cb107-141" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-142"><a href="#cb107-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-143"><a href="#cb107-143" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">ti</span>(</span>
<span id="cb107-144"><a href="#cb107-144" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb107-145"><a href="#cb107-145" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> learner,</span>
<span id="cb107-146"><a href="#cb107-146" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>),</span>
<span id="cb107-147"><a href="#cb107-147" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb107-148"><a href="#cb107-148" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"none"</span>)</span>
<span id="cb107-149"><a href="#cb107-149" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-150"><a href="#cb107-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-151"><a href="#cb107-151" aria-hidden="true" tabindex="-1"></a>instance</span>
<span id="cb107-152"><a href="#cb107-152" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-153"><a href="#cb107-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-154"><a href="#cb107-154" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuner {#sec-tuner}</span></span>
<span id="cb107-155"><a href="#cb107-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-156"><a href="#cb107-156" aria-hidden="true" tabindex="-1"></a>With all the pieces of our tuning problem assembled, we can now decide *how* to tune our model.</span>
<span id="cb107-157"><a href="#cb107-157" aria-hidden="true" tabindex="-1"></a>There are multiple <span class="in">`r ref("Tuner", aside = TRUE)`</span> classes in <span class="in">`mlr3tuning`</span>, which implement different HPO (or more generally speaking <span class="in">`r index('black box optimization')`</span>) algorithms (@tbl-tuners).</span>
<span id="cb107-158"><a href="#cb107-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-159"><a href="#cb107-159" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Tuner                           <span class="pp">|</span> Function call          <span class="pp">|</span> Package               <span class="pp">|</span></span>
<span id="cb107-160"><a href="#cb107-160" aria-hidden="true" tabindex="-1"></a><span class="pp">|---------------------------------|------------------------|-----------------------|</span></span>
<span id="cb107-161"><a href="#cb107-161" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Random Search                   <span class="pp">|</span> <span class="in">`tnr("random_search")`</span> <span class="pp">|</span> <span class="in">`r mlr3tuning`</span>        <span class="pp">|</span></span>
<span id="cb107-162"><a href="#cb107-162" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Grid Search                     <span class="pp">|</span> <span class="in">`tnr("grid_search")`</span>   <span class="pp">|</span> <span class="in">`r mlr3tuning`</span>        <span class="pp">|</span></span>
<span id="cb107-163"><a href="#cb107-163" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Bayesian Optimization           <span class="pp">|</span> <span class="in">`tnr("mbo")`</span>           <span class="pp">|</span> <span class="in">`r mlr3mbo`</span>           <span class="pp">|</span></span>
<span id="cb107-164"><a href="#cb107-164" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> CMA-ES                          <span class="pp">|</span> <span class="in">`tnr("cmaes")`</span>         <span class="pp">|</span> <span class="in">`r ref_pkg("adagio")`</span> <span class="pp">|</span></span>
<span id="cb107-165"><a href="#cb107-165" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Iterated Racing                <span class="pp">|</span> <span class="in">`tnr("irace")`</span>         <span class="pp">|</span> <span class="in">`r ref_pkg("irace")`</span>  <span class="pp">|</span></span>
<span id="cb107-166"><a href="#cb107-166" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Hyperband                       <span class="pp">|</span> <span class="in">`tnr("hyperband")`</span>     <span class="pp">|</span> <span class="in">`r mlr3hyperband`</span>     <span class="pp">|</span></span>
<span id="cb107-167"><a href="#cb107-167" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Generalized Simulated Annealing <span class="pp">|</span> <span class="in">`tnr("gensa")`</span>         <span class="pp">|</span> <span class="in">`r ref_pkg("GenSA")`</span>  <span class="pp">|</span></span>
<span id="cb107-168"><a href="#cb107-168" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Nonlinear Optimization          <span class="pp">|</span> <span class="in">`tnr("nloptr")`</span>        <span class="pp">|</span> <span class="in">`r ref_pkg("nloptr")`</span> <span class="pp">|</span></span>
<span id="cb107-169"><a href="#cb107-169" aria-hidden="true" tabindex="-1"></a>: Tuning algorithms available in <span class="in">`mlr3tuning`</span>, their function call and the package in which the algorithm is implemented. A complete and up-to-date list can be found at <span class="in">`r link("https://mlr-org.com/tuners.html")`</span>. {#tbl-tuners}</span>
<span id="cb107-170"><a href="#cb107-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-171"><a href="#cb107-171" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Search strategies {.unnumbered .unlisted}</span></span>
<span id="cb107-172"><a href="#cb107-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-173"><a href="#cb107-173" aria-hidden="true" tabindex="-1"></a>Grid search and random search <span class="co">[</span><span class="ot">@bergstra2012</span><span class="co">]</span> are the most basic algorithms and are often selected first in initial experiments.</span>
<span id="cb107-174"><a href="#cb107-174" aria-hidden="true" tabindex="-1"></a>The idea of grid search is to exhaustively evaluate every possible combination of given hyperparameter values.</span>
<span id="cb107-175"><a href="#cb107-175" aria-hidden="true" tabindex="-1"></a>Categorical hyperparameters are usually evaluated over all possible values they can take.</span>
<span id="cb107-176"><a href="#cb107-176" aria-hidden="true" tabindex="-1"></a>Numeric and integer hyperparameter values are then spaced equidistantly in their box constraints (upper and lower bounds) according to a given resolution, which is the number of distinct values to try per hyperparameter.</span>
<span id="cb107-177"><a href="#cb107-177" aria-hidden="true" tabindex="-1"></a>Random search involves randomly selecting values for each hyperparameter independently from a pre-specified distribution, usually uniform.</span>
<span id="cb107-178"><a href="#cb107-178" aria-hidden="true" tabindex="-1"></a>Both methods are non-adaptive, which means each proposed configuration ignores the performance of previous configurations.</span>
<span id="cb107-179"><a href="#cb107-179" aria-hidden="true" tabindex="-1"></a>Due to their simplicity, both grid search and random search can handle mixed search spaces (i.e., hyperparameters can be numeric, integer, or categorical) as well as hierarchical search spaces (@sec-defining-search-spaces).</span>
<span id="cb107-180"><a href="#cb107-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-181"><a href="#cb107-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-182"><a href="#cb107-182" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Adaptive algorithms {.unnumbered .unlisted}</span></span>
<span id="cb107-183"><a href="#cb107-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-184"><a href="#cb107-184" aria-hidden="true" tabindex="-1"></a>Adaptive algorithms learn from previously evaluated configurations to find good configurations quickly, examples in <span class="in">`r mlr3`</span> include Bayesian optimization (also called model-based optimization), Covariance Matrix Adaptation Evolution Strategy (CMA-ES), <span class="in">`r index('Iterated Racing')`</span>, and Hyperband.</span>
<span id="cb107-185"><a href="#cb107-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-186"><a href="#cb107-186" aria-hidden="true" tabindex="-1"></a><span class="in">`r index('Bayesian optimization', lower = FALSE)`</span> <span class="co">[</span><span class="ot">e.g., @Snoek2012</span><span class="co">]</span> describes a family of iterative optimization algorithms that use a surrogate model to approximate the unknown function that is to be optimized -- in HPO this would be the mapping from a hyperparameter configuration to the estimated generalization performance. If a suitable surrogate model is chosen, e.g. a random forest,</span>
<span id="cb107-187"><a href="#cb107-187" aria-hidden="true" tabindex="-1"></a>Bayesian optimization can be quite flexible and even handle mixed and hierarchical search spaces. Bayesian optimization is discussed in full detail in @sec-bayesian-optimization.</span>
<span id="cb107-188"><a href="#cb107-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-189"><a href="#cb107-189" aria-hidden="true" tabindex="-1"></a><span class="in">`r index('CMA-ES', lower = FALSE)`</span> <span class="co">[</span><span class="ot">@hansen2011</span><span class="co">]</span> is an evolutionary strategy\index{evolutionary strategies} that maintains a probability distribution over candidate points, with the distribution represented by a mean vector and covariance matrix.</span>
<span id="cb107-190"><a href="#cb107-190" aria-hidden="true" tabindex="-1"></a>A new set of candidate points is generated by sampling from this distribution, with the probability of each candidate being proportional to its performance.</span>
<span id="cb107-191"><a href="#cb107-191" aria-hidden="true" tabindex="-1"></a>The covariance matrix is adapted over time to reflect the performance landscape.</span>
<span id="cb107-192"><a href="#cb107-192" aria-hidden="true" tabindex="-1"></a>Further evolutionary strategies are available in <span class="in">`mlr3`</span> via the <span class="in">`r ref_pkg("miesmuschel")`</span> package, however, these will not be covered in this book.</span>
<span id="cb107-193"><a href="#cb107-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-194"><a href="#cb107-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-195"><a href="#cb107-195" aria-hidden="true" tabindex="-1"></a>Racing algorithms work by iteratively discarding configurations that show poor performance, as determined by statistical tests.</span>
<span id="cb107-196"><a href="#cb107-196" aria-hidden="true" tabindex="-1"></a>Iterated Racing <span class="co">[</span><span class="ot">@lopez2016</span><span class="co">]</span> starts by 'racing' down an initial population of randomly sampled configurations from a parameterized density and then uses the surviving configurations of the race to stochastically update the density of the subsequent race to focus on promising regions of the search space, and so on.</span>
<span id="cb107-197"><a href="#cb107-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-198"><a href="#cb107-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-199"><a href="#cb107-199" aria-hidden="true" tabindex="-1"></a>Multi-fidelity HPO is an adaptive method that leverages the predictive power of computationally cheap lower fidelity evaluations (i.e., poorer quality predictions such as those arising from neural networks with a small number of epochs) to improve the overall optimization efficiency.</span>
<span id="cb107-200"><a href="#cb107-200" aria-hidden="true" tabindex="-1"></a>This concept is used in <span class="in">`r index('Hyperband')`</span> <span class="co">[</span><span class="ot">@li_2018</span><span class="co">]</span>, a popular multi-fidelity hyperparameter optimization algorithm that dynamically allocates increasingly more resources to promising configurations and terminates low-performing ones.</span>
<span id="cb107-201"><a href="#cb107-201" aria-hidden="true" tabindex="-1"></a>Hyperband is discussed in full detail in @sec-hyperband.</span>
<span id="cb107-202"><a href="#cb107-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-203"><a href="#cb107-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-204"><a href="#cb107-204" aria-hidden="true" tabindex="-1"></a>Other implemented algorithms for numeric search spaces are Generalized Simulated Annealing <span class="co">[</span><span class="ot">@xiang2013; @tsallis1996</span><span class="co">]</span> and various nonlinear optimization algorithms.</span>
<span id="cb107-205"><a href="#cb107-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-206"><a href="#cb107-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-207"><a href="#cb107-207" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Choosing strategies {.unnumbered .unlisted}</span></span>
<span id="cb107-208"><a href="#cb107-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-209"><a href="#cb107-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-210"><a href="#cb107-210" aria-hidden="true" tabindex="-1"></a>As a rule of thumb, if the search space is small or does not have a complex structure, grid search may be able to exhaustively evaluate the entire search space in a reasonable time. However, <span class="in">`r index('grid search')`</span> is generally not recommended due to the curse of dimensionality -- the grid size 'blows up' very quickly as the number of parameters to tune increases -- and insufficient coverage of numeric search spaces.</span>
<span id="cb107-211"><a href="#cb107-211" aria-hidden="true" tabindex="-1"></a>By construction, grid search cannot evaluate a large number of unique values per hyperparameter, which is suboptimal when some hyperparameters have minimal impact on performance while others do.</span>
<span id="cb107-212"><a href="#cb107-212" aria-hidden="true" tabindex="-1"></a>In such scenarios, <span class="in">`r index('random search')`</span> is often a better choice as it considers more unique values per hyperparameter compared to grid search.</span>
<span id="cb107-213"><a href="#cb107-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-214"><a href="#cb107-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-215"><a href="#cb107-215" aria-hidden="true" tabindex="-1"></a>For higher-dimensional search spaces or search spaces with more complex structure, more guided optimization algorithms such as evolutionary strategies or Bayesian optimization tend to perform better and are more likely to result in peak performance.</span>
<span id="cb107-216"><a href="#cb107-216" aria-hidden="true" tabindex="-1"></a>When choosing between <span class="in">`r index('evolutionary strategies')`</span> and <span class="in">`r index('Bayesian optimization', lower = FALSE)`</span>, the cost of function evaluation is highly relevant.</span>
<span id="cb107-217"><a href="#cb107-217" aria-hidden="true" tabindex="-1"></a>If hyperparameter configurations can be evaluated quickly, evolutionary strategies often work well.</span>
<span id="cb107-218"><a href="#cb107-218" aria-hidden="true" tabindex="-1"></a>On the other hand, if model evaluations are time-consuming and the optimization budget is limited, Bayesian optimization is usually preferred, as it is quite sample efficient compared to other algorithms, i.e., less function evaluations are needed to find good configurations.</span>
<span id="cb107-219"><a href="#cb107-219" aria-hidden="true" tabindex="-1"></a>Hence, Bayesian optimization is usually recommended for HPO.</span>
<span id="cb107-220"><a href="#cb107-220" aria-hidden="true" tabindex="-1"></a>While the optimization overhead of Bayesian optimization is comparably large (e.g., in each iteration, training of the surrogate model and optimizing the acquisition function), this has less of an impact in the context of relatively costly function evaluations such as resampling of ML models.</span>
<span id="cb107-221"><a href="#cb107-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-222"><a href="#cb107-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-223"><a href="#cb107-223" aria-hidden="true" tabindex="-1"></a>Finally, in cases where the hyperparameter optimization problem involves a meaningful fidelity parameter (e.g., number of epochs, number of trees, number of boosting rounds) and where the optimization budget needs to be spent efficiently, multi-fidelity hyperparameter optimization algorithms like Hyperband may be worth considering.</span>
<span id="cb107-224"><a href="#cb107-224" aria-hidden="true" tabindex="-1"></a>For further details on different tuners and practical recommendations, we refer to @hpo_practical.</span>
<span id="cb107-225"><a href="#cb107-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-226"><a href="#cb107-226" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb107-227"><a href="#cb107-227" aria-hidden="true" tabindex="-1"></a><span class="fu">## `$param_classes` and `$properties`</span></span>
<span id="cb107-228"><a href="#cb107-228" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$param_classes`</span> and <span class="in">`$properties`</span> fields of a <span class="in">`Tuner`</span> respectively provide information about which classes of hyperparameters can be handled and what properties the tuner can handle (e.g., hyperparameter dependencies, which are shown in @sec-defining-search-spaces, or multicriteria optimization, which is presented in @sec-multi-metrics-tuning):</span>
<span id="cb107-229"><a href="#cb107-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-230"><a href="#cb107-230" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-005}</span></span>
<span id="cb107-231"><a href="#cb107-231" aria-hidden="true" tabindex="-1"></a><span class="fu">tnr</span>(<span class="st">"random_search"</span>)<span class="sc">$</span>param_classes</span>
<span id="cb107-232"><a href="#cb107-232" aria-hidden="true" tabindex="-1"></a><span class="fu">tnr</span>(<span class="st">"random_search"</span>)<span class="sc">$</span>properties</span>
<span id="cb107-233"><a href="#cb107-233" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-234"><a href="#cb107-234" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb107-235"><a href="#cb107-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-236"><a href="#cb107-236" aria-hidden="true" tabindex="-1"></a>For our SVM example, we will use a grid search with a resolution of five for runtime reasons here (in practice a larger resolution would be preferred).</span>
<span id="cb107-237"><a href="#cb107-237" aria-hidden="true" tabindex="-1"></a>The resolution is the number of distinct values to try *per hyperparameter*, which means in our example the tuner will construct a 5x5 grid of 25 configurations of equally spaced points between the specified upper and lower bounds.</span>
<span id="cb107-238"><a href="#cb107-238" aria-hidden="true" tabindex="-1"></a>All configurations will be tried by the tuner (in random order) until either all configurations are evaluated or the terminator (@sec-terminator) signals that the budget is exhausted.</span>
<span id="cb107-239"><a href="#cb107-239" aria-hidden="true" tabindex="-1"></a>For grid and random search tuners, the <span class="in">`batch_size`</span> parameter controls how many configurations are evaluated at the same time when parallelization is enabled (see @sec-parallel-tuning), and also determines how many configurations should be applied before the terminator should check if the termination criterion has been reached.</span>
<span id="cb107-240"><a href="#cb107-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-241"><a href="#cb107-241" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-006}</span></span>
<span id="cb107-242"><a href="#cb107-242" aria-hidden="true" tabindex="-1"></a>tuner <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"grid_search"</span>, <span class="at">resolution =</span> <span class="dv">5</span>, <span class="at">batch_size =</span> <span class="dv">10</span>)</span>
<span id="cb107-243"><a href="#cb107-243" aria-hidden="true" tabindex="-1"></a>tuner</span>
<span id="cb107-244"><a href="#cb107-244" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-245"><a href="#cb107-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-246"><a href="#cb107-246" aria-hidden="true" tabindex="-1"></a>The <span class="in">`resolution`</span> and <span class="in">`batch_size`</span> parameters are termed <span class="in">`r index("control parameters", aside = TRUE)`</span> of the tuner, and other tuners will have other control parameters that can be set, as with learners these are accessible with <span class="in">`$param_set`</span>.</span>
<span id="cb107-247"><a href="#cb107-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-248"><a href="#cb107-248" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-007}</span></span>
<span id="cb107-249"><a href="#cb107-249" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span>param_set</span>
<span id="cb107-250"><a href="#cb107-250" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-251"><a href="#cb107-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-252"><a href="#cb107-252" aria-hidden="true" tabindex="-1"></a>While changing the control parameters of the tuner can improve optimal performance, we have to take care that is likely the default settings will fit most needs.</span>
<span id="cb107-253"><a href="#cb107-253" aria-hidden="true" tabindex="-1"></a>While it is not possible to cover all application cases, <span class="in">`mlr3tuning`</span>'s defaults were chosen to work well in most cases.</span>
<span id="cb107-254"><a href="#cb107-254" aria-hidden="true" tabindex="-1"></a>However, some control parameters like <span class="in">`batch_size`</span> often interact with the parallelization setup (further described in @sec-parallel-tuning) and may need to be adjusted accordingly.</span>
<span id="cb107-255"><a href="#cb107-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-256"><a href="#cb107-256" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Triggering the tuning process {.unnumbered .unlisted}</span></span>
<span id="cb107-257"><a href="#cb107-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-258"><a href="#cb107-258" aria-hidden="true" tabindex="-1"></a>Now that we have introduced all our components, we can start the tuning process.</span>
<span id="cb107-259"><a href="#cb107-259" aria-hidden="true" tabindex="-1"></a>To do this we simply pass the constructed <span class="in">`r ref("TuningInstanceBatchSingleCrit")`</span> to the <span class="in">`$optimize()`</span> method of the initialized <span class="in">`r ref("TunerBatch")`</span>, which triggers the hyperparameter optimization loop (@fig-optimization-loop-basic).</span>
<span id="cb107-260"><a href="#cb107-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-261"><a href="#cb107-261" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-008}</span></span>
<span id="cb107-262"><a href="#cb107-262" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb107-263"><a href="#cb107-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-264"><a href="#cb107-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-265"><a href="#cb107-265" aria-hidden="true" tabindex="-1"></a>The optimizer returns the best hyperparameter configuration and the corresponding performance, this information is also stored in <span class="in">`instance$result`</span>.</span>
<span id="cb107-266"><a href="#cb107-266" aria-hidden="true" tabindex="-1"></a>The first columns (here <span class="in">`cost`</span> and <span class="in">`gamma`</span>) will be named after the tuned hyperparameters and show the optimal values from the searched tuning spaces.</span>
<span id="cb107-267"><a href="#cb107-267" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$learner_param_vals`</span> field of the <span class="in">`$result`</span> lists the optimal hyperparameters from tuning, as well as the values of any other hyperparameters that were set, this is useful for onward model use (@sec-analyzing-result).</span>
<span id="cb107-268"><a href="#cb107-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-269"><a href="#cb107-269" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-009}</span></span>
<span id="cb107-270"><a href="#cb107-270" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result<span class="sc">$</span>learner_param_vals</span>
<span id="cb107-271"><a href="#cb107-271" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-272"><a href="#cb107-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-273"><a href="#cb107-273" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$x_domain`</span> field is most useful in the context of hyperparameter transformations, which we will briefly turn to next.</span>
<span id="cb107-274"><a href="#cb107-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-275"><a href="#cb107-275" aria-hidden="true" tabindex="-1"></a>:::{.callout-warning}</span>
<span id="cb107-276"><a href="#cb107-276" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overconfident Performance Estimates</span></span>
<span id="cb107-277"><a href="#cb107-277" aria-hidden="true" tabindex="-1"></a>A common mistake when tuning is to report the performance estimated on the resampling sets on which the tuning was performed (<span class="in">`instance$result$classif.ce`</span>) as an unbiased estimate of the model's performance and to ignore its optimistic bias.</span>
<span id="cb107-278"><a href="#cb107-278" aria-hidden="true" tabindex="-1"></a>The correct method is to test the model on more unseen data, which can be efficiently performed with nested resampling, we will discuss this in @sec-resample-overfitting.</span>
<span id="cb107-279"><a href="#cb107-279" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb107-280"><a href="#cb107-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-281"><a href="#cb107-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-282"><a href="#cb107-282" aria-hidden="true" tabindex="-1"></a><span class="fu">### Logarithmic Transformations {#sec-logarithmic-transformations}</span></span>
<span id="cb107-283"><a href="#cb107-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-284"><a href="#cb107-284" aria-hidden="true" tabindex="-1"></a>For many non-negative hyperparameters that have a large upper bound, tuning on a logarithmic scale can be more efficient than tuning on a linear scale.</span>
<span id="cb107-285"><a href="#cb107-285" aria-hidden="true" tabindex="-1"></a>By example, consider sampling uniformly in the interval $<span class="co">[</span><span class="ot">\log(1e-5), \log(1e5)</span><span class="co">]</span>$ and then exponentiating the outcome, the histograms in @fig-logscale show how we are initially sampling within a narrow range ($<span class="co">[</span><span class="ot">-11.5, 11.5</span><span class="co">]</span>$) but then exponentiating results in the majority of points being relatively small but a few being very large.</span>
<span id="cb107-286"><a href="#cb107-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-287"><a href="#cb107-287" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-010}</span></span>
<span id="cb107-288"><a href="#cb107-288" aria-hidden="true" tabindex="-1"></a>cost <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1000</span>, <span class="fu">log</span>(<span class="fl">1e-5</span>), <span class="fu">log</span>(<span class="fl">1e5</span>))</span>
<span id="cb107-289"><a href="#cb107-289" aria-hidden="true" tabindex="-1"></a>exp_cost <span class="ot">=</span> <span class="fu">exp</span>(cost)</span>
<span id="cb107-290"><a href="#cb107-290" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-291"><a href="#cb107-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-292"><a href="#cb107-292" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-011, echo = FALSE}</span></span>
<span id="cb107-293"><a href="#cb107-293" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-logscale</span></span>
<span id="cb107-294"><a href="#cb107-294" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Histograms of uniformly sampled values from the interval $[\log(1e-5), \log(1e5)]$ before (left) and after (right) exponentiation.</span></span>
<span id="cb107-295"><a href="#cb107-295" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb107-296"><a href="#cb107-296" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Linear scale sampled by the tuner."</span></span>
<span id="cb107-297"><a href="#cb107-297" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Logarithmic scale seen by the learner."</span></span>
<span id="cb107-298"><a href="#cb107-298" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] with roughly equal length bars. Right plot shows values between [1e-5, 1e5] with the vast majority close to 0 and very few at other points.</span></span>
<span id="cb107-299"><a href="#cb107-299" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb107-300"><a href="#cb107-300" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb107-301"><a href="#cb107-301" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">cost =</span> cost)</span>
<span id="cb107-302"><a href="#cb107-302" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(data, <span class="fu">aes</span>(<span class="at">x =</span> cost)) <span class="sc">+</span></span>
<span id="cb107-303"><a href="#cb107-303" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(</span>
<span id="cb107-304"><a href="#cb107-304" aria-hidden="true" tabindex="-1"></a>    <span class="at">bins =</span> <span class="dv">15</span>,</span>
<span id="cb107-305"><a href="#cb107-305" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="fl">0.8</span>,</span>
<span id="cb107-306"><a href="#cb107-306" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb107-307"><a href="#cb107-307" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span>
<span id="cb107-308"><a href="#cb107-308" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">cost =</span> exp_cost)</span>
<span id="cb107-309"><a href="#cb107-309" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(data, <span class="fu">aes</span>(<span class="at">x =</span> cost)) <span class="sc">+</span></span>
<span id="cb107-310"><a href="#cb107-310" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(</span>
<span id="cb107-311"><a href="#cb107-311" aria-hidden="true" tabindex="-1"></a>    <span class="at">bins =</span> <span class="dv">15</span>,</span>
<span id="cb107-312"><a href="#cb107-312" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="fl">0.8</span>,</span>
<span id="cb107-313"><a href="#cb107-313" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb107-314"><a href="#cb107-314" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb107-315"><a href="#cb107-315" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_grey</span>()</span>
<span id="cb107-316"><a href="#cb107-316" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-317"><a href="#cb107-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-318"><a href="#cb107-318" aria-hidden="true" tabindex="-1"></a>To add this transformation to a hyperparameter we simply pass <span class="in">`logscale = TRUE`</span> to <span class="in">`r ref("to_tune()")`</span>.</span>
<span id="cb107-319"><a href="#cb107-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-320"><a href="#cb107-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-012}</span></span>
<span id="cb107-321"><a href="#cb107-321" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-322"><a href="#cb107-322" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-323"><a href="#cb107-323" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-324"><a href="#cb107-324" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb107-325"><a href="#cb107-325" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb107-326"><a href="#cb107-326" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-327"><a href="#cb107-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-328"><a href="#cb107-328" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">ti</span>(</span>
<span id="cb107-329"><a href="#cb107-329" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb107-330"><a href="#cb107-330" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> learner,</span>
<span id="cb107-331"><a href="#cb107-331" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>),</span>
<span id="cb107-332"><a href="#cb107-332" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb107-333"><a href="#cb107-333" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"none"</span>)</span>
<span id="cb107-334"><a href="#cb107-334" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-335"><a href="#cb107-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-336"><a href="#cb107-336" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb107-337"><a href="#cb107-337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-338"><a href="#cb107-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-339"><a href="#cb107-339" aria-hidden="true" tabindex="-1"></a>We can see from this example that using the log transformation improved the hyperparameter search, as <span class="in">`classif.ce`</span> is smaller.</span>
<span id="cb107-340"><a href="#cb107-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-341"><a href="#cb107-341" aria-hidden="true" tabindex="-1"></a>Note that the fields <span class="in">`cost`</span> and <span class="in">`gamma`</span> show the optimal values *before* transformation, whereas `x_domain` and `learner_param_vals` contain optimal values *after* transformation, it is these latter fields you would take forward for future model use.</span>
<span id="cb107-342"><a href="#cb107-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-343"><a href="#cb107-343" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-013}</span></span>
<span id="cb107-344"><a href="#cb107-344" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result<span class="sc">$</span>x_domain</span>
<span id="cb107-345"><a href="#cb107-345" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-346"><a href="#cb107-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-347"><a href="#cb107-347" aria-hidden="true" tabindex="-1"></a>In @sec-defining-search-spaces we will look at how to implement more complex, custom transformations for any hyperparameter or combination of hyperparameters.</span>
<span id="cb107-348"><a href="#cb107-348" aria-hidden="true" tabindex="-1"></a>Now we will look at how to put everything into practice so we can make use of the tuned model (and the transformed hyperparameters).</span>
<span id="cb107-349"><a href="#cb107-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-350"><a href="#cb107-350" aria-hidden="true" tabindex="-1"></a><span class="fu">### Analyzing and Using the Result {#sec-analyzing-result}</span></span>
<span id="cb107-351"><a href="#cb107-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-352"><a href="#cb107-352" aria-hidden="true" tabindex="-1"></a>Independently of whether you use <span class="in">`r ref("ti()")`</span> or <span class="in">`r ref("tune()")`</span>, or if you include transformations or not, the created objects and the output are structurally the same and the instance's archive lists all evaluated hyperparameter configurations:</span>
<span id="cb107-353"><a href="#cb107-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-354"><a href="#cb107-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-014}</span></span>
<span id="cb107-355"><a href="#cb107-355" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, .(cost, gamma, classif.ce)]</span>
<span id="cb107-356"><a href="#cb107-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-357"><a href="#cb107-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-358"><a href="#cb107-358" aria-hidden="true" tabindex="-1"></a>Each row of the archive is a different evaluated configuration.</span>
<span id="cb107-359"><a href="#cb107-359" aria-hidden="true" tabindex="-1"></a>The columns show the tested configurations (before transformation) and the chosen performance measure.</span>
<span id="cb107-360"><a href="#cb107-360" aria-hidden="true" tabindex="-1"></a>We can also manually inspect the archive to determine other important features such as time of evaluation, model runtime, and any errors or warnings that occurred during tuning.</span>
<span id="cb107-361"><a href="#cb107-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-362"><a href="#cb107-362" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-015}</span></span>
<span id="cb107-363"><a href="#cb107-363" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb107-364"><a href="#cb107-364" aria-hidden="true" tabindex="-1"></a>  .(timestamp, runtime_learners, errors, warnings)]</span>
<span id="cb107-365"><a href="#cb107-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-366"><a href="#cb107-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-367"><a href="#cb107-367" aria-hidden="true" tabindex="-1"></a>Another powerful feature of the instance is that we can score the internal <span class="in">`r ref("ResampleResult")`</span>s on a different performance measure, for example looking at false negative rate and false positive rate as well as classification error:</span>
<span id="cb107-368"><a href="#cb107-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-369"><a href="#cb107-369" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-016}</span></span>
<span id="cb107-370"><a href="#cb107-370" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive,</span>
<span id="cb107-371"><a href="#cb107-371" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msrs</span>(<span class="fu">c</span>(<span class="st">"classif.fpr"</span>, <span class="st">"classif.fnr"</span>)))[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span> ,</span>
<span id="cb107-372"><a href="#cb107-372" aria-hidden="true" tabindex="-1"></a>  .(cost, gamma, classif.ce, classif.fpr, classif.fnr)]</span>
<span id="cb107-373"><a href="#cb107-373" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-374"><a href="#cb107-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-375"><a href="#cb107-375" aria-hidden="true" tabindex="-1"></a>You can access all the resamplings combined in a <span class="in">`r ref("BenchmarkResult")`</span> object with <span class="in">`instance$archive$benchmark_result`</span>.</span>
<span id="cb107-376"><a href="#cb107-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-377"><a href="#cb107-377" aria-hidden="true" tabindex="-1"></a>Finally, to visualize the results, you can use <span class="in">`r ref("mlr3viz::autoplot.TuningInstanceBatchSingleCrit")`</span> (@fig-surface).</span>
<span id="cb107-378"><a href="#cb107-378" aria-hidden="true" tabindex="-1"></a>In this example we can observe one of the flaws (by design) in grid search, despite testing 25 configurations, we only saw five unique values for each hyperparameter.</span>
<span id="cb107-379"><a href="#cb107-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-380"><a href="#cb107-380" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-017}</span></span>
<span id="cb107-381"><a href="#cb107-381" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-surface</span></span>
<span id="cb107-382"><a href="#cb107-382" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Model performance with different configurations for `cost` and `gamma`. Bright yellow regions represent the model performing worse and dark blue performing better. We can see that high `cost` values and low `gamma` values achieve the best performance. Note that we should not directly infer the performance of new unseen values from the heatmap since it is only an interpolation based on a surrogate model (`regr.ranger`). However, we can see the general interaction between the hyperparameters.</span></span>
<span id="cb107-383"><a href="#cb107-383" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Heatmap showing model performance during HPO. y-axis is 'gamma' parameter between (-10,10) and x-axis is 'cost' parameter between (-10,10). The heatmap shows squares covering all points on the plot and circular points indicating configurations tried in our optimization. The top-left quadrant is all yellow indicating poor performance when gamma is high and cost is low. The bottom-right is dark blue indicating good performance when cost is high and gamma is low.</span></span>
<span id="cb107-384"><a href="#cb107-384" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(instance, <span class="at">type =</span> <span class="st">"surface"</span>)</span>
<span id="cb107-385"><a href="#cb107-385" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-386"><a href="#cb107-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-387"><a href="#cb107-387" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Training an optimized model {.unnumbered .unlisted}</span></span>
<span id="cb107-388"><a href="#cb107-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-389"><a href="#cb107-389" aria-hidden="true" tabindex="-1"></a>Once we found good hyperparameters for our learner through tuning, we can use them to train a final model on the whole data.</span>
<span id="cb107-390"><a href="#cb107-390" aria-hidden="true" tabindex="-1"></a>To do this we simply construct a new learner with the same underlying algorithm and set the learner hyperparameters to the optimal configuration:</span>
<span id="cb107-391"><a href="#cb107-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-392"><a href="#cb107-392" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-018}</span></span>
<span id="cb107-393"><a href="#cb107-393" aria-hidden="true" tabindex="-1"></a>lrn_svm_tuned <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>)</span>
<span id="cb107-394"><a href="#cb107-394" aria-hidden="true" tabindex="-1"></a>lrn_svm_tuned<span class="sc">$</span>param_set<span class="sc">$</span>values <span class="ot">=</span> instance<span class="sc">$</span>result_learner_param_vals</span>
<span id="cb107-395"><a href="#cb107-395" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-396"><a href="#cb107-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-397"><a href="#cb107-397" aria-hidden="true" tabindex="-1"></a>Now we can train the learner on the full dataset and we are ready to make predictions.</span>
<span id="cb107-398"><a href="#cb107-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-399"><a href="#cb107-399" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-019}</span></span>
<span id="cb107-400"><a href="#cb107-400" aria-hidden="true" tabindex="-1"></a>lrn_svm_tuned<span class="sc">$</span><span class="fu">train</span>(tsk_sonar)<span class="sc">$</span>model</span>
<span id="cb107-401"><a href="#cb107-401" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-402"><a href="#cb107-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-403"><a href="#cb107-403" aria-hidden="true" tabindex="-1"></a><span class="fu">## Convenient Tuning with `tune` and `auto_tuner` {#sec-autotuner}</span></span>
<span id="cb107-404"><a href="#cb107-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-405"><a href="#cb107-405" aria-hidden="true" tabindex="-1"></a>In the previous section, we looked at constructing and manually putting together the components of HPO by creating a tuning instance using <span class="in">`r ref("ti()")`</span>, passing this to the tuner, and then calling <span class="in">`$optimize()`</span> to start the tuning process.</span>
<span id="cb107-406"><a href="#cb107-406" aria-hidden="true" tabindex="-1"></a><span class="in">`mlr3tuning`</span> includes two helper methods to simplify this process further.</span>
<span id="cb107-407"><a href="#cb107-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-408"><a href="#cb107-408" aria-hidden="true" tabindex="-1"></a>The first helper function is <span class="in">`r ref("tune()")`</span>, which creates the tuning instance and calls <span class="in">`$optimize()`</span> for you.</span>
<span id="cb107-409"><a href="#cb107-409" aria-hidden="true" tabindex="-1"></a>You may prefer the manual method with <span class="in">`ti()`</span> if you want to view and make changes to the instance before tuning.</span>
<span id="cb107-410"><a href="#cb107-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-411"><a href="#cb107-411" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-020}</span></span>
<span id="cb107-412"><a href="#cb107-412" aria-hidden="true" tabindex="-1"></a>tnr_grid_search <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"grid_search"</span>, <span class="at">resolution =</span> <span class="dv">5</span>, <span class="at">batch_size =</span> <span class="dv">5</span>)</span>
<span id="cb107-413"><a href="#cb107-413" aria-hidden="true" tabindex="-1"></a>lrn_svm <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-414"><a href="#cb107-414" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-415"><a href="#cb107-415" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-416"><a href="#cb107-416" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb107-417"><a href="#cb107-417" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb107-418"><a href="#cb107-418" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-419"><a href="#cb107-419" aria-hidden="true" tabindex="-1"></a>rsmp_cv3 <span class="ot">=</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>)</span>
<span id="cb107-420"><a href="#cb107-420" aria-hidden="true" tabindex="-1"></a>msr_ce <span class="ot">=</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>)</span>
<span id="cb107-421"><a href="#cb107-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-422"><a href="#cb107-422" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(</span>
<span id="cb107-423"><a href="#cb107-423" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_grid_search,</span>
<span id="cb107-424"><a href="#cb107-424" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb107-425"><a href="#cb107-425" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_svm,</span>
<span id="cb107-426"><a href="#cb107-426" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_cv3,</span>
<span id="cb107-427"><a href="#cb107-427" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> msr_ce</span>
<span id="cb107-428"><a href="#cb107-428" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-429"><a href="#cb107-429" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result</span>
<span id="cb107-430"><a href="#cb107-430" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-431"><a href="#cb107-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-432"><a href="#cb107-432" aria-hidden="true" tabindex="-1"></a>The other helper function is <span class="in">`r ref("auto_tuner")`</span>, which creates an object of class <span class="in">`r ref("AutoTuner", index = TRUE)`</span> (@fig-auto-tuner).</span>
<span id="cb107-433"><a href="#cb107-433" aria-hidden="true" tabindex="-1"></a>The <span class="in">`AutoTuner`</span> inherits from the <span class="in">`r ref("Learner")`</span> class and wraps all the information needed for tuning, which means you can treat a learner waiting to be optimized just like any other learner.</span>
<span id="cb107-434"><a href="#cb107-434" aria-hidden="true" tabindex="-1"></a>Under the hood, the <span class="in">`AutoTuner`</span> essentially runs <span class="in">`tune()`</span> on the data that is passed to the model when <span class="in">`$train()`</span> is called and then sets the learner parameters to the optimal configuration.</span>
<span id="cb107-435"><a href="#cb107-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-436"><a href="#cb107-436" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-021}</span></span>
<span id="cb107-437"><a href="#cb107-437" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_tuner</span>(</span>
<span id="cb107-438"><a href="#cb107-438" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_grid_search,</span>
<span id="cb107-439"><a href="#cb107-439" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_svm,</span>
<span id="cb107-440"><a href="#cb107-440" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_cv3,</span>
<span id="cb107-441"><a href="#cb107-441" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> msr_ce</span>
<span id="cb107-442"><a href="#cb107-442" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-443"><a href="#cb107-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-444"><a href="#cb107-444" aria-hidden="true" tabindex="-1"></a>at</span>
<span id="cb107-445"><a href="#cb107-445" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-446"><a href="#cb107-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-447"><a href="#cb107-447" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-022, echo=FALSE, out.width = "60%"}</span></span>
<span id="cb107-448"><a href="#cb107-448" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-auto-tuner</span></span>
<span id="cb107-449"><a href="#cb107-449" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustration of an Auto-Tuner."</span></span>
<span id="cb107-450"><a href="#cb107-450" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Flow diagram. Top box "Input: Training Data, Learner, Performance Metric, Resampling Strategy, Search Space". This has an arrow to "Auto-Tuner" which is a box containing "Tuning", which has three arrows pointing at each other in a circle representing the tuning process, and "Final Model Fit: Fit Learner with Optimal Hyperparameters on Dtrain". "Auto-Tuner" then points to "Return: Model, Optimal Hyperparameters".'</span></span>
<span id="cb107-451"><a href="#cb107-451" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-12"</span>)</span>
<span id="cb107-452"><a href="#cb107-452" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-453"><a href="#cb107-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-454"><a href="#cb107-454" aria-hidden="true" tabindex="-1"></a>And we can now call <span class="in">`$train()`</span>, which will first tune the hyperparameters in the search space listed above before fitting the optimal model.</span>
<span id="cb107-455"><a href="#cb107-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-456"><a href="#cb107-456" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-023}</span></span>
<span id="cb107-457"><a href="#cb107-457" aria-hidden="true" tabindex="-1"></a>split <span class="ot">=</span> <span class="fu">partition</span>(tsk_sonar)</span>
<span id="cb107-458"><a href="#cb107-458" aria-hidden="true" tabindex="-1"></a>at<span class="sc">$</span><span class="fu">train</span>(tsk_sonar, <span class="at">row_ids =</span> split<span class="sc">$</span>train)</span>
<span id="cb107-459"><a href="#cb107-459" aria-hidden="true" tabindex="-1"></a>at<span class="sc">$</span><span class="fu">predict</span>(tsk_sonar, <span class="at">row_ids =</span> split<span class="sc">$</span>test)<span class="sc">$</span><span class="fu">score</span>()</span>
<span id="cb107-460"><a href="#cb107-460" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-461"><a href="#cb107-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-462"><a href="#cb107-462" aria-hidden="true" tabindex="-1"></a>The <span class="in">`AutoTuner`</span> contains a tuning instance that can be analyzed like any other instance.</span>
<span id="cb107-463"><a href="#cb107-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-464"><a href="#cb107-464" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-024}</span></span>
<span id="cb107-465"><a href="#cb107-465" aria-hidden="true" tabindex="-1"></a>at<span class="sc">$</span>tuning_instance<span class="sc">$</span>result</span>
<span id="cb107-466"><a href="#cb107-466" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-467"><a href="#cb107-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-468"><a href="#cb107-468" aria-hidden="true" tabindex="-1"></a>We could also pass the <span class="in">`AutoTuner`</span> to <span class="in">`r ref("resample()")`</span> and <span class="in">`r ref("benchmark()")`</span>, which would result in a nested resampling, discussed next.</span>
<span id="cb107-469"><a href="#cb107-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-470"><a href="#cb107-470" aria-hidden="true" tabindex="-1"></a><span class="fu">## Nested Resampling {#sec-nested-resampling}</span></span>
<span id="cb107-471"><a href="#cb107-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-472"><a href="#cb107-472" aria-hidden="true" tabindex="-1"></a>HPO requires additional resampling to reduce bias when estimating the performance of a model.</span>
<span id="cb107-473"><a href="#cb107-473" aria-hidden="true" tabindex="-1"></a>If the same data is used for determining the optimal configuration and the evaluation of the resulting model itself, the actual performance estimate might be biased <span class="co">[</span><span class="ot">@Simon2007</span><span class="co">]</span>.</span>
<span id="cb107-474"><a href="#cb107-474" aria-hidden="true" tabindex="-1"></a>This is analogous to <span class="in">`r index("optimism of the training error")`</span> described in @james_introduction_2014, which occurs when training error is taken as an estimate of out-of-sample performance.</span>
<span id="cb107-475"><a href="#cb107-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-476"><a href="#cb107-476" aria-hidden="true" tabindex="-1"></a><span class="in">`r index("Nested resampling")`</span> separates model optimization from the process of estimating the performance of the tuned model by adding an additional resampling, i.e., while model performance is estimated using a resampling method in the 'usual way', tuning is then performed by resampling the resampled data (@fig-nested-resampling).</span>
<span id="cb107-477"><a href="#cb107-477" aria-hidden="true" tabindex="-1"></a>For more details and a formal introduction to nested resampling the reader is referred to @hpo_practical and @Simon2007.</span>
<span id="cb107-478"><a href="#cb107-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-479"><a href="#cb107-479" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-025, echo = FALSE, out.width = "80%"}</span></span>
<span id="cb107-480"><a href="#cb107-480" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-nested-resampling</span></span>
<span id="cb107-481"><a href="#cb107-481" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: An illustration of nested resampling. The large blocks represent three-fold CV for the outer resampling for model evaluation and the small blocks represent four-fold CV for the inner resampling for HPO. The light blue blocks are the training sets and the dark blue blocks are the test sets.</span></span>
<span id="cb107-482"><a href="#cb107-482" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: The image shows three rows of large blocks representing three-fold CV for the outer resampling. Below the blocks are four further rows of small blocks representing four-fold CV for the inner resampling. Text annotations highlight how tuned parameters from the inner resampling are passed to the outer resampling.</span></span>
<span id="cb107-483"><a href="#cb107-483" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-11"</span>)</span>
<span id="cb107-484"><a href="#cb107-484" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-485"><a href="#cb107-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-486"><a href="#cb107-486" aria-hidden="true" tabindex="-1"></a>@fig-nested-resampling represents the following example of nested resampling:</span>
<span id="cb107-487"><a href="#cb107-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-488"><a href="#cb107-488" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Outer resampling start -- Instantiate three-fold CV to create different testing and training datasets.</span>
<span id="cb107-489"><a href="#cb107-489" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Inner resampling -- Within the outer training data instantiate four-fold CV to create different inner testing and training datasets.</span>
<span id="cb107-490"><a href="#cb107-490" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>HPO -- Tune the hyperparameters on the outer training set (large, light blue blocks) using the inner data splits.</span>
<span id="cb107-491"><a href="#cb107-491" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Training -- Fit the learner on the outer training dataset using the optimal hyperparameter configuration obtained from the inner resampling (small blocks).</span>
<span id="cb107-492"><a href="#cb107-492" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Evaluation -- Evaluate the performance of the learner on the outer testing data (large, dark blue block).</span>
<span id="cb107-493"><a href="#cb107-493" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>Outer resampling repeats -- Repeat (2)-(5) for each of the three outer folds.</span>
<span id="cb107-494"><a href="#cb107-494" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>Aggregation -- Take the sample mean of the three performance values for an unbiased performance estimate.</span>
<span id="cb107-495"><a href="#cb107-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-496"><a href="#cb107-496" aria-hidden="true" tabindex="-1"></a>The inner resampling produces generalization performance estimates for each configuration and selects the optimal configuration to be evaluated on the outer resampling.</span>
<span id="cb107-497"><a href="#cb107-497" aria-hidden="true" tabindex="-1"></a>The outer resampling then produces generalization estimates for these optimal configurations.</span>
<span id="cb107-498"><a href="#cb107-498" aria-hidden="true" tabindex="-1"></a>The result from the outer resampling can be used for comparison to other models trained and tested on the same outer folds.</span>
<span id="cb107-499"><a href="#cb107-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-500"><a href="#cb107-500" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb107-501"><a href="#cb107-501" aria-hidden="true" tabindex="-1"></a><span class="fu">## Nested Resampling and Parallelization</span></span>
<span id="cb107-502"><a href="#cb107-502" aria-hidden="true" tabindex="-1"></a>Nested resampling is computationally expensive, three outer folds and four inner folds with a grid search of resolution five used to tune two parameters, results in $3*4*5^2 = 300$ iterations of model training/testing.</span>
<span id="cb107-503"><a href="#cb107-503" aria-hidden="true" tabindex="-1"></a>If you have the resources we recommend utilizing parallelization when tuning (@sec-parallelization).</span>
<span id="cb107-504"><a href="#cb107-504" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb107-505"><a href="#cb107-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-506"><a href="#cb107-506" aria-hidden="true" tabindex="-1"></a>A common mistake is to think of nested resampling as a method to select optimal model configurations.</span>
<span id="cb107-507"><a href="#cb107-507" aria-hidden="true" tabindex="-1"></a>Nested resampling is a method to compare models and to estimate the generalization performance of a tuned model, however, this is the performance based on multiple different configurations (one from each outer fold) and not performance based on a *single* configuration (@sec-resample-overfitting).</span>
<span id="cb107-508"><a href="#cb107-508" aria-hidden="true" tabindex="-1"></a>If you are interested in identifying optimal configurations, then use <span class="in">`r ref("tune()", index = TRUE)`</span>/<span class="in">`r ref("ti()")`</span> or <span class="in">`r ref("auto_tuner()", index = TRUE)`</span> with <span class="in">`$train()`</span> on the complete dataset.</span>
<span id="cb107-509"><a href="#cb107-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-510"><a href="#cb107-510" aria-hidden="true" tabindex="-1"></a><span class="fu">### Nested Resampling with an `AutoTuner`</span></span>
<span id="cb107-511"><a href="#cb107-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-512"><a href="#cb107-512" aria-hidden="true" tabindex="-1"></a>While the theory of nested resampling may seem complicated, it is all automated in <span class="in">`mlr3tuning`</span> by simply passing an <span class="in">`AutoTuner`</span> to <span class="in">`r ref("resample()")`</span> or <span class="in">`r ref("benchmark()")`</span>.</span>
<span id="cb107-513"><a href="#cb107-513" aria-hidden="true" tabindex="-1"></a>Continuing with our previous example, we will use the auto-tuner to resample a support vector classifier with three-fold CV in the outer resampling and four-fold CV in the inner resampling.</span>
<span id="cb107-514"><a href="#cb107-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-515"><a href="#cb107-515" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-026}</span></span>
<span id="cb107-516"><a href="#cb107-516" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_tuner</span>(</span>
<span id="cb107-517"><a href="#cb107-517" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_grid_search,</span>
<span id="cb107-518"><a href="#cb107-518" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_svm,</span>
<span id="cb107-519"><a href="#cb107-519" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">4</span>),</span>
<span id="cb107-520"><a href="#cb107-520" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> msr_ce,</span>
<span id="cb107-521"><a href="#cb107-521" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-522"><a href="#cb107-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-523"><a href="#cb107-523" aria-hidden="true" tabindex="-1"></a>rr <span class="ot">=</span> <span class="fu">resample</span>(tsk_sonar, at, rsmp_cv3, <span class="at">store_models =</span> <span class="cn">TRUE</span>)</span>
<span id="cb107-524"><a href="#cb107-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-525"><a href="#cb107-525" aria-hidden="true" tabindex="-1"></a>rr</span>
<span id="cb107-526"><a href="#cb107-526" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-527"><a href="#cb107-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-528"><a href="#cb107-528" aria-hidden="true" tabindex="-1"></a>Note that we set <span class="in">`store_models = TRUE`</span> so that the <span class="in">`AutoTuner`</span> models (fitted on the outer training data) are stored, which also enables investigation of the inner tuning instances.</span>
<span id="cb107-529"><a href="#cb107-529" aria-hidden="true" tabindex="-1"></a>While we used k-fold CV for both the inner and outer resampling strategy, you could use different resampling strategies (@sec-resampling) and also different parallelization methods (@sec-nested-resampling-parallelization).</span>
<span id="cb107-530"><a href="#cb107-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-531"><a href="#cb107-531" aria-hidden="true" tabindex="-1"></a>The estimated performance of a tuned model is reported as the aggregated performance of all outer resampling iterations, which is a less biased estimate of future model performance.</span>
<span id="cb107-532"><a href="#cb107-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-533"><a href="#cb107-533" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-027}</span></span>
<span id="cb107-534"><a href="#cb107-534" aria-hidden="true" tabindex="-1"></a>rr<span class="sc">$</span><span class="fu">aggregate</span>()</span>
<span id="cb107-535"><a href="#cb107-535" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-536"><a href="#cb107-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-537"><a href="#cb107-537" aria-hidden="true" tabindex="-1"></a>In addition to the methods described in @sec-resampling, <span class="in">`r ref("extract_inner_tuning_results()")`</span> and <span class="in">`r ref("extract_inner_tuning_archives()")`</span> return the optimal configurations (across all outer folds) and full tuning archives, respectively.</span>
<span id="cb107-538"><a href="#cb107-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-539"><a href="#cb107-539" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-028}</span></span>
<span id="cb107-540"><a href="#cb107-540" aria-hidden="true" tabindex="-1"></a><span class="fu">extract_inner_tuning_results</span>(rr)[,</span>
<span id="cb107-541"><a href="#cb107-541" aria-hidden="true" tabindex="-1"></a>  .(iteration, cost, gamma, classif.ce)]</span>
<span id="cb107-542"><a href="#cb107-542" aria-hidden="true" tabindex="-1"></a><span class="fu">extract_inner_tuning_archives</span>(rr)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb107-543"><a href="#cb107-543" aria-hidden="true" tabindex="-1"></a>  .(iteration, cost, gamma, classif.ce)]</span>
<span id="cb107-544"><a href="#cb107-544" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-545"><a href="#cb107-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-546"><a href="#cb107-546" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Right (and Wrong) Way to Estimate Performance {#sec-resample-overfitting}</span></span>
<span id="cb107-547"><a href="#cb107-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-548"><a href="#cb107-548" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb107-549"><a href="#cb107-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-550"><a href="#cb107-550" aria-hidden="true" tabindex="-1"></a>In this short section we will empirically demonstrate that directly reporting tuning performance without nested resampling results in optimistically biased performance estimates.</span>
<span id="cb107-551"><a href="#cb107-551" aria-hidden="true" tabindex="-1"></a>In this experiment we tune several parameters from <span class="in">`lrn("classif.xgboost")`</span>.</span>
<span id="cb107-552"><a href="#cb107-552" aria-hidden="true" tabindex="-1"></a>To best estimate the generalization performance we make use of the <span class="in">`"moons"`</span> <span class="in">`r ref("TaskGenerator", aside = TRUE)`</span>.</span>
<span id="cb107-553"><a href="#cb107-553" aria-hidden="true" tabindex="-1"></a>The <span class="in">`TaskGenerator`</span> class is used when you want to simulate data for use in experiments, these are very useful in cases such as this experiment when you need access to an infinite number of data points to estimate quantities such as the generalization error.</span>
<span id="cb107-554"><a href="#cb107-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-555"><a href="#cb107-555" aria-hidden="true" tabindex="-1"></a>We begin by loading our learner, task generator, and generating 100 training data points and 1,000,000 testing data points.</span>
<span id="cb107-556"><a href="#cb107-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-557"><a href="#cb107-557" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-029}</span></span>
<span id="cb107-558"><a href="#cb107-558" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb107-559"><a href="#cb107-559" aria-hidden="true" tabindex="-1"></a>lrn_xgboost <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.xgboost"</span>,</span>
<span id="cb107-560"><a href="#cb107-560" aria-hidden="true" tabindex="-1"></a>  <span class="at">eta               =</span> <span class="fu">to_tune</span>(<span class="fl">1e-4</span>, <span class="dv">1</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-561"><a href="#cb107-561" aria-hidden="true" tabindex="-1"></a>  <span class="at">max_depth         =</span> <span class="fu">to_tune</span>(<span class="dv">1</span>, <span class="dv">20</span>),</span>
<span id="cb107-562"><a href="#cb107-562" aria-hidden="true" tabindex="-1"></a>  <span class="at">colsample_bytree  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb107-563"><a href="#cb107-563" aria-hidden="true" tabindex="-1"></a>  <span class="at">colsample_bylevel =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb107-564"><a href="#cb107-564" aria-hidden="true" tabindex="-1"></a>  <span class="at">lambda            =</span> <span class="fu">to_tune</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-565"><a href="#cb107-565" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha             =</span> <span class="fu">to_tune</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb107-566"><a href="#cb107-566" aria-hidden="true" tabindex="-1"></a>  <span class="at">subsample         =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>)</span>
<span id="cb107-567"><a href="#cb107-567" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-568"><a href="#cb107-568" aria-hidden="true" tabindex="-1"></a>tsk_moons <span class="ot">=</span> <span class="fu">tgen</span>(<span class="st">"moons"</span>)</span>
<span id="cb107-569"><a href="#cb107-569" aria-hidden="true" tabindex="-1"></a>tsk_moons_train <span class="ot">=</span> tsk_moons<span class="sc">$</span><span class="fu">generate</span>(<span class="dv">100</span>)</span>
<span id="cb107-570"><a href="#cb107-570" aria-hidden="true" tabindex="-1"></a>tsk_moons_test <span class="ot">=</span> tsk_moons<span class="sc">$</span><span class="fu">generate</span>(<span class="dv">1000000</span>)</span>
<span id="cb107-571"><a href="#cb107-571" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-572"><a href="#cb107-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-573"><a href="#cb107-573" aria-hidden="true" tabindex="-1"></a>Now we will tune the learner with respect to the classification error, using holdout resampling and random search with 700 evaluations. We then report the tuning performance without nested resampling.</span>
<span id="cb107-574"><a href="#cb107-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-575"><a href="#cb107-575" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-030}</span></span>
<span id="cb107-576"><a href="#cb107-576" aria-hidden="true" tabindex="-1"></a>tnr_random <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"random_search"</span>)</span>
<span id="cb107-577"><a href="#cb107-577" aria-hidden="true" tabindex="-1"></a>rsmp_holdout <span class="ot">=</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>)</span>
<span id="cb107-578"><a href="#cb107-578" aria-hidden="true" tabindex="-1"></a>trm_evals700 <span class="ot">=</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">700</span>)</span>
<span id="cb107-579"><a href="#cb107-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-580"><a href="#cb107-580" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(</span>
<span id="cb107-581"><a href="#cb107-581" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_random,</span>
<span id="cb107-582"><a href="#cb107-582" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_moons_train,</span>
<span id="cb107-583"><a href="#cb107-583" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_xgboost,</span>
<span id="cb107-584"><a href="#cb107-584" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_holdout,</span>
<span id="cb107-585"><a href="#cb107-585" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> msr_ce,</span>
<span id="cb107-586"><a href="#cb107-586" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> trm_evals700</span>
<span id="cb107-587"><a href="#cb107-587" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-588"><a href="#cb107-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-589"><a href="#cb107-589" aria-hidden="true" tabindex="-1"></a>insample <span class="ot">=</span> instance<span class="sc">$</span>result_y</span>
<span id="cb107-590"><a href="#cb107-590" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-591"><a href="#cb107-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-592"><a href="#cb107-592" aria-hidden="true" tabindex="-1"></a>Next, we estimate generalization error by nested resampling (below we use an outer five-fold CV), using an <span class="in">`AutoTuner`</span>:</span>
<span id="cb107-593"><a href="#cb107-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-594"><a href="#cb107-594" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-031}</span></span>
<span id="cb107-595"><a href="#cb107-595" aria-hidden="true" tabindex="-1"></a><span class="co"># same setup as above</span></span>
<span id="cb107-596"><a href="#cb107-596" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_tuner</span>(</span>
<span id="cb107-597"><a href="#cb107-597" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_random,</span>
<span id="cb107-598"><a href="#cb107-598" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_xgboost,</span>
<span id="cb107-599"><a href="#cb107-599" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_holdout,</span>
<span id="cb107-600"><a href="#cb107-600" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> msr_ce,</span>
<span id="cb107-601"><a href="#cb107-601" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> trm_evals700</span>
<span id="cb107-602"><a href="#cb107-602" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-603"><a href="#cb107-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-604"><a href="#cb107-604" aria-hidden="true" tabindex="-1"></a>rsmp_cv5 <span class="ot">=</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">5</span>)</span>
<span id="cb107-605"><a href="#cb107-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-606"><a href="#cb107-606" aria-hidden="true" tabindex="-1"></a>outsample <span class="ot">=</span> <span class="fu">resample</span>(tsk_moons_train, at, rsmp_cv5)<span class="sc">$</span><span class="fu">aggregate</span>()</span>
<span id="cb107-607"><a href="#cb107-607" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-608"><a href="#cb107-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-609"><a href="#cb107-609" aria-hidden="true" tabindex="-1"></a>And finally, we estimate the <span class="in">`r index('generalization error')`</span> by training the tuned learner (i.e., using the values from the <span class="in">`instance`</span> above) on the full training data again and predicting on the test data.</span>
<span id="cb107-610"><a href="#cb107-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-611"><a href="#cb107-611" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-032}</span></span>
<span id="cb107-612"><a href="#cb107-612" aria-hidden="true" tabindex="-1"></a>lrn_xgboost_tuned <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.xgboost"</span>)</span>
<span id="cb107-613"><a href="#cb107-613" aria-hidden="true" tabindex="-1"></a>lrn_xgboost_tuned<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(</span>
<span id="cb107-614"><a href="#cb107-614" aria-hidden="true" tabindex="-1"></a>  <span class="at">.values =</span> instance<span class="sc">$</span>result_learner_param_vals)</span>
<span id="cb107-615"><a href="#cb107-615" aria-hidden="true" tabindex="-1"></a>generalization <span class="ot">=</span> lrn_xgboost_tuned<span class="sc">$</span><span class="fu">train</span>(tsk_moons_train)<span class="sc">$</span></span>
<span id="cb107-616"><a href="#cb107-616" aria-hidden="true" tabindex="-1"></a>  <span class="fu">predict</span>(tsk_moons_test)<span class="sc">$</span><span class="fu">score</span>()</span>
<span id="cb107-617"><a href="#cb107-617" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-618"><a href="#cb107-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-619"><a href="#cb107-619" aria-hidden="true" tabindex="-1"></a>Now we can compare these three values:</span>
<span id="cb107-620"><a href="#cb107-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-621"><a href="#cb107-621" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-033}</span></span>
<span id="cb107-622"><a href="#cb107-622" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">c</span>(<span class="at">true_generalization =</span> <span class="fu">as.numeric</span>(generalization),</span>
<span id="cb107-623"><a href="#cb107-623" aria-hidden="true" tabindex="-1"></a>  <span class="at">without_nested_resampling =</span> <span class="fu">as.numeric</span>(insample),</span>
<span id="cb107-624"><a href="#cb107-624" aria-hidden="true" tabindex="-1"></a>  <span class="at">with_nested_resampling =</span> <span class="fu">as.numeric</span>(outsample)), <span class="dv">2</span>)</span>
<span id="cb107-625"><a href="#cb107-625" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-626"><a href="#cb107-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-627"><a href="#cb107-627" aria-hidden="true" tabindex="-1"></a>We find that the performance estimate from unnested tuning optimistically overestimates the true performance (which could indicate 'meta-overfitting' to the specific inner holdout-splits), while the outer estimate from nested resampling works much better.</span>
<span id="cb107-628"><a href="#cb107-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-629"><a href="#cb107-629" aria-hidden="true" tabindex="-1"></a><span class="fu">## More Advanced Search Spaces {#sec-defining-search-spaces}</span></span>
<span id="cb107-630"><a href="#cb107-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-631"><a href="#cb107-631" aria-hidden="true" tabindex="-1"></a>Up until now, we have only considered tuning simple search spaces limited to a few numeric hyperparameters.</span>
<span id="cb107-632"><a href="#cb107-632" aria-hidden="true" tabindex="-1"></a>In this section, we will first look at how to tune different scalar parameter classes with <span class="in">`r ref("to_tune()")`</span>, and then how to define your own search space with <span class="in">`r ref("ParamSet")`</span> to create more advanced search spaces that may include tuning over vectors, transformations, and handling parameter dependencies.</span>
<span id="cb107-633"><a href="#cb107-633" aria-hidden="true" tabindex="-1"></a>Finally, we will consider how to access a database of standardized search spaces from the literature.</span>
<span id="cb107-634"><a href="#cb107-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-635"><a href="#cb107-635" aria-hidden="true" tabindex="-1"></a><span class="fu">### Scalar Parameter Tuning</span></span>
<span id="cb107-636"><a href="#cb107-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-637"><a href="#cb107-637" aria-hidden="true" tabindex="-1"></a>The <span class="in">`r ref("to_tune()")`</span> function can be used to tune parameters of any class, whether they are scalar or vectors.</span>
<span id="cb107-638"><a href="#cb107-638" aria-hidden="true" tabindex="-1"></a>To best understand this function, we will consider what is happening behind the scenes.</span>
<span id="cb107-639"><a href="#cb107-639" aria-hidden="true" tabindex="-1"></a>When <span class="in">`to_tune()`</span> is used in a learner, implicitly a <span class="in">`r ref("ParamSet")`</span> is created just for the tuning search space:</span>
<span id="cb107-640"><a href="#cb107-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-641"><a href="#cb107-641" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-034}</span></span>
<span id="cb107-642"><a href="#cb107-642" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-643"><a href="#cb107-643" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb107-644"><a href="#cb107-644" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb107-645"><a href="#cb107-645" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb107-646"><a href="#cb107-646" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb107-647"><a href="#cb107-647" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-648"><a href="#cb107-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-649"><a href="#cb107-649" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb107-650"><a href="#cb107-650" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-651"><a href="#cb107-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-652"><a href="#cb107-652" aria-hidden="true" tabindex="-1"></a>Recall from @sec-param-set, that the <span class="in">`class`</span> field corresponds to the hyperparameter class as defined in <span class="in">`r ref_pkg("paradox")`</span>.</span>
<span id="cb107-653"><a href="#cb107-653" aria-hidden="true" tabindex="-1"></a>In this example, we can see that <span class="in">`gamma`</span> hyperparameter has class <span class="in">`ParamDbl`</span>, with <span class="in">`lower = 0.1`</span> and <span class="in">`upper = 1`</span>, which was automatically created by <span class="in">`to_tune()`</span> as we passed two numeric values to this function.</span>
<span id="cb107-654"><a href="#cb107-654" aria-hidden="true" tabindex="-1"></a>If we wanted to tune over a non-numeric hyperparameter, we can still use <span class="in">`to_tune()`</span>, which will infer the correct class to construct in the resulting parameter set.</span>
<span id="cb107-655"><a href="#cb107-655" aria-hidden="true" tabindex="-1"></a>For example, say we wanted to tune the numeric <span class="in">`cost`</span>, factor <span class="in">`kernel`</span>, and logical <span class="in">`scale`</span> hyperparameter in our SVM:</span>
<span id="cb107-656"><a href="#cb107-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-657"><a href="#cb107-657" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-035}</span></span>
<span id="cb107-658"><a href="#cb107-658" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-659"><a href="#cb107-659" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb107-660"><a href="#cb107-660" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="st">"radial"</span>, <span class="st">"linear"</span>)),</span>
<span id="cb107-661"><a href="#cb107-661" aria-hidden="true" tabindex="-1"></a>  <span class="at">shrinking =</span> <span class="fu">to_tune</span>(),</span>
<span id="cb107-662"><a href="#cb107-662" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb107-663"><a href="#cb107-663" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-664"><a href="#cb107-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-665"><a href="#cb107-665" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb107-666"><a href="#cb107-666" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-667"><a href="#cb107-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-668"><a href="#cb107-668" aria-hidden="true" tabindex="-1"></a>Here the <span class="in">`kernel`</span> hyperparameter is a factor, so we simply pass in a vector corresponding to the levels we want to tune over.</span>
<span id="cb107-669"><a href="#cb107-669" aria-hidden="true" tabindex="-1"></a>The <span class="in">`shrinking`</span> hyperparameter is a logical, there are only two possible values this could take so we do not need to pass anything to <span class="in">`to_tune()`</span>, it will automatically recognize this is a logical from <span class="in">`learner$param_set`</span> and passes this detail to <span class="in">`learner$param_set$search_space()`</span>.</span>
<span id="cb107-670"><a href="#cb107-670" aria-hidden="true" tabindex="-1"></a>Similarly, for factor parameters, we could also use <span class="in">`to_tune()`</span> without any arguments if we want to tune over all possible values.</span>
<span id="cb107-671"><a href="#cb107-671" aria-hidden="true" tabindex="-1"></a>Finally, we can use <span class="in">`to_tune()`</span> to treat numeric parameters as factors if we want to discretize them over a small subset of possible values, for example, if we wanted to find the optimal number of trees in a random forest we might only consider three scenarios: 100, 200, or 400 trees:</span>
<span id="cb107-672"><a href="#cb107-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-673"><a href="#cb107-673" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-036, eval = FALSE}</span></span>
<span id="cb107-674"><a href="#cb107-674" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.ranger"</span>, <span class="at">num.trees =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">400</span>)))</span>
<span id="cb107-675"><a href="#cb107-675" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-676"><a href="#cb107-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-677"><a href="#cb107-677" aria-hidden="true" tabindex="-1"></a>Before we look at tuning over vectors, we must first learn how to create parameter sets from scratch.</span>
<span id="cb107-678"><a href="#cb107-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-679"><a href="#cb107-679" aria-hidden="true" tabindex="-1"></a>:::{.callout-warning}</span>
<span id="cb107-680"><a href="#cb107-680" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ordered Hyperparameters</span></span>
<span id="cb107-681"><a href="#cb107-681" aria-hidden="true" tabindex="-1"></a>Treating an integer as a factor for tuning results in "unordered" hyperparameters.</span>
<span id="cb107-682"><a href="#cb107-682" aria-hidden="true" tabindex="-1"></a>Therefore algorithms that make use of ordering information will perform worse when ordering is ignored.</span>
<span id="cb107-683"><a href="#cb107-683" aria-hidden="true" tabindex="-1"></a>For these algorithms, it would make more sense to define a <span class="in">`ParamDbl`</span> or <span class="in">`ParamInt`</span> (@sec-tune-ps) with a custom transformation (@sec-tune-trafo).</span>
<span id="cb107-684"><a href="#cb107-684" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb107-685"><a href="#cb107-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-686"><a href="#cb107-686" aria-hidden="true" tabindex="-1"></a><span class="fu">### Defining Search Spaces with `ps` {#sec-tune-ps}</span></span>
<span id="cb107-687"><a href="#cb107-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-688"><a href="#cb107-688" aria-hidden="true" tabindex="-1"></a>As we have seen, <span class="in">`r ref("to_tune()")`</span> is a helper function that creates a parameter set that will go on to be used by <span class="in">`r ref("tune()")`</span>, <span class="in">`r ref("ti()")`</span>, or <span class="in">`r ref("auto_tuner()")`</span> during the tuning process.</span>
<span id="cb107-689"><a href="#cb107-689" aria-hidden="true" tabindex="-1"></a>However, there will be use cases where you will need to create a parameter set manually using <span class="in">`r ref("ps()")`</span>.</span>
<span id="cb107-690"><a href="#cb107-690" aria-hidden="true" tabindex="-1"></a>This function takes named arguments of class <span class="in">`r ref("Domain")`</span>, which can be created using the sugar functions in @tbl-paradox-define.</span>
<span id="cb107-691"><a href="#cb107-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-692"><a href="#cb107-692" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Constructor      <span class="pp">|</span> Description                          <span class="pp">|</span> Underlying Class <span class="pp">|</span></span>
<span id="cb107-693"><a href="#cb107-693" aria-hidden="true" tabindex="-1"></a><span class="pp">|------------------|--------------------------------------|------------------|</span></span>
<span id="cb107-694"><a href="#cb107-694" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("p_dbl")`</span> <span class="pp">|</span> Real valued parameter ("double")     <span class="pp">|</span> <span class="in">`ParamDbl`</span>       <span class="pp">|</span></span>
<span id="cb107-695"><a href="#cb107-695" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("p_int")`</span> <span class="pp">|</span> Integer parameter                    <span class="pp">|</span> <span class="in">`ParamInt`</span>       <span class="pp">|</span></span>
<span id="cb107-696"><a href="#cb107-696" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("p_fct")`</span> <span class="pp">|</span> Discrete valued parameter ("factor") <span class="pp">|</span> <span class="in">`ParamFct`</span>       <span class="pp">|</span></span>
<span id="cb107-697"><a href="#cb107-697" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("p_lgl")`</span> <span class="pp">|</span> Logical / Boolean parameter          <span class="pp">|</span> <span class="in">`ParamLgl`</span>       <span class="pp">|</span></span>
<span id="cb107-698"><a href="#cb107-698" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("p_uty")`</span> <span class="pp">|</span> Untyped parameter                    <span class="pp">|</span> <span class="in">`ParamUty`</span>       <span class="pp">|</span></span>
<span id="cb107-699"><a href="#cb107-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-700"><a href="#cb107-700" aria-hidden="true" tabindex="-1"></a>: <span class="in">`r ref("Domain")`</span> Constructors and their resulting <span class="in">`r ref("Domain")`</span>. {#tbl-paradox-define}</span>
<span id="cb107-701"><a href="#cb107-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-702"><a href="#cb107-702" aria-hidden="true" tabindex="-1"></a>As a simple example, let us look at how to create a search space to tune <span class="in">`cost`</span> and <span class="in">`gamma`</span> again:</span>
<span id="cb107-703"><a href="#cb107-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-704"><a href="#cb107-704" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-037}</span></span>
<span id="cb107-705"><a href="#cb107-705" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb107-706"><a href="#cb107-706" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">1e-1</span>, <span class="at">upper =</span> <span class="fl">1e5</span>),</span>
<span id="cb107-707"><a href="#cb107-707" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">p_fct</span>(<span class="fu">c</span>(<span class="st">"radial"</span>, <span class="st">"linear"</span>)),</span>
<span id="cb107-708"><a href="#cb107-708" aria-hidden="true" tabindex="-1"></a>  <span class="at">shrinking =</span> <span class="fu">p_lgl</span>()</span>
<span id="cb107-709"><a href="#cb107-709" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-710"><a href="#cb107-710" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-711"><a href="#cb107-711" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-712"><a href="#cb107-712" aria-hidden="true" tabindex="-1"></a>This search space would then be passed to the <span class="in">`search_space`</span> argument in <span class="in">`auto_tuner()`</span>:</span>
<span id="cb107-713"><a href="#cb107-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-714"><a href="#cb107-714" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-038}</span></span>
<span id="cb107-715"><a href="#cb107-715" aria-hidden="true" tabindex="-1"></a><span class="fu">ti</span>(tsk_sonar, <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">type =</span> <span class="st">"C-classification"</span>), rsmp_cv3,</span>
<span id="cb107-716"><a href="#cb107-716" aria-hidden="true" tabindex="-1"></a>  msr_ce, <span class="fu">trm</span>(<span class="st">"none"</span>), <span class="at">search_space =</span> search_space)</span>
<span id="cb107-717"><a href="#cb107-717" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-718"><a href="#cb107-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-719"><a href="#cb107-719" aria-hidden="true" tabindex="-1"></a>:::{.callout-warning}</span>
<span id="cb107-720"><a href="#cb107-720" aria-hidden="true" tabindex="-1"></a><span class="fu">## Bounded Search Spaces</span></span>
<span id="cb107-721"><a href="#cb107-721" aria-hidden="true" tabindex="-1"></a>When manually creating search spaces, make sure all numeric hyperparameters in your search space are bounded, e.g., if you are trying to tune a hyperparameter that could take any value in $(-\infty, \infty)$ then the tuning process will throw an error for nearly all tuners if you do not pass lower and upper limits to <span class="in">`p_dbl()`</span> or <span class="in">`p_int()`</span>.</span>
<span id="cb107-722"><a href="#cb107-722" aria-hidden="true" tabindex="-1"></a>You can use <span class="in">`$is_bounded`</span> on the constructed <span class="in">`r ref("ParamSet")`</span> if you are unsure:</span>
<span id="cb107-723"><a href="#cb107-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-724"><a href="#cb107-724" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-039}</span></span>
<span id="cb107-725"><a href="#cb107-725" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">0.1</span>, <span class="at">upper =</span> <span class="dv">1</span>))<span class="sc">$</span>is_bounded</span>
<span id="cb107-726"><a href="#cb107-726" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">0.1</span>, <span class="at">upper =</span> <span class="cn">Inf</span>))<span class="sc">$</span>is_bounded</span>
<span id="cb107-727"><a href="#cb107-727" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-728"><a href="#cb107-728" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb107-729"><a href="#cb107-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-730"><a href="#cb107-730" aria-hidden="true" tabindex="-1"></a><span class="fu">### Transformations and Tuning Over Vectors {#sec-tune-trafo}</span></span>
<span id="cb107-731"><a href="#cb107-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-732"><a href="#cb107-732" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb107-733"><a href="#cb107-733" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-734"><a href="#cb107-734" aria-hidden="true" tabindex="-1"></a>In @sec-logarithmic-transformations we saw how to quickly apply log transformations with <span class="in">`r ref("to_tune()")`</span>.</span>
<span id="cb107-735"><a href="#cb107-735" aria-hidden="true" tabindex="-1"></a>As you now know, <span class="in">`to_tune()`</span> is just a wrapper that creates <span class="in">`r ref("ParamSet")`</span> objects, so let us look at what is taking place when we set <span class="in">`logscale = TRUE`</span>:</span>
<span id="cb107-736"><a href="#cb107-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-737"><a href="#cb107-737" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-040}</span></span>
<span id="cb107-738"><a href="#cb107-738" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">cost =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>))<span class="sc">$</span></span>
<span id="cb107-739"><a href="#cb107-739" aria-hidden="true" tabindex="-1"></a>  param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb107-740"><a href="#cb107-740" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-741"><a href="#cb107-741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-742"><a href="#cb107-742" aria-hidden="true" tabindex="-1"></a>Notice that now the <span class="in">`lower`</span> and <span class="in">`upper`</span> fields correspond to the transformed bounds, i.e. $<span class="co">[</span><span class="ot">\log(1e-5), \log(1e5)</span><span class="co">]</span>$.</span>
<span id="cb107-743"><a href="#cb107-743" aria-hidden="true" tabindex="-1"></a>To manually create the same transformation, we can pass the transformation to the <span class="in">`trafo`</span> argument in <span class="in">`p_dbl()`</span> and set the bounds:</span>
<span id="cb107-744"><a href="#cb107-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-745"><a href="#cb107-745" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-041}</span></span>
<span id="cb107-746"><a href="#cb107-746" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="fu">log</span>(<span class="fl">1e-5</span>), <span class="fu">log</span>(<span class="fl">1e5</span>),</span>
<span id="cb107-747"><a href="#cb107-747" aria-hidden="true" tabindex="-1"></a>  <span class="at">trafo =</span> <span class="cf">function</span>(x) <span class="fu">exp</span>(x))) <span class="co"># alternatively: 'trafo = exp'</span></span>
<span id="cb107-748"><a href="#cb107-748" aria-hidden="true" tabindex="-1"></a>search_space</span>
<span id="cb107-749"><a href="#cb107-749" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-750"><a href="#cb107-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-751"><a href="#cb107-751" aria-hidden="true" tabindex="-1"></a>We can confirm it is correctly set by making use of the <span class="in">`$trafo()`</span> method, which takes a named list and applies the specified transformations</span>
<span id="cb107-752"><a href="#cb107-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-753"><a href="#cb107-753" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-042}</span></span>
<span id="cb107-754"><a href="#cb107-754" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>))</span>
<span id="cb107-755"><a href="#cb107-755" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-756"><a href="#cb107-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-757"><a href="#cb107-757" aria-hidden="true" tabindex="-1"></a>Where transformations become the most powerful is in the ability to pass arbitrary functions that can act on single parameters or even the entire parameter set.</span>
<span id="cb107-758"><a href="#cb107-758" aria-hidden="true" tabindex="-1"></a>As an example, consider a simple transformation to add '2' to our range:</span>
<span id="cb107-759"><a href="#cb107-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-760"><a href="#cb107-760" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-043}</span></span>
<span id="cb107-761"><a href="#cb107-761" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) x <span class="sc">+</span> <span class="dv">2</span>))</span>
<span id="cb107-762"><a href="#cb107-762" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>))</span>
<span id="cb107-763"><a href="#cb107-763" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-764"><a href="#cb107-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-765"><a href="#cb107-765" aria-hidden="true" tabindex="-1"></a>Simple transformations such as this can even be added directly to a learner by passing a <span class="in">`Param`</span> object to <span class="in">`to_tune()`</span>:</span>
<span id="cb107-766"><a href="#cb107-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-767"><a href="#cb107-767" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-044, eval = FALSE}</span></span>
<span id="cb107-768"><a href="#cb107-768" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-769"><a href="#cb107-769" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost =</span> <span class="fu">to_tune</span>(<span class="fu">p_dbl</span>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) x <span class="sc">+</span> <span class="dv">2</span>)))</span>
<span id="cb107-770"><a href="#cb107-770" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-771"><a href="#cb107-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-772"><a href="#cb107-772" aria-hidden="true" tabindex="-1"></a>More complex transformations that require multiple arguments should be passed to the <span class="in">`.extra_trafo`</span> parameter in <span class="in">`ps()`</span>.</span>
<span id="cb107-773"><a href="#cb107-773" aria-hidden="true" tabindex="-1"></a><span class="in">`.extra_trafo`</span> takes a function with parameters <span class="in">`x`</span> and <span class="in">`param_set`</span> where, during tuning, <span class="in">`x`</span> will be a list containing the configuration being tested, and <span class="in">`param_set`</span> is the whole parameter set.</span>
<span id="cb107-774"><a href="#cb107-774" aria-hidden="true" tabindex="-1"></a>Below we first exponentiate the value of <span class="in">`cost`</span> and then add '2' if the <span class="in">`kernel`</span> is <span class="in">`"polynomial"`</span>.</span>
<span id="cb107-775"><a href="#cb107-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-776"><a href="#cb107-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-777"><a href="#cb107-777" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-045}</span></span>
<span id="cb107-778"><a href="#cb107-778" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb107-779"><a href="#cb107-779" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) <span class="fu">exp</span>(x)),</span>
<span id="cb107-780"><a href="#cb107-780" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">p_fct</span>(<span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)),</span>
<span id="cb107-781"><a href="#cb107-781" aria-hidden="true" tabindex="-1"></a>  <span class="at">.extra_trafo =</span> <span class="cf">function</span>(x, param_set) {</span>
<span id="cb107-782"><a href="#cb107-782" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x<span class="sc">$</span>kernel <span class="sc">==</span> <span class="st">"polynomial"</span>) {</span>
<span id="cb107-783"><a href="#cb107-783" aria-hidden="true" tabindex="-1"></a>      x<span class="sc">$</span>cost <span class="ot">=</span> x<span class="sc">$</span>cost <span class="sc">+</span> <span class="dv">2</span></span>
<span id="cb107-784"><a href="#cb107-784" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb107-785"><a href="#cb107-785" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb107-786"><a href="#cb107-786" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb107-787"><a href="#cb107-787" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-788"><a href="#cb107-788" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>, <span class="at">kernel =</span> <span class="st">"radial"</span>))</span>
<span id="cb107-789"><a href="#cb107-789" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>, <span class="at">kernel =</span> <span class="st">"polynomial"</span>))</span>
<span id="cb107-790"><a href="#cb107-790" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-791"><a href="#cb107-791" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-792"><a href="#cb107-792" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Vector transformations {.unnumbered .unlisted}</span></span>
<span id="cb107-793"><a href="#cb107-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-794"><a href="#cb107-794" aria-hidden="true" tabindex="-1"></a>Any function can be passed to <span class="in">`trafo`</span> and <span class="in">`.extra_trafo`</span>, which enables tuning of 'untyped' parameters of class <span class="in">`ParamUty`</span> that could be vectors, functions, or any non-atomic class.</span>
<span id="cb107-795"><a href="#cb107-795" aria-hidden="true" tabindex="-1"></a>By example, consider the <span class="in">`class.weights`</span> parameter of the SVM, which takes a named vector of class weights with one entry for each target class.</span>
<span id="cb107-796"><a href="#cb107-796" aria-hidden="true" tabindex="-1"></a>To tune this parameter we could tune a scalar and then transform this to a vector.</span>
<span id="cb107-797"><a href="#cb107-797" aria-hidden="true" tabindex="-1"></a>The code below would result in a value, <span class="in">`x`</span>, between <span class="in">`0.1`</span> and <span class="in">`0.9`</span> being sampled, the result is then transformed to (<span class="in">`x`</span>, <span class="in">`1 - x`</span>) and is then passed to the <span class="in">`Learner`</span>.</span>
<span id="cb107-798"><a href="#cb107-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-799"><a href="#cb107-799" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-046}</span></span>
<span id="cb107-800"><a href="#cb107-800" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb107-801"><a href="#cb107-801" aria-hidden="true" tabindex="-1"></a>  <span class="at">class.weights =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">0.1</span>, <span class="at">upper =</span> <span class="fl">0.9</span>,</span>
<span id="cb107-802"><a href="#cb107-802" aria-hidden="true" tabindex="-1"></a>    <span class="at">trafo =</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="at">M =</span> x, <span class="at">R =</span> <span class="dv">1</span> <span class="sc">-</span> x))</span>
<span id="cb107-803"><a href="#cb107-803" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-804"><a href="#cb107-804" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-805"><a href="#cb107-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-806"><a href="#cb107-806" aria-hidden="true" tabindex="-1"></a>In other cases, we may need to tune two or more 'pseudoparameters' that do not exist in our learner's parameter set but are required to tune a vector parameter.</span>
<span id="cb107-807"><a href="#cb107-807" aria-hidden="true" tabindex="-1"></a>For example, say we want to tune the architecture of a <span class="in">`r index('neural network')`</span>, in which we need to decide the number of layers and the number of nodes in each layer, this is the case in the <span class="in">`num_nodes`</span> hyperparameter in <span class="in">`lrn("surv.coxtime")`</span> (we use this learner as it provides a useful template for this sort of transformation, interested readers can read about survival analysis in @sec-survival).</span>
<span id="cb107-808"><a href="#cb107-808" aria-hidden="true" tabindex="-1"></a>In this case, the learner expects a vector where each element of the vector corresponds to the number of nodes in a layer and the length of the vector is the number of layers.</span>
<span id="cb107-809"><a href="#cb107-809" aria-hidden="true" tabindex="-1"></a>We could then tune this as follows:</span>
<span id="cb107-810"><a href="#cb107-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-811"><a href="#cb107-811" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-047}</span></span>
<span id="cb107-812"><a href="#cb107-812" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb107-813"><a href="#cb107-813" aria-hidden="true" tabindex="-1"></a>  <span class="at">num_layers =</span> <span class="fu">p_int</span>(<span class="at">lower =</span> <span class="dv">1</span>, <span class="at">upper =</span> <span class="dv">20</span>),</span>
<span id="cb107-814"><a href="#cb107-814" aria-hidden="true" tabindex="-1"></a>  <span class="at">num_nodes_per_layer =</span> <span class="fu">p_int</span>(<span class="dv">4</span>, <span class="dv">64</span>),</span>
<span id="cb107-815"><a href="#cb107-815" aria-hidden="true" tabindex="-1"></a>  <span class="at">.extra_trafo =</span> <span class="cf">function</span>(x, param_set) {</span>
<span id="cb107-816"><a href="#cb107-816" aria-hidden="true" tabindex="-1"></a>    x<span class="sc">$</span>num_nodes <span class="ot">=</span> <span class="fu">rep</span>(x<span class="sc">$</span>num_nodes_per_layer, x<span class="sc">$</span>num_layers)</span>
<span id="cb107-817"><a href="#cb107-817" aria-hidden="true" tabindex="-1"></a>    x<span class="sc">$</span>num_layers <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb107-818"><a href="#cb107-818" aria-hidden="true" tabindex="-1"></a>    x<span class="sc">$</span>num_nodes_per_layer <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb107-819"><a href="#cb107-819" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb107-820"><a href="#cb107-820" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb107-821"><a href="#cb107-821" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-822"><a href="#cb107-822" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-823"><a href="#cb107-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-824"><a href="#cb107-824" aria-hidden="true" tabindex="-1"></a>Here we are tuning the pseudo-parameter <span class="in">`num_layers`</span> between <span class="in">`1`</span> and <span class="in">`20`</span>, then tuning the pseudo-parameter <span class="in">`num_nodes_per_layer`</span> between <span class="in">`4`</span> and <span class="in">`64`</span>, then combining these into a vector called <span class="in">`num_nodes`</span> (the real hyperparameter) and removing the pseudo-parameters.</span>
<span id="cb107-825"><a href="#cb107-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-826"><a href="#cb107-826" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-048}</span></span>
<span id="cb107-827"><a href="#cb107-827" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">num_layers =</span> <span class="dv">4</span>, <span class="at">num_nodes_per_layer =</span> <span class="dv">12</span>))</span>
<span id="cb107-828"><a href="#cb107-828" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-829"><a href="#cb107-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-830"><a href="#cb107-830" aria-hidden="true" tabindex="-1"></a>Even though this transformation looks complex, it only affects one of the hyperparameters (and does not need access to others), so we could include it in the learner using <span class="in">`to_tune()`</span> by passing the whole <span class="in">`ParamSet`</span> object:</span>
<span id="cb107-831"><a href="#cb107-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-832"><a href="#cb107-832" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-049}</span></span>
<span id="cb107-833"><a href="#cb107-833" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"surv.coxtime"</span>)</span>
<span id="cb107-834"><a href="#cb107-834" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(<span class="at">num_nodes =</span> <span class="fu">to_tune</span>(search_space))</span>
<span id="cb107-835"><a href="#cb107-835" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb107-836"><a href="#cb107-836" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-837"><a href="#cb107-837" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-838"><a href="#cb107-838" aria-hidden="true" tabindex="-1"></a><span class="fu">### Hyperparameter Dependencies {#sec-optimization-depends}</span></span>
<span id="cb107-839"><a href="#cb107-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-840"><a href="#cb107-840" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb107-841"><a href="#cb107-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-842"><a href="#cb107-842" aria-hidden="true" tabindex="-1"></a>Hyperparameter dependencies occur when a hyperparameter should only be set if another hyperparameter has a particular value.</span>
<span id="cb107-843"><a href="#cb107-843" aria-hidden="true" tabindex="-1"></a>For example, the <span class="in">`degree`</span> parameter in SVM is only valid when <span class="in">`kernel`</span> is <span class="in">`"polynomial"`</span>.</span>
<span id="cb107-844"><a href="#cb107-844" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`r ref("ps()")`</span> function, we specify this using the <span class="in">`depends`</span> argument, which takes a named argument of the form <span class="in">`&lt;param&gt; == value`</span> or <span class="in">`&lt;param&gt; %in% &lt;vector&gt;`</span>:</span>
<span id="cb107-845"><a href="#cb107-845" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-846"><a href="#cb107-846" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-050}</span></span>
<span id="cb107-847"><a href="#cb107-847" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(</span>
<span id="cb107-848"><a href="#cb107-848" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">p_fct</span>(<span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)),</span>
<span id="cb107-849"><a href="#cb107-849" aria-hidden="true" tabindex="-1"></a>  <span class="at">degree =</span> <span class="fu">p_int</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="at">depends =</span> (kernel <span class="sc">==</span> <span class="st">"polynomial"</span>)),</span>
<span id="cb107-850"><a href="#cb107-850" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">p_dbl</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>,</span>
<span id="cb107-851"><a href="#cb107-851" aria-hidden="true" tabindex="-1"></a>    <span class="at">depends =</span> (kernel <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)))</span>
<span id="cb107-852"><a href="#cb107-852" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-853"><a href="#cb107-853" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-854"><a href="#cb107-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-855"><a href="#cb107-855" aria-hidden="true" tabindex="-1"></a>Above we have said that <span class="in">`degree`</span> should only be set if <span class="in">`kernel`</span> is (<span class="in">`==`</span>) <span class="in">`"polynomial"`</span>, and <span class="in">`gamma`</span> should only be set if <span class="in">`kernel`</span> is one of (<span class="in">`%in%`</span>) <span class="in">`"polynomial"`</span> or  <span class="in">`"radial"`</span>.</span>
<span id="cb107-856"><a href="#cb107-856" aria-hidden="true" tabindex="-1"></a>In practice, some underlying implementations ignore unused parameters and others throw errors, either way, this is problematic during tuning if, for example, we were wasting time trying to tune <span class="in">`degree`</span> when the kernel was not polynomial.</span>
<span id="cb107-857"><a href="#cb107-857" aria-hidden="true" tabindex="-1"></a>Hence setting the dependency tells the tuning process to tune <span class="in">`degree`</span> if <span class="in">`kernel`</span> is <span class="in">`"polynomial"`</span> and to ignore it otherwise.</span>
<span id="cb107-858"><a href="#cb107-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-859"><a href="#cb107-859" aria-hidden="true" tabindex="-1"></a>Dependencies can also be passed straight into a learner using <span class="in">`r ref("to_tune()")`</span>:</span>
<span id="cb107-860"><a href="#cb107-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-861"><a href="#cb107-861" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-051}</span></span>
<span id="cb107-862"><a href="#cb107-862" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb107-863"><a href="#cb107-863" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)),</span>
<span id="cb107-864"><a href="#cb107-864" aria-hidden="true" tabindex="-1"></a>  <span class="at">degree =</span> <span class="fu">to_tune</span>(<span class="fu">p_int</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="at">depends =</span> (kernel <span class="sc">==</span> <span class="st">"polynomial"</span>)))</span>
<span id="cb107-865"><a href="#cb107-865" aria-hidden="true" tabindex="-1"></a>)<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb107-866"><a href="#cb107-866" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-867"><a href="#cb107-867" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-868"><a href="#cb107-868" aria-hidden="true" tabindex="-1"></a><span class="fu">### Recommended Search Spaces with `mlr3tuningspaces` {#sec-tuning-spaces}</span></span>
<span id="cb107-869"><a href="#cb107-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-870"><a href="#cb107-870" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb107-871"><a href="#cb107-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-872"><a href="#cb107-872" aria-hidden="true" tabindex="-1"></a>Selected search spaces can require a lot of background knowledge or expertise.</span>
<span id="cb107-873"><a href="#cb107-873" aria-hidden="true" tabindex="-1"></a>The package <span class="in">`r ref_pkg("mlr3tuningspaces")`</span> tries to make HPO more accessible by providing implementations of published search spaces for many popular machine learning algorithms, the hope is that these search spaces are applicable to a wide range of datasets.</span>
<span id="cb107-874"><a href="#cb107-874" aria-hidden="true" tabindex="-1"></a>The search spaces are stored in the dictionary <span class="in">`r ref("mlr_tuning_spaces")`</span>.</span>
<span id="cb107-875"><a href="#cb107-875" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-876"><a href="#cb107-876" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-052,message=FALSE}</span></span>
<span id="cb107-877"><a href="#cb107-877" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3tuningspaces)</span>
<span id="cb107-878"><a href="#cb107-878" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(mlr_tuning_spaces)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, .(key, label)]</span>
<span id="cb107-879"><a href="#cb107-879" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-880"><a href="#cb107-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-881"><a href="#cb107-881" aria-hidden="true" tabindex="-1"></a>The tuning spaces are named according to the scheme <span class="in">`{learner-id}.{tuning-space-id}`</span>.</span>
<span id="cb107-882"><a href="#cb107-882" aria-hidden="true" tabindex="-1"></a>The <span class="in">`default`</span> tuning spaces are published in @hpo_practical, other tuning spaces are part of the random bot experiments <span class="in">`rbv1`</span> and <span class="in">`rbv2`</span> published in @kuehn_2018 and @binder2020.</span>
<span id="cb107-883"><a href="#cb107-883" aria-hidden="true" tabindex="-1"></a>The sugar function <span class="in">`r ref("lts()")`</span> (learner tuning space) is used to retrieve a <span class="in">`r ref("TuningSpace")`</span>.</span>
<span id="cb107-884"><a href="#cb107-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-885"><a href="#cb107-885" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-053}</span></span>
<span id="cb107-886"><a href="#cb107-886" aria-hidden="true" tabindex="-1"></a>lts_rpart <span class="ot">=</span> <span class="fu">lts</span>(<span class="st">"classif.rpart.default"</span>)</span>
<span id="cb107-887"><a href="#cb107-887" aria-hidden="true" tabindex="-1"></a>lts_rpart</span>
<span id="cb107-888"><a href="#cb107-888" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-889"><a href="#cb107-889" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-890"><a href="#cb107-890" aria-hidden="true" tabindex="-1"></a>A tuning space can be passed to <span class="in">`r ref("ti()")`</span> or <span class="in">`r ref("auto_tuner()")`</span> as the <span class="in">`search_space`</span>.</span>
<span id="cb107-891"><a href="#cb107-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-892"><a href="#cb107-892" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-054}</span></span>
<span id="cb107-893"><a href="#cb107-893" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">ti</span>(</span>
<span id="cb107-894"><a href="#cb107-894" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb107-895"><a href="#cb107-895" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb107-896"><a href="#cb107-896" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>),</span>
<span id="cb107-897"><a href="#cb107-897" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb107-898"><a href="#cb107-898" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">20</span>),</span>
<span id="cb107-899"><a href="#cb107-899" aria-hidden="true" tabindex="-1"></a>  <span class="at">search_space =</span> lts_rpart</span>
<span id="cb107-900"><a href="#cb107-900" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-901"><a href="#cb107-901" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-902"><a href="#cb107-902" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-903"><a href="#cb107-903" aria-hidden="true" tabindex="-1"></a>Alternatively, as loaded search spaces are just a collection of tune tokens, we could also pass these straight to a learner:</span>
<span id="cb107-904"><a href="#cb107-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-905"><a href="#cb107-905" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-055}</span></span>
<span id="cb107-906"><a href="#cb107-906" aria-hidden="true" tabindex="-1"></a>vals <span class="ot">=</span> lts_rpart<span class="sc">$</span>values</span>
<span id="cb107-907"><a href="#cb107-907" aria-hidden="true" tabindex="-1"></a>vals</span>
<span id="cb107-908"><a href="#cb107-908" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb107-909"><a href="#cb107-909" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(<span class="at">.values =</span> vals)</span>
<span id="cb107-910"><a href="#cb107-910" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set</span>
<span id="cb107-911"><a href="#cb107-911" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-912"><a href="#cb107-912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-913"><a href="#cb107-913" aria-hidden="true" tabindex="-1"></a>Note how we used the <span class="in">`.values`</span> parameter of <span class="in">`$set_values()`</span>, which allows us to safely pass a list to the <span class="in">`ParamSet`</span> without accidentally overwriting any other hyperparameter values (@sec-param-set).</span>
<span id="cb107-914"><a href="#cb107-914" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-915"><a href="#cb107-915" aria-hidden="true" tabindex="-1"></a>We could also apply the default search spaces from @hpo_practical by passing the learner to <span class="in">`r ref("lts()")`</span>:</span>
<span id="cb107-916"><a href="#cb107-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-917"><a href="#cb107-917" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-056}</span></span>
<span id="cb107-918"><a href="#cb107-918" aria-hidden="true" tabindex="-1"></a><span class="fu">lts</span>(<span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>))</span>
<span id="cb107-919"><a href="#cb107-919" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-920"><a href="#cb107-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-921"><a href="#cb107-921" aria-hidden="true" tabindex="-1"></a>Finally, it is possible to overwrite a predefined tuning space in construction, for example, changing the range of the <span class="in">`maxdepth`</span> hyperparameter in a decision tree:</span>
<span id="cb107-922"><a href="#cb107-922" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-923"><a href="#cb107-923" aria-hidden="true" tabindex="-1"></a><span class="in">```{r hyperparameter_optimization-057}</span></span>
<span id="cb107-924"><a href="#cb107-924" aria-hidden="true" tabindex="-1"></a><span class="fu">lts</span>(<span class="st">"classif.rpart.rbv2"</span>, <span class="at">maxdepth =</span> <span class="fu">to_tune</span>(<span class="dv">1</span>, <span class="dv">20</span>))</span>
<span id="cb107-925"><a href="#cb107-925" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb107-926"><a href="#cb107-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-927"><a href="#cb107-927" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb107-928"><a href="#cb107-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-929"><a href="#cb107-929" aria-hidden="true" tabindex="-1"></a>In this chapter, we learned how to optimize a model using tuning instances, about different tuners and terminators, search spaces and transformations, how to make use of convenience methods for quicker implementation in larger experiments, and the importance of nested resampling.</span>
<span id="cb107-930"><a href="#cb107-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-931"><a href="#cb107-931" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Class                                                                               <span class="pp">|</span> Constructor/Function                       <span class="pp">|</span> Fields/Methods                               <span class="pp">|</span></span>
<span id="cb107-932"><a href="#cb107-932" aria-hidden="true" tabindex="-1"></a><span class="pp">|-------------------------------------------------------------------------------------|--------------------------------------------|----------------------------------------------|</span></span>
<span id="cb107-933"><a href="#cb107-933" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("Terminator")`</span>                                                               <span class="pp">|</span> <span class="in">`r ref("trm()")`</span>                           <span class="pp">|</span> -                                            <span class="pp">|</span></span>
<span id="cb107-934"><a href="#cb107-934" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("TuningInstanceBatchSingleCrit")`</span> or <span class="in">`r ref("TuningInstanceBatchMultiCrit")`</span> <span class="pp">|</span> <span class="in">`r ref("ti()")`</span>/<span class="in">`r ref("tune()")`</span>          <span class="pp">|</span> <span class="in">`$result`</span>; <span class="in">`$archive`</span>                        <span class="pp">|</span></span>
<span id="cb107-935"><a href="#cb107-935" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("TunerBatch")`</span>                                                               <span class="pp">|</span> <span class="in">`r ref("tnr()")`</span>                           <span class="pp">|</span> <span class="in">`$optimize()`</span>                                <span class="pp">|</span></span>
<span id="cb107-936"><a href="#cb107-936" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("paradox::TuneToken")`</span>                                                       <span class="pp">|</span> <span class="in">`r ref("to_tune()")`</span>                       <span class="pp">|</span> -                                            <span class="pp">|</span></span>
<span id="cb107-937"><a href="#cb107-937" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("AutoTuner")`</span>                                                                <span class="pp">|</span> <span class="in">`r ref("auto_tuner()")`</span>                    <span class="pp">|</span> <span class="in">`$train()`</span>; <span class="in">`$predict()`</span>; <span class="in">`$tuning_instance`</span> <span class="pp">|</span></span>
<span id="cb107-938"><a href="#cb107-938" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> -                                                                                   <span class="pp">|</span> <span class="in">`r ref("extract_inner_tuning_results()")`</span>  <span class="pp">|</span>                                              <span class="pp">|</span></span>
<span id="cb107-939"><a href="#cb107-939" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> -                                                                                   <span class="pp">|</span> <span class="in">`r ref("extract_inner_tuning_archives()")`</span> <span class="pp">|</span>                                              <span class="pp">|</span></span>
<span id="cb107-940"><a href="#cb107-940" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("paradox::ParamSet")`</span>                                                        <span class="pp">|</span> <span class="in">`r ref("ps()")`</span>                            <span class="pp">|</span> -                                            <span class="pp">|</span></span>
<span id="cb107-941"><a href="#cb107-941" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("TuningSpace")`</span>                                                              <span class="pp">|</span> <span class="in">`r ref("lts()")`</span>                           <span class="pp">|</span> <span class="in">`$values`</span>                                    <span class="pp">|</span></span>
<span id="cb107-942"><a href="#cb107-942" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-943"><a href="#cb107-943" aria-hidden="true" tabindex="-1"></a>: Important classes and functions covered in this chapter with underlying class (if applicable), class constructor or function, and important class fields and methods (if applicable). {#tbl-api-optimization}</span>
<span id="cb107-944"><a href="#cb107-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-945"><a href="#cb107-945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-946"><a href="#cb107-946" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercises</span></span>
<span id="cb107-947"><a href="#cb107-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-948"><a href="#cb107-948" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Tune the <span class="in">`mtry`</span>, <span class="in">`sample.fraction`</span>, and <span class="in">`num.trees`</span> hyperparameters of <span class="in">`lrn("regr.ranger")`</span> on <span class="in">`tsk("mtcars")`</span>.</span>
<span id="cb107-949"><a href="#cb107-949" aria-hidden="true" tabindex="-1"></a>  Use a simple random search with 50 evaluations.</span>
<span id="cb107-950"><a href="#cb107-950" aria-hidden="true" tabindex="-1"></a>  Evaluate with a three-fold CV and the root mean squared error.</span>
<span id="cb107-951"><a href="#cb107-951" aria-hidden="true" tabindex="-1"></a>  Visualize the effects that each hyperparameter has on the performance via simple marginal plots, which plot a single hyperparameter versus the cross-validated MSE.</span>
<span id="cb107-952"><a href="#cb107-952" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Evaluate the performance of the model created in Exercise 1 with nested resampling.</span>
<span id="cb107-953"><a href="#cb107-953" aria-hidden="true" tabindex="-1"></a>  Use a holdout validation for the inner resampling and a three-fold CV for the outer resampling.</span>
<span id="cb107-954"><a href="#cb107-954" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Tune and benchmark an XGBoost model against a logistic regression (without tuning the latter) and determine which has the best Brier score.</span>
<span id="cb107-955"><a href="#cb107-955" aria-hidden="true" tabindex="-1"></a>  Use <span class="in">`mlr3tuningspaces`</span> and nested resampling, try to pick appropriate inner and outer resampling strategies that balance computational efficiency vs. stability of the results.</span>
<span id="cb107-956"><a href="#cb107-956" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>(*) Write a function that implements an iterated random search procedure that drills down on the optimal configuration by applying random search to iteratively smaller search spaces.</span>
<span id="cb107-957"><a href="#cb107-957" aria-hidden="true" tabindex="-1"></a>  Your function should have seven inputs: <span class="in">`task`</span>, <span class="in">`learner`</span>, <span class="in">`search_space`</span>, <span class="in">`resampling`</span>, <span class="in">`measure`</span>, <span class="in">`random_search_stages`</span>, and <span class="in">`random_search_size`</span>.</span>
<span id="cb107-958"><a href="#cb107-958" aria-hidden="true" tabindex="-1"></a>  You should only worry about programming this for fully numeric and bounded search spaces that have no dependencies.</span>
<span id="cb107-959"><a href="#cb107-959" aria-hidden="true" tabindex="-1"></a>  In pseudo-code:</span>
<span id="cb107-960"><a href="#cb107-960" aria-hidden="true" tabindex="-1"></a>    (1) Create a random design of size <span class="in">`random_search_size`</span> from the given search space and evaluate the learner on it.</span>
<span id="cb107-961"><a href="#cb107-961" aria-hidden="true" tabindex="-1"></a>    (2) Identify the best configuration.</span>
<span id="cb107-962"><a href="#cb107-962" aria-hidden="true" tabindex="-1"></a>    (3) Create a smaller search space around this best config, where you define the new range for each parameter as: <span class="in">`new_range[i] = (best_conf[i] - 0.25 * current_range[i], best_conf[i] + 0.25*current_range[i])`</span>.</span>
<span id="cb107-963"><a href="#cb107-963" aria-hidden="true" tabindex="-1"></a>      Ensure that this <span class="in">`new_range`</span> respects the initial bound of the original <span class="in">`search_space`</span> by taking the <span class="in">`max()`</span> of the new and old lower bound, and the <span class="in">`min()`</span> of the new and the old upper bound ("clipping").</span>
<span id="cb107-964"><a href="#cb107-964" aria-hidden="true" tabindex="-1"></a>    (4) Iterate the previous steps <span class="in">`random_search_stages`</span> times and at the end return the best configuration you have ever evaluated.</span>
<span id="cb107-965"><a href="#cb107-965" aria-hidden="true" tabindex="-1"></a>  As a stretch goal, look into <span class="in">`mlr3tuning`</span>'s internal source code and turn your function into an R6 class inheriting from the <span class="in">`TunerBatch`</span> class -- test it out on a learner of your choice.</span>
<span id="cb107-966"><a href="#cb107-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-967"><a href="#cb107-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-968"><a href="#cb107-968" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb107-969"><a href="#cb107-969" aria-hidden="true" tabindex="-1"></a><span class="in">`r citeas(chapter)`</span></span>
<span id="cb107-970"><a href="#cb107-970" aria-hidden="true" tabindex="-1"></a>:::</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
<p>All content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> <br> © Bernd Bischl, Raphael Sonabend, Lars Kotthoff, Michel Lang.</p>
</div>   
    <div class="nav-footer-center">
<p><a href="https://mlr-org.com">Website</a> | <a href="https://github.com/mlr-org/mlr3book">GitHub</a> | <a href="https://mlr-org.com/gallery">Gallery</a> | <a href="https://lmmisld-lmu-stats-slds.srv.mwn.de/mlr_invite/">Mattermost</a></p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter4/hyperparameter_optimization.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter4/hyperparameter_optimization.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>


<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>