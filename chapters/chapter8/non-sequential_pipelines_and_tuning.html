<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>8&nbsp; Non-sequential Pipelines and Tuning – Applied Machine Learning Using mlr3 in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter9/preprocessing.html" rel="next">
<link href="../../chapters/chapter7/sequential_pipelines.html" rel="prev">
<link href="../../Figures/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-0d45b1ff1595a53868627e64e30aef28.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-54b1fec74e0844836633235e285d9714.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><style>html{ scroll-behavior: smooth; }</style>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter7/sequential_pipelines.html">Pipelines and Preprocessing</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Applied Machine Learning Using mlr3 in R</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mlr-org/mlr3book/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../Applied-Machine-Learning-Using-mlr3-in-R.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/introduction_and_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction and Overview</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/data_and_basic_modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data and Basic Modeling</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">Tuning and Feature Selection</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter4/hyperparameter_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter6/feature_selection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Pipelines and Preprocessing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter7/sequential_pipelines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter9/preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Preprocessing</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">Advanced Topics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter10/advanced_technical_aspects_of_mlr3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Advanced Technical Aspects of mlr3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter11/large-scale_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Large-Scale Benchmarking</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter12/model_interpretation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Model Interpretation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter13/beyond_regression_and_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Beyond Regression and Classification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter14/algorithmic_fairness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Algorithmic Fairness</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter15/predsets_valid_inttune.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Predict Sets, Validation and Internal Tuning (+)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter16/advanced_hyperparameter_specification_using_paradox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Advanced Hyperparameter Specification using paradox</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/solutions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Solutions to exercises</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/tasks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Tasks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/overview-tables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Overview Tables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/errata.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Errata</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/session_info.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Session Info</span></span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Table of contents</h2>
   
  <ul>
<li><a href="#selectors-and-parallel-pipelines" id="toc-selectors-and-parallel-pipelines" class="nav-link active" data-scroll-target="#selectors-and-parallel-pipelines"><span class="header-section-number">8.1</span> Selectors and Parallel Pipelines</a></li>
  <li><a href="#sec-pipelines-ppl" id="toc-sec-pipelines-ppl" class="nav-link" data-scroll-target="#sec-pipelines-ppl"><span class="header-section-number">8.2</span> Common Patterns and ppl()</a></li>
  <li>
<a href="#practical-pipelines-by-example" id="toc-practical-pipelines-by-example" class="nav-link" data-scroll-target="#practical-pipelines-by-example"><span class="header-section-number">8.3</span> Practical Pipelines by Example</a>
  <ul class="collapse">
<li><a href="#sec-pipelines-bagging" id="toc-sec-pipelines-bagging" class="nav-link" data-scroll-target="#sec-pipelines-bagging"><span class="header-section-number">8.3.1</span> Bagging with “greplicate” and “subsample”</a></li>
  <li><a href="#sec-pipelines-stack" id="toc-sec-pipelines-stack" class="nav-link" data-scroll-target="#sec-pipelines-stack"><span class="header-section-number">8.3.2</span> Stacking with po(“learner_cv”)</a></li>
  </ul>
</li>
  <li>
<a href="#sec-pipelines-tuning" id="toc-sec-pipelines-tuning" class="nav-link" data-scroll-target="#sec-pipelines-tuning"><span class="header-section-number">8.4</span> Tuning Graphs</a>
  <ul class="collapse">
<li><a href="#sec-pipelines-combined" id="toc-sec-pipelines-combined" class="nav-link" data-scroll-target="#sec-pipelines-combined"><span class="header-section-number">8.4.1</span> Tuning Graph Hyperparameters</a></li>
  <li><a href="#sec-pipelines-branch" id="toc-sec-pipelines-branch" class="nav-link" data-scroll-target="#sec-pipelines-branch"><span class="header-section-number">8.4.2</span> Tuning Alternative Paths with po(“branch”)</a></li>
  <li><a href="#sec-pipelines-proxy" id="toc-sec-pipelines-proxy" class="nav-link" data-scroll-target="#sec-pipelines-proxy"><span class="header-section-number">8.4.3</span> Tuning with po(“proxy”)</a></li>
  <li><a href="#sec-hyperband-example-svm" id="toc-sec-hyperband-example-svm" class="nav-link" data-scroll-target="#sec-hyperband-example-svm"><span class="header-section-number">8.4.4</span> Hyperband with Subsampling</a></li>
  <li><a href="#sec-pipelines-featsel" id="toc-sec-pipelines-featsel" class="nav-link" data-scroll-target="#sec-pipelines-featsel"><span class="header-section-number">8.4.5</span> Feature Selection with Filter Pipelines</a></li>
  </ul>
</li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">8.5</span> Conclusion</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">8.6</span> Exercises</a></li>
  <li><a href="#citation" id="toc-citation" class="nav-link" data-scroll-target="#citation"><span class="header-section-number">8.7</span> Citation</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter8/non-sequential_pipelines_and_tuning.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter8/non-sequential_pipelines_and_tuning.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter7/sequential_pipelines.html">Pipelines and Preprocessing</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></a></li></ol></nav><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-pipelines-nonseq" class="quarto-section-identifier"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><p><strong>Martin Binder</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML)</em></p>
<p><strong>Florian Pfisterer</strong> <br><em>Ludwig-Maximilians-Universität München</em></p>
<p><strong>Marc Becker</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML)</em></p>
<p><strong>Marvin N. Wright</strong> <br><em>Leibniz Institute for Prevention Research and Epidemiology – BIPS, and University of Bremen, and University of Copenhagen</em> <br><br></p>
<p>In <a href="../chapter7/sequential_pipelines.html" class="quarto-xref"><span>Chapter 7</span></a> we looked at simple sequential pipelines that can be built using the <a href="https://mlr3pipelines.mlr-org.com/reference/Graph.html"><code>Graph</code></a> class and a few <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a> objects. In this chapter, we will take this further and look at non-sequential pipelines that can perform more complex operations. We will then look at tuning pipelines by combining methods in <a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a> and <a href="https://mlr3pipelines.mlr-org.com"><code>mlr3pipelines</code></a> and will consider some concrete examples using multi-fidelity tuning (<a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-hyperband" class="quarto-xref"><span>Section 5.3</span></a>) and feature selection (<a href="../chapter6/feature_selection.html" class="quarto-xref"><span>Chapter 6</span></a>).</p>
<p>We saw the power of the <code>%&gt;&gt;%</code>-operator in <a href="../chapter7/sequential_pipelines.html" class="quarto-xref"><span>Chapter 7</span></a> to assemble graphs from combinations of multiple <code>PipeOp</code>s and <code>Learner</code>s. Given a single <code>PipeOp</code> or <a href="https://mlr3.mlr-org.com/reference/Learner.html"><code>Learner</code></a>, the <code>%&gt;&gt;%</code>-operator will arrange these objects into a linear <code>Graph</code> with each <code>PipeOp</code> acting in sequence. However, by using the <a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html"><code>gunion()</code></a> function, we can instead combine multiple <code>PipeOp</code>s, <code>Graph</code>s, or a mixture of both, into a parallel <code>Graph</code>.</p>
<p>In the following example, we create a <code>Graph</code> that centers its inputs (<code>po("scale")</code>) and then copies the centered data to two parallel streams: one replaces the data with columns that indicate whether data is missing (<code>po("missind")</code>), and the other imputes missing data using the median (<code>po("imputemedian")</code>), which we will return to in <a href="../chapter9/preprocessing.html#sec-preprocessing-missing" class="quarto-xref"><span>Section 9.3</span></a>. The outputs of both streams are then combined into a single dataset using <code>po("featureunion")</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3pipelines.mlr-org.com">mlr3pipelines</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"scale"</span>, center <span class="op">=</span> <span class="cn">TRUE</span>, scale <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html">gunion</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>    <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"missind"</span><span class="op">)</span>,</span>
<span>    <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"imputemedian"</span><span class="op">)</span></span>
<span>  <span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"featureunion"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>horizontal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-parallel-plot" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Six boxes where first two are &quot;<INPUT> -> scale&quot;, then &quot;scale&quot; has two arrows to &quot;missind&quot; and &quot;imputemedian&quot; which both have an arrow to &quot;featureunion -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-parallel-plot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-parallel-plot-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Six boxes where first two are &quot;<INPUT> -> scale&quot;, then &quot;scale&quot; has two arrows to &quot;missind&quot; and &quot;imputemedian&quot; which both have an arrow to &quot;featureunion -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-parallel-plot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.1: Simple parallel pipeline plot showing a common data source being scaled then the same data being passed to two <code>PipeOp</code>s in parallel whose outputs are combined and returned to the user.
</figcaption></figure>
</div>
</div>
</div>
<p>When applied to the first three rows of the <code>"pima"</code> task we can see how this imputes missing data and adds a column indicating where values were missing.</p>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_pima_head</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"pima"</span><span class="op">)</span><span class="op">$</span><span class="fu">filter</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">tsk_pima_head</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"diabetes"</span>, <span class="st">"insulin"</span>, <span class="st">"triceps"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   diabetes insulin triceps
1:      pos      NA      35
2:      neg      NA      29
3:      pos      NA      NA</code></pre>
</div>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">result</span> <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_pima_head</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">result</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"diabetes"</span>, <span class="st">"insulin"</span>, <span class="st">"missing_insulin"</span>, <span class="st">"triceps"</span>,</span>
<span>  <span class="st">"missing_triceps"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   diabetes insulin missing_insulin triceps missing_triceps
1:      pos       0         missing       3         present
2:      neg       0         missing      -3         present
3:      pos       0         missing       0         missing</code></pre>
</div>
</div>
<section id="selectors-and-parallel-pipelines" class="level2 page-columns page-full" data-number="8.1"><h2 data-number="8.1" class="anchored" data-anchor-id="selectors-and-parallel-pipelines">
<span class="header-section-number">8.1</span> Selectors and Parallel Pipelines</h2>
<p>It is common in <a href="https://mlr3pipelines.mlr-org.com/reference/Graph.html"><code>Graph</code></a>s for an operation to be applied to a subset of features. In <code>mlr3pipelines</code> this can be achieved in two ways (<a href="#fig-pipelines-select-affect" class="quarto-xref">Figure&nbsp;<span>8.2</span></a>): either by passing the column subset to the <code>affect_columns</code> hyperparameter of a <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a> (assuming it has that hyperparameter), which controls which columns should be affected by the <code>PipeOp</code>; or, one can use the <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_select.html"><code>PipeOpSelect</code></a> operator to create operations in parallel on specified feature subsets, and then unite the result using <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_featureunion.html"><code>PipeOpFeatureUnion</code></a>.</p>
<div class="cell" data-layout-nrow="2">
<div id="fig-pipelines-select-affect" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-select-affect-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-pipelines-select-affect" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-pipelines-select-affect-1" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Top plot shows the sequential pipeline &quot;po(op1, affected_columns: ¬X&quot;) -> po(op2, affected_columns: X&quot;). Bottom plot shows the parallel pipeline that starts with an arrow splitting and then pointing to both  po(&quot;select&quot;, ¬X) and po(&quot;select&quot;, X). These respectively point to po(op1) and po(op2), which then both point to the same po(&quot;featureunion&quot;).">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-pipelines-select-affect-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-28.svg" class="img-fluid figure-img" style="width:70.0%" data-ref-parent="fig-pipelines-select-affect" alt="Top plot shows the sequential pipeline &quot;po(op1, affected_columns: ¬X&quot;) -> po(op2, affected_columns: X&quot;). Bottom plot shows the parallel pipeline that starts with an arrow splitting and then pointing to both  po(&quot;select&quot;, ¬X) and po(&quot;select&quot;, X). These respectively point to po(op1) and po(op2), which then both point to the same po(&quot;featureunion&quot;).">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-pipelines-select-affect-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) The <code>affect_columns</code> hyperparameter can be used to restrict operations to a subset of features. When used, pipelines may still be run in sequence.
</figcaption></figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-pipelines-select-affect" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-pipelines-select-affect-2" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Top plot shows the sequential pipeline &quot;po(op1, affected_columns: ¬X&quot;) -> po(op2, affected_columns: X&quot;). Bottom plot shows the parallel pipeline that starts with an arrow splitting and then pointing to both  po(&quot;select&quot;, ¬X) and po(&quot;select&quot;, X). These respectively point to po(op1) and po(op2), which then both point to the same po(&quot;featureunion&quot;).">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-pipelines-select-affect-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-29.svg" class="img-fluid figure-img" style="width:70.0%" data-ref-parent="fig-pipelines-select-affect" alt="Top plot shows the sequential pipeline &quot;po(op1, affected_columns: ¬X&quot;) -> po(op2, affected_columns: X&quot;). Bottom plot shows the parallel pipeline that starts with an arrow splitting and then pointing to both  po(&quot;select&quot;, ¬X) and po(&quot;select&quot;, X). These respectively point to po(op1) and po(op2), which then both point to the same po(&quot;featureunion&quot;).">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-pipelines-select-affect-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Operating on subsets of tasks using concurrent paths by first splitting the inputs with <code>po("select")</code> and then combining outputs with <code>po("featureunion")</code>.
</figcaption></figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-select-affect-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.2: Two methods of setting up <code>PipeOp</code>s (<code>po(op1)</code> and <code>po(op2)</code>) that operate on complementary features (X and ¬X) of an input task.
</figcaption></figure>
</div>
</div>
<div class="page-columns page-full"><p>Both methods make use of <a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>Selector</code></a>-functions. These are helper functions that indicate to a <code>PipeOp</code> which features it should apply to. <code>Selectors</code> may match column names by regular expressions (<a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_grep()</code></a>), or by column type (<a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_type()</code></a>). <code>Selectors</code> can also be used to join variables (<a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_union()</code></a>), return their set difference (<a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_setdiff()</code></a>), or select the complement of features from another <code>Selector</code> (<a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_invert()</code></a>).</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>Selector</code></span></div></div>
<p>For example, in <a href="../chapter7/sequential_pipelines.html#sec-pipelines-pipeops" class="quarto-xref"><span>Section 7.1</span></a> we applied PCA to the bill length and depth of penguins from <code>tsk("penguins_simple")</code> by first selecting these columns using the <code>Task</code> method <code>$select()</code> and then applying the <code>PipeOp</code>. We can now do this more simply with <code>selector_grep</code>, and could go on to use <code>selector_invert</code> to apply some other <code>PipeOp</code> to other features, below we use <code>po("scale")</code> and make use of the <code>affect_columns</code> hyperparameter:</p>
<div class="cell">
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">sel_bill</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html">selector_grep</a></span><span class="op">(</span><span class="st">"^bill"</span><span class="op">)</span></span>
<span><span class="va">sel_not_bill</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html">selector_invert</a></span><span class="op">(</span><span class="va">sel_bill</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"scale"</span>, affect_columns <span class="op">=</span> <span class="va">sel_not_bill</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span>, affect_columns <span class="op">=</span> <span class="va">sel_bill</span><span class="op">)</span></span>
<span></span>
<span><span class="va">result</span> <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"penguins_simple"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">result</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   species    PC1     PC2 body_mass flipper_length
1:  Adelie -5.015  1.0717   -0.5676        -1.4246
2:  Adelie -4.495 -0.1853   -0.5055        -1.0679
3:  Adelie -3.755  0.4868   -1.1886        -0.4257</code></pre>
</div>
</div>
<p>The biggest advantage of this method is that it creates a very simple, sequential <code>Graph</code>. However, one disadvantage of the <code>affect_columns</code> method is that it is relatively easy to have unexpected results if the ordering of <code>PipeOp</code>s is mixed up. For example, if we had reversed the order of <code>po("pca")</code> and <code>po("scale")</code> above then we would have first created columns <code>"PC1"</code> and <code>"PC2"</code> and then erroneously scaled these, since their names do not start with “bill” and they are therefore matched by <code>sel_not_bill</code>. Creating parallel paths with <code>po("select")</code> can help mitigate such errors by selecting features given by the <code>Selector</code> and creating independent data processing streams with the given feature subset. Below we pass the parallel pipelines to <a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html"><code>gunion()</code></a> as a <code>list</code> to ensure they receive the same input, and then combine the outputs with <code>po("featureunion")</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">po_select_bill</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"select"</span>, id <span class="op">=</span> <span class="st">"s_bill"</span>, selector <span class="op">=</span> <span class="va">sel_bill</span><span class="op">)</span></span>
<span><span class="va">po_select_not_bill</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"select"</span>, id <span class="op">=</span> <span class="st">"s_notbill"</span>,</span>
<span>  selector <span class="op">=</span> <span class="va">sel_not_bill</span><span class="op">)</span></span>
<span></span>
<span><span class="va">path_pca</span> <span class="op">=</span>  <span class="va">po_select_bill</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span><span class="op">)</span></span>
<span><span class="va">path_scale</span> <span class="op">=</span> <span class="va">po_select_not_bill</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"scale"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html">gunion</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">path_pca</span>, <span class="va">path_scale</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"featureunion"</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>horizontal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-pcascale" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Seven boxes where first is &quot;<INPUT>&quot; which points to &quot;s_bill -> pca&quot; and &quot;s_notbill&quot; -> scale&quot;, then both &quot;pca&quot; and &quot;scale&quot; point to &quot;featureunion -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-pcascale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-pcascale-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Seven boxes where first is &quot;<INPUT>&quot; which points to &quot;s_bill -> pca&quot; and &quot;s_notbill&quot; -> scale&quot;, then both &quot;pca&quot; and &quot;scale&quot; point to &quot;featureunion -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-pcascale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.3: Visualization of a <code>Graph</code> where features are split into two paths, one with PCA and one with scaling, then combined and returned.
</figcaption></figure>
</div>
</div>
</div>
<p>The <code>po("select")</code> method also has the significant advantage that it allows the same set of features to be used in multiple operations simultaneously, or to both transform features and keep their untransformed versions (by using <code>po("nop")</code> in one path). <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_nop.html"><code>PipeOpNOP</code></a> performs no operation on its inputs and is thus useful when you only want to perform a transformation on a subset of features and leave the others untouched:</p>
<div class="cell">
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html">gunion</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  <span class="va">po_select_bill</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"scale"</span><span class="op">)</span>,</span>
<span>  <span class="va">po_select_not_bill</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"nop"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"featureunion"</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>horizontal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-selectnop" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Seven boxes where first is &quot;<INPUT>&quot; which points to &quot;s_bill -> scale&quot; and &quot;s_notbill -> nop&quot;, then both &quot;scale&quot; and &quot;nop&quot; point to &quot;featureunion -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-selectnop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-selectnop-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Seven boxes where first is &quot;<INPUT>&quot; which points to &quot;s_bill -> scale&quot; and &quot;s_notbill -> nop&quot;, then both &quot;scale&quot; and &quot;nop&quot; point to &quot;featureunion -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-selectnop-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.4: Visualization of our <code>Graph</code> where features are split into two paths, features that start with ‘bill’ are scaled and the rest are untransformed.
</figcaption></figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"penguins_simple"</span><span class="op">)</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   species bill_depth bill_length body_mass flipper_length
1:  Adelie     0.7796     -0.8947      3750            181
2:  Adelie     0.1194     -0.8216      3800            186
3:  Adelie     0.4241     -0.6753      3250            195</code></pre>
</div>
</div>
</section><section id="sec-pipelines-ppl" class="level2 page-columns page-full" data-number="8.2"><h2 data-number="8.2" class="anchored" data-anchor-id="sec-pipelines-ppl">
<span class="header-section-number">8.2</span> Common Patterns and ppl()</h2>
<div class="page-columns page-full"><p>Now you have the tools to create sequential and non-sequential pipelines, you can create an infinite number of transformations on <a href="https://mlr3.mlr-org.com/reference/Task.html"><code>Task</code></a>, <a href="https://mlr3.mlr-org.com/reference/Learner.html"><code>Learner</code></a>, and <a href="https://mlr3.mlr-org.com/reference/Prediction.html"><code>Prediction</code></a> objects. In <a href="#sec-pipelines-bagging" class="quarto-xref"><span>Section 8.3.1</span></a> and <a href="#sec-pipelines-stack" class="quarto-xref"><span>Section 8.3.2</span></a> we will work through two examples to demonstrate how you can make complex and powerful graphs using the methods and classes we have already looked at. However, many common problems in ML can be well solved by the same pipelines, and so to make your life easier we have implemented and saved these pipelines in the <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_graphs.html"><code>mlr_graphs</code></a> dictionary; pipelines in the dictionary can be accessed with the <a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html"><code>ppl()</code></a> sugar function.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl()</a></code></span></div></div>
<p>At the time of writing, this dictionary includes seven <a href="https://mlr3pipelines.mlr-org.com/reference/Graph.html"><code>Graph</code></a>s (required arguments included below):</p>
<ul>
<li>
<code>ppl("bagging", graph)</code>: In <code>mlr3pipelines</code>, bagging is the process of running a <code>graph</code> multiple times on different data samples and then averaging the results. This is discussed in detail in <a href="#sec-pipelines-bagging" class="quarto-xref"><span>Section 8.3.1</span></a>.</li>
<li>
<code>ppl("branch", graphs)</code>: Uses <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_branch.html"><code>PipeOpBranch</code></a> to create different path branches from the given <code>graphs</code> where only one branch is evaluated. This is returned to in more detail in <a href="#sec-pipelines-branch" class="quarto-xref"><span>Section 8.4.2</span></a>.</li>
<li>
<code>ppl("greplicate", graph, n)</code>: Create a <code>Graph</code> that replicates <code>graph</code> (which can also be a single <code>PipeOp</code>) <code>n</code> times. The pipeline avoids ID clashes by adding a suffix to each <code>PipeOp</code>, we will see this pipeline in use in <a href="#sec-pipelines-bagging" class="quarto-xref"><span>Section 8.3.1</span></a>.</li>
<li>
<code>ppl("ovr", graph)</code>: One-versus-rest classification for converting multiclass classification tasks into several binary classification tasks with one task for each class in the original. These tasks are then evaluated by the given <code>graph</code>, which should be a learner (or a pipeline containing a learner that emits a prediction). The predictions made on the binary tasks are combined into the multiclass prediction needed for the original task.</li>
<li>
<code>ppl("robustify")</code>: Performs common preprocessing steps to make any <code>Task</code> compatible with a given <code>Learner</code>. This pipeline is demonstrated in <a href="../chapter9/preprocessing.html#sec-prepro-robustify" class="quarto-xref"><span>Section 9.4</span></a>.</li>
<li>
<code>ppl("stacking", base_learners, super_learner)</code>: Stacking, returned to in detail in <a href="#sec-pipelines-stack" class="quarto-xref"><span>Section 8.3.2</span></a>, is the process of using predictions from one or more models (<code>base_learners</code>) as features in a subsequent model (<code>super_learner</code>)</li>
<li>
<code>ppl("targettrafo", graph)</code>: Create a <code>Graph</code> that transforms the prediction target of a task and ensures that any transformations applied during training (using the function passed to the <code>targetmutate.trafo</code> hyperparameter) are inverted in the resulting predictions (using the function passed to the <code>targetmutate.inverter</code> hyperparameter); an example is given in <a href="../chapter9/preprocessing.html#sec-prepro-scale" class="quarto-xref"><span>Section 9.5</span></a>.</li>
</ul></section><section id="practical-pipelines-by-example" class="level2" data-number="8.3"><h2 data-number="8.3" class="anchored" data-anchor-id="practical-pipelines-by-example">
<span class="header-section-number">8.3</span> Practical Pipelines by Example</h2>
<p>In this section, we will put pipelines into practice by demonstrating how to turn weak learners into powerful machine learning models using bagging and stacking.</p>
<section id="sec-pipelines-bagging" class="level3" data-number="8.3.1"><h3 data-number="8.3.1" class="anchored" data-anchor-id="sec-pipelines-bagging">
<span class="header-section-number">8.3.1</span> Bagging with “greplicate” and “subsample”</h3>
<p>The basic idea of bagging (from <strong>b</strong>ootstrapp <strong>agg</strong>regat<strong>ing</strong>), introduced by <span class="citation" data-cites="Breiman1996">Breiman (<a href="../references.html#ref-Breiman1996" role="doc-biblioref">1996</a>)</span>, is to aggregate multiple predictors into a single, more powerful predictor (<a href="#fig-pipelines-bagging" class="quarto-xref">Figure&nbsp;<span>8.5</span></a>). Predictions are usually aggregated by the arithmetic mean for regression tasks or majority vote for classification. The underlying intuition behind bagging is that averaging a set of unstable and diverse (i.e., only weakly correlated) predictors can reduce the variance of the overall prediction. Each learner is trained on a different random sample of the original data.</p>
<p>Although we have already seen that a pre-constructed bagging pipeline is available with <code>ppl("bagging")</code>, in this section we will build our own pipeline from scratch to showcase how to construct a complex <a href="https://mlr3pipelines.mlr-org.com/reference/Graph.html"><code>Graph</code></a>, which will look something like <a href="#fig-pipelines-bagging" class="quarto-xref">Figure&nbsp;<span>8.5</span></a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-bagging" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph shows &quot;Dtrain&quot; with arrows to four separate po(&quot;subsample&quot;) boxes that each have a separate arrow to four more po(&quot;classif.rpart&quot;) boxes that each have an arrow to the same one po(&quot;classif.avg&quot;) box.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-bagging-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-26.svg" class="img-fluid figure-img" style="width:70.0%" alt="Graph shows &quot;Dtrain&quot; with arrows to four separate po(&quot;subsample&quot;) boxes that each have a separate arrow to four more po(&quot;classif.rpart&quot;) boxes that each have an arrow to the same one po(&quot;classif.avg&quot;) box.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-bagging-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.5: Graph that performs Bagging by independently subsampling data and fitting individual decision tree learners. The resulting predictions are aggregated by a majority vote <code>PipeOp</code>.
</figcaption></figure>
</div>
</div>
</div>
<p>To begin, we use <code>po("subsample")</code> to sample a fraction of the data (here 70%), which is then passed to a classification tree (note by default <code>po("subsample")</code> samples without replacement).</p>
<div class="cell">
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">gr_single_pred</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"subsample"</span>, frac <span class="op">=</span> <span class="fl">0.7</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we use <code>ppl("greplicate")</code> to copy the graph, <code>gr_single_pred</code>, 10 times (<code>n = 10</code>) and finally <code>po("classifavg")</code> to take the majority vote of all predictions, note that we pass <code>innum = 10</code> to <code>"classifavg"</code> to tell the <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a> to expect 10 inputs.</p>
<div class="cell">
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">gr_pred_set</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl</a></span><span class="op">(</span><span class="st">"greplicate"</span>, graph <span class="op">=</span> <span class="va">gr_single_pred</span>, n <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">gr_bagging</span> <span class="op">=</span> <span class="va">gr_pred_set</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"classifavg"</span>, innum <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">gr_bagging</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-bagginggraph" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Parallel pipeline showing &quot;<INPUT>&quot; pointing to ten PipeOps &quot;subsample_1&quot;,...,&quot;subsample_10&quot; that each separately point to &quot;classif.rpart_1&quot;,...,&quot;classif.rpart_10&quot; respectively, which all point to the same &quot;classifavg -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-bagginggraph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-bagginggraph-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Parallel pipeline showing &quot;<INPUT>&quot; pointing to ten PipeOps &quot;subsample_1&quot;,...,&quot;subsample_10&quot; that each separately point to &quot;classif.rpart_1&quot;,...,&quot;classif.rpart_10&quot; respectively, which all point to the same &quot;classifavg -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-bagginggraph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.6: Constructed bagging <code>Graph</code> with one input being sampled many times for 10 different learners.
</figcaption></figure>
</div>
</div>
</div>
<p>Now let us see how well our bagging pipeline compares to the single decision tree and a random forest when benchmarked against <code>tsk("sonar")</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># turn graph into learner</span></span>
<span><span class="va">glrn_bagging</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="va">gr_bagging</span><span class="op">)</span></span>
<span><span class="va">glrn_bagging</span><span class="op">$</span><span class="va">id</span> <span class="op">=</span> <span class="st">"bagging"</span></span>
<span></span>
<span><span class="va">lrn_rpart</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span><span class="va">learners</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">glrn_bagging</span>, <span class="va">lrn_rpart</span>, <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.ranger"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">bmr</span> <span class="op">=</span> <span class="fu">benchmark</span><span class="op">(</span><span class="fu">benchmark_grid</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>, <span class="va">learners</span>,</span>
<span>  <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">bmr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">learner_id</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       learner_id classif.ce
1:        bagging     0.2498
2:  classif.rpart     0.2739
3: classif.ranger     0.1973</code></pre>
</div>
</div>
<p>The bagged learner performs better than the decision tree but worse than the random forest. To automatically recreate this pipeline, you can construct <code>ppl("bagging")</code> by specifying the learner to ‘bag’, the number of iterations, the fraction of data to sample, and the <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a> to average the predictions, as shown in the code below. Note we set <code>collect_multiplicity = TRUE</code> which collects the predictions across paths, that technically use the <a href="https://mlr3pipelines.mlr-org.com/reference/Multiplicity.html"><code>Multiplicity</code></a> method, which we will not discuss here but refer the reader to the documentation.</p>
<div class="cell">
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl</a></span><span class="op">(</span><span class="st">"bagging"</span>, <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>  iterations <span class="op">=</span> <span class="fl">10</span>, frac <span class="op">=</span> <span class="fl">0.7</span>,</span>
<span>  averager <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"classifavg"</span>, collect_multiplicity <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The main difference between our pipeline and a random forest is that the latter also performs feature subsampling, where only a random subset of available features is considered at each split point. While we cannot implement this directly with <code>mlr3pipelines</code>, we can use a custom <a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>Selector</code></a> method to approximate this method. We will create this <code>Selector</code> by passing a function that takes as input the task and returns a sample of the features, we sample the square root of the number of features to mimic the implementation in <a href="https://www.rdocumentation.org/packages/ranger/topics/ranger"><code>ranger</code></a>. For efficiency, we will now use <code>ppl("bagging")</code> to recreate the steps above:</p>
<div class="cell">
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># custom selector</span></span>
<span><span class="va">selector_subsample</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">task</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="va">task</span><span class="op">$</span><span class="va">feature_names</span>, <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">task</span><span class="op">$</span><span class="va">feature_names</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># bagging pipeline with our selector</span></span>
<span><span class="va">gr_bagging_quasi_rf</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl</a></span><span class="op">(</span><span class="st">"bagging"</span>,</span>
<span>  graph <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"select"</span>, selector <span class="op">=</span> <span class="va">selector_subsample</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>    <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span>, minsplit <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>  iterations <span class="op">=</span> <span class="fl">100</span>,</span>
<span>  averager <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"classifavg"</span>, collect_multiplicity <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># bootstrap resampling</span></span>
<span><span class="va">gr_bagging_quasi_rf</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span><span class="op">$</span><span class="va">subsample.replace</span> <span class="op">=</span> <span class="cn">TRUE</span></span>
<span></span>
<span><span class="co"># convert to learner</span></span>
<span><span class="va">glrn_quasi_rf</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="va">gr_bagging_quasi_rf</span><span class="op">)</span></span>
<span><span class="va">glrn_quasi_rf</span><span class="op">$</span><span class="va">id</span> <span class="op">=</span> <span class="st">"quasi.rf"</span></span>
<span></span>
<span><span class="co"># benchmark</span></span>
<span><span class="va">design</span> <span class="op">=</span> <span class="fu">benchmark_grid</span><span class="op">(</span><span class="fu">tsks</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">glrn_quasi_rf</span>, <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.ranger"</span>, num.trees <span class="op">=</span> <span class="fl">100</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">bmr</span> <span class="op">=</span> <span class="fu">benchmark</span><span class="op">(</span><span class="va">design</span><span class="op">)</span></span>
<span><span class="va">bmr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">learner_id</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       learner_id classif.ce
1:       quasi.rf     0.1826
2: classif.ranger     0.1590</code></pre>
</div>
</div>
<p>In only a few lines of code, we took a weaker learner and turned it into a powerful model that we can see is comparable to the implementation in <code><a href="http://imbs-hl.github.io/ranger/reference/ranger.html">ranger::ranger</a></code>. In the next section, we will look at a second example, which makes use of cross-validation within pipelines.</p>
</section><section id="sec-pipelines-stack" class="level3" data-number="8.3.2"><h3 data-number="8.3.2" class="anchored" data-anchor-id="sec-pipelines-stack">
<span class="header-section-number">8.3.2</span> Stacking with po(“learner_cv”)</h3>
<p>Stacking <span class="citation" data-cites="Wolpert1992">(<a href="../references.html#ref-Wolpert1992" role="doc-biblioref">Wolpert 1992</a>)</span> is another very popular ensembling technique that can significantly improve predictive performance. The basic idea behind stacking is to use predictions from multiple models (usually referred to as level 0 models) as features for a subsequent model (the level 1 model) which in turn combines these predictions (<a href="#fig-pipelines-stacking" class="quarto-xref">Figure&nbsp;<span>8.7</span></a>). A simple combination can be a linear model (possibly regularized if you have many level 0 models), since a weighted sum of level 0 models is often plausible and good enough. Though, non-linear level 1 models can also be used, and it is also possible for the level 1 model to access the input features as well as the level 0 predictions. Stacking can be built with more than two levels (both conceptually, and in <code>mlr3</code>) but we limit ourselves to this simpler setup here, which often also performs well in practice.</p>
<p>As with bagging, we will demonstrate how to create a stacking pipeline manually, although a pre-constructed pipeline is available with <code>ppl("stacking")</code>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-stacking" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph shows &quot;Dtrain&quot; with arrows to three boxes: &quot;Decision Tree&quot;, &quot;KNN&quot;, and &quot;Lasso Regression&quot;. Each of these points to the same &quot;Feature Union -> Logistic Regression&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-stacking-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-27.svg" class="img-fluid figure-img" style="width:70.0%" alt="Graph shows &quot;Dtrain&quot; with arrows to three boxes: &quot;Decision Tree&quot;, &quot;KNN&quot;, and &quot;Lasso Regression&quot;. Each of these points to the same &quot;Feature Union -> Logistic Regression&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-stacking-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.7: Graph that performs Stacking by fitting three models and using their outputs as features for another model after combining with <code>PipeOpFeatureUnion</code>.
</figcaption></figure>
</div>
</div>
</div>
<p>Stacking pipelines depend on the level 0 learners returning predictions during the <code>$train()</code> phase. This is possible in <code>mlr3pipelines</code> with <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_learner_cv.html"><code>PipeOpLearnerCV</code></a>. During training, this operator performs cross-validation and passes the out-of-sample predictions to the level 1 model. Using cross-validated predictions is recommended to reduce the risk of overfitting.</p>
<p>We first create the level 0 learners to produce the predictions that will be used as features. In this example, we use a classification tree, k-nearest neighbors (KNN), and a regularized GLM. Each learner is wrapped in <code>po("learner_cv")</code> which performs cross-validation on the input data and then outputs the predictions from the <a href="https://mlr3.mlr-org.com/reference/Learner.html"><code>Learner</code></a> in a new <a href="https://mlr3.mlr-org.com/reference/Task.html"><code>Task</code></a> object.</p>
<div class="cell">
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_rpart</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span>
<span><span class="va">po_rpart_cv</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner_cv"</span>, learner <span class="op">=</span> <span class="va">lrn_rpart</span>,</span>
<span>  resampling.folds <span class="op">=</span> <span class="fl">2</span>, id <span class="op">=</span> <span class="st">"rpart_cv"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">lrn_knn</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.kknn"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span>
<span><span class="va">po_knn_cv</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner_cv"</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_knn</span>,</span>
<span>  resampling.folds <span class="op">=</span> <span class="fl">2</span>, id <span class="op">=</span> <span class="st">"knn_cv"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">lrn_glmnet</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.glmnet"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span>
<span><span class="va">po_glmnet_cv</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner_cv"</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_glmnet</span>,</span>
<span>  resampling.folds <span class="op">=</span> <span class="fl">2</span>, id <span class="op">=</span> <span class="st">"glmnet_cv"</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These learners are combined using <a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html"><code>gunion()</code></a>, and <code>po("featureunion")</code> is used to merge their predictions. This is demonstrated in the output of <code>$train()</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">gr_level_0</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html">gunion</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">po_rpart_cv</span>, <span class="va">po_knn_cv</span>, <span class="va">po_glmnet_cv</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">gr_combined</span> <span class="op">=</span> <span class="va">gr_level_0</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"featureunion"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">gr_combined</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="fu">head</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Class rpart_cv.prob.M rpart_cv.prob.R knn_cv.prob.M knn_cv.prob.R
1:     R         0.57895          0.4211        0.3857        0.6143
2:     R         0.88636          0.1136        0.3170        0.6830
3:     R         0.04348          0.9565        0.4396        0.5604
4:     R         0.03030          0.9697        0.4762        0.5238
5:     R         0.04348          0.9565        0.4753        0.5247
6:     R         0.23077          0.7692        0.4020        0.5980
2 variables not shown: [glmnet_cv.prob.M, glmnet_cv.prob.R]</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Retaining Features
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this example, the original features were removed as each <code>PipeOp</code> only returns the predictions made by the respective learners. To retain the original features, include <code>po("nop")</code> in the list passed to <a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html"><code>gunion()</code></a>.</p>
</div>
</div>
<p>The resulting task contains the predicted probabilities for both classes made from each of the level 0 learners. However, as the probabilities always add up to <span class="math inline">\(1\)</span>, we only need the predictions for one of the classes (as this is a binary classification task), so we can use <code>po("select")</code> to only keep predictions for one class (we choose <code>"M"</code> in this example).</p>
<div class="cell">
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">gr_stack</span> <span class="op">=</span> <span class="va">gr_combined</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"select"</span>, selector <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html">selector_grep</a></span><span class="op">(</span><span class="st">"\\.M$"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we can combine our pipeline with the final model that will take these predictions as its input. Below we use logistic regression, which combines the level 0 predictions in a weighted linear sum.</p>
<div class="cell">
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">gr_stack</span> <span class="op">=</span> <span class="va">gr_stack</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner"</span>, <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.log_reg"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">gr_stack</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>horizontal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-stackinggraph" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph with &quot;<INPUT>&quot; in the first box with arrows to three boxes: &quot;rpart_cv&quot;, &quot;knn_cv&quot;, &quot;glmnet_cv&quot;, which all have arrows pointing to the same boxes: &quot;featureunion -> select -> classif.log_reg -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-stackinggraph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-stackinggraph-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Graph with &quot;<INPUT>&quot; in the first box with arrows to three boxes: &quot;rpart_cv&quot;, &quot;knn_cv&quot;, &quot;glmnet_cv&quot;, which all have arrows pointing to the same boxes: &quot;featureunion -> select -> classif.log_reg -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-stackinggraph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.8: Constructed stacking Graph with one input being passed to three weak learners whose predictions are passed to the logistic regression.
</figcaption></figure>
</div>
</div>
</div>
<p>As our final model was an interpretable logistic regression, we can inspect the weights of the level 0 learners by looking at the final trained model:</p>
<div class="cell">
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">glrn_stack</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="va">gr_stack</span><span class="op">)</span></span>
<span><span class="va">glrn_stack</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">glrn_stack</span><span class="op">$</span><span class="fu">base_learner</span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="va">model</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:  stats::glm(formula = form, family = "binomial", data = data, 
    model = FALSE)

Coefficients:
     (Intercept)   rpart_cv.prob.M     knn_cv.prob.M  glmnet_cv.prob.M  
          -3.120            -0.134             4.040             1.804  

Degrees of Freedom: 207 Total (i.e. Null);  204 Residual
Null Deviance:      287 
Residual Deviance: 176  AIC: 184</code></pre>
</div>
</div>
<p>The model weights suggest that knn influences the predictions the most with the largest coefficient. To confirm this we can benchmark the individual models alongside the stacking pipeline.</p>
<div class="cell">
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">glrn_stack</span><span class="op">$</span><span class="va">id</span> <span class="op">=</span> <span class="st">"stacking"</span></span>
<span><span class="va">design</span> <span class="op">=</span> <span class="fu">benchmark_grid</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">lrn_rpart</span>, <span class="va">lrn_knn</span>, <span class="va">lrn_glmnet</span>, <span class="va">glrn_stack</span><span class="op">)</span>, <span class="fu">rsmp</span><span class="op">(</span><span class="st">"repeated_cv"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">bmr</span> <span class="op">=</span> <span class="fu">benchmark</span><span class="op">(</span><span class="va">design</span><span class="op">)</span></span>
<span><span class="va">bmr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">learner_id</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       learner_id classif.ce
1:  classif.rpart     0.2876
2:   classif.kknn     0.1505
3: classif.glmnet     0.2559
4:       stacking     0.1438</code></pre>
</div>
</div>
<p>This experiment confirms that of the individual models, the KNN learner performs the best, however, our stacking pipeline outperforms them all. Now that we have seen the inner workings of this pipeline, next time you might want to more efficiently create it using <code>ppl("stacking")</code>, to copy the example above you would run:</p>
<div class="cell">
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl</a></span><span class="op">(</span><span class="st">"stacking"</span>,</span>
<span>  base_learners <span class="op">=</span> <span class="fu">lrns</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span>,</span>
<span>    <span class="st">"classif.glmnet"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  super_learner <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.log_reg"</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Having covered the building blocks of <code>mlr3pipelines</code> and seen these in practice, we will now turn to more advanced functionality, combining pipelines with tuning.</p>
</section></section><section id="sec-pipelines-tuning" class="level2" data-number="8.4"><h2 data-number="8.4" class="anchored" data-anchor-id="sec-pipelines-tuning">
<span class="header-section-number">8.4</span> Tuning Graphs</h2>
<p>By wrapping a pipeline inside a <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_learners_graph.html"><code>GraphLearner</code></a>, we can tune it at two levels of complexity using <a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a>:</p>
<ol type="1">
<li><p>Tuning of a fixed, usually sequential pipeline, where preprocessing is combined with a given learner. This simply means the joint tuning of any subset of selected hyperparameters of operations in the pipeline. Conceptually and also technically in <code>mlr3</code>, this is not much different from tuning a learner that is not part of a pipeline.</p></li>
<li><p>Tuning not only the hyperparameters of a pipeline, whose structure is not completely fixed in terms of its included operations, but also which concrete <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a>s should be applied to data. This allows us to select these operations (e.g.&nbsp;which learner to use, which preprocessing to perform) in a data-driven manner known as “Combined Algorithm Selection and Hyperparameter optimization” <span class="citation" data-cites="Thornton2013">(<a href="../references.html#ref-Thornton2013" role="doc-biblioref">Thornton et al. 2013</a>)</span>. As we will soon see, we can do this in <code>mlr3pipelines</code> by using the powerful branching (<a href="#sec-pipelines-branch" class="quarto-xref"><span>Section 8.4.2</span></a>) and proxy (<a href="#sec-pipelines-proxy" class="quarto-xref"><span>Section 8.4.3</span></a>) meta operators. Through this, we can conveniently create our own “mini AutoML systems” <span class="citation" data-cites="hutter2019automated">(<a href="../references.html#ref-hutter2019automated" role="doc-biblioref">Hutter, Kotthoff, and Vanschoren 2019</a>)</span> in <code>mlr3</code>, which can even be geared for specific tasks.</p></li>
</ol>
<section id="sec-pipelines-combined" class="level3" data-number="8.4.1"><h3 data-number="8.4.1" class="anchored" data-anchor-id="sec-pipelines-combined">
<span class="header-section-number">8.4.1</span> Tuning Graph Hyperparameters</h3>
<p>Let us consider a simple, sequential pipeline using <code>po("pca")</code> followed by <code>lrn("classif.kknn")</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph_learner</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.kknn"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The optimal setting of the <code>rank.</code> hyperparameter of our PCA <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a> may realistically depend on the value of the <code>k</code> hyperparameter of the KNN model so jointly tuning them is reasonable. For this, we can simply use the syntax for tuning <code>Learner</code>s, which was introduced in <a href="../chapter4/hyperparameter_optimization.html" class="quarto-xref"><span>Chapter 4</span></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_knn</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.kknn"</span>, k <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">32</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">po_pca</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span>, rank. <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">2</span>, <span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph_learner</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="va">po_pca</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="va">lrn_knn</span><span class="op">)</span></span>
<span><span class="va">graph_learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$pca.rank.
Tuning over:
range [2, 20]


$classif.kknn.k
Tuning over:
range [1, 32]</code></pre>
</div>
</div>
<p>We can see how the pipeline’s <code>$param_set</code> includes the tune tokens for all selected hyperparameters, creating a joint search space. We can compare the tuned and untuned pipeline in a benchmark experiment with nested resampling by using an <code>AutoTuner</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">glrn_tuned</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span><span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span>, <span class="va">graph_learner</span>,</span>
<span>  <span class="fu">rsmp</span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span>, term_evals <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">glrn_untuned</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.kknn"</span><span class="op">)</span></span>
<span><span class="va">design</span> <span class="op">=</span> <span class="fu">benchmark_grid</span><span class="op">(</span><span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">glrn_tuned</span>, <span class="va">glrn_untuned</span><span class="op">)</span>,</span>
<span>  <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">benchmark</span><span class="op">(</span><span class="va">design</span><span class="op">)</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">learner_id</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>               learner_id classif.ce
1: pca.classif.kknn.tuned     0.2028
2:       pca.classif.kknn     0.2458</code></pre>
</div>
</div>
<p>Tuning pipelines will usually take longer than tuning individual learners as training steps are often more complex and the search space will be larger. Therefore, parallelization is often appropriate (<a href="../chapter10/advanced_technical_aspects_of_mlr3.html#sec-parallelization" class="quarto-xref"><span>Section 10.1</span></a>) and/or more efficient tuning methods for searching large tuning spaces such as Bayesian optimization (<a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-bayesian-optimization" class="quarto-xref"><span>Section 5.4</span></a>).</p>
</section><section id="sec-pipelines-branch" class="level3" data-number="8.4.2"><h3 data-number="8.4.2" class="anchored" data-anchor-id="sec-pipelines-branch">
<span class="header-section-number">8.4.2</span> Tuning Alternative Paths with po(“branch”)</h3>
<p>In the previous section, we tuned the KKNN and decision tree in the stacking pipeline, as well as tuning the rank of the PCA. However, we tuned the PCA without first considering if it was even beneficial at all, in this section we will answer that question by making use of <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_branch.html"><code>PipeOpBranch</code></a> and <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_unbranch.html"><code>PipeOpUnbranch</code></a>, which make it possible to specify multiple alternative paths in a pipeline. <code>po("branch")</code> creates multiple paths such that data can only flow through <em>one</em> of these as determined by the <code>selection</code> hyperparameter (<a href="#fig-pipelines-alternatives" class="quarto-xref">Figure&nbsp;<span>8.13</span></a>). This concept makes it possible to use tuning to decide which <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a>s and <a href="https://mlr3.mlr-org.com/reference/Learner.html"><code>Learner</code></a>s to include in the pipeline, while also allowing all options in every path to be tuned.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-branching" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph with &quot;Dtrain&quot; on the left with an arrow to `po(&quot;branch&quot;, selection = &quot;pca&quot;)` which then has a dark shaded arrow to a box that says &quot;PCA&quot;. Above this box is a transparent box that says &quot;PipeOpNOP&quot; and below the &quot;PCA&quot; box is another transparent box that says &quot;YeoJohnson&quot;, the implication is that only the &quot;PCA&quot; box is active. The &quot;PCA&quot; box then has an arrow to `po(&quot;unbranch&quot;)` -> po(&quot;branch&quot;, selection = &quot;XGBoost&quot;)` which has three arrows to another three boxes with &quot;XGBoost&quot; highlighted and &quot;Random Forest&quot; and &quot;Decision Tree&quot; transparent again. These finally have arrows to the same `po(&quot;unbranch&quot;)`.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-branching-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-24.svg" class="img-fluid figure-img" style="width:100.0%" alt="Graph with &quot;Dtrain&quot; on the left with an arrow to `po(&quot;branch&quot;, selection = &quot;pca&quot;)` which then has a dark shaded arrow to a box that says &quot;PCA&quot;. Above this box is a transparent box that says &quot;PipeOpNOP&quot; and below the &quot;PCA&quot; box is another transparent box that says &quot;YeoJohnson&quot;, the implication is that only the &quot;PCA&quot; box is active. The &quot;PCA&quot; box then has an arrow to `po(&quot;unbranch&quot;)` -> po(&quot;branch&quot;, selection = &quot;XGBoost&quot;)` which has three arrows to another three boxes with &quot;XGBoost&quot; highlighted and &quot;Random Forest&quot; and &quot;Decision Tree&quot; transparent again. These finally have arrows to the same `po(&quot;unbranch&quot;)`.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-branching-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.9: Figure demonstrates the <code>po("branch")</code> and <code>po("unbranch")</code> operators where three separate branches are created and data only flows through the PCA, which is specified with the argument to <code>selection</code>.
</figcaption></figure>
</div>
</div>
</div>
<p>To demonstrate alternative paths we will make use of the MNIST <span class="citation" data-cites="lecun1998gradient">(<a href="../references.html#ref-lecun1998gradient" role="doc-biblioref">LeCun et al. 1998</a>)</span> data, which is useful for demonstrating preprocessing. The data is loaded from OpenML, which is described in <a href="../chapter11/large-scale_benchmarking.html#sec-openml" class="quarto-xref"><span>Section 11.1</span></a>, we subset the data to make the example run faster.</p>
<div class="cell">
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3oml.mlr-org.com">mlr3oml</a></span><span class="op">)</span></span>
<span><span class="va">otsk_mnist</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3oml.mlr-org.com/reference/otsk.html">otsk</a></span><span class="op">(</span>id <span class="op">=</span> <span class="fl">3573</span><span class="op">)</span></span>
<span><span class="va">tsk_mnist</span> <span class="op">=</span> <span class="fu">as_task</span><span class="op">(</span><span class="va">otsk_mnist</span><span class="op">)</span><span class="op">$</span></span>
<span>  <span class="fu">filter</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">70000</span>, <span class="fl">1000</span><span class="op">)</span><span class="op">)</span><span class="op">$</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">otsk_mnist</span><span class="op">$</span><span class="va">feature_names</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">700</span>, <span class="fl">100</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>po("branch")</code> is initialized either with the number of branches or with a <code>character</code>-vector indicating the names of the branches, the latter makes the <code>selection</code> hyperparameter (discussed below) more readable. Below we create three branches: do nothing (<code>po("nop")</code>), apply PCA (<code>po("pca")</code>), remove constant features (<code>po("removeconstants")</code>) then apply the Yeo-Johnson transform (<code>po("yeojohnson")</code>). It is important to use <code>po("unbranch")</code> (with the same arguments as <code>"branch"</code>) to ensure that the outputs are merged into one result object.</p>
<div class="cell">
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">paths</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"nop"</span>, <span class="st">"pca"</span>, <span class="st">"yeojohnson"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"branch"</span>, <span class="va">paths</span>, id <span class="op">=</span> <span class="st">"brnchPO"</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/gunion.html">gunion</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>    <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"nop"</span><span class="op">)</span>,</span>
<span>    <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span><span class="op">)</span>,</span>
<span>    <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"removeconstants"</span>, id <span class="op">=</span> <span class="st">"rm_const"</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>      <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"yeojohnson"</span>, id <span class="op">=</span> <span class="st">"YJ"</span><span class="op">)</span></span>
<span>  <span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"unbranch"</span>, <span class="va">paths</span>, id <span class="op">=</span> <span class="st">"unbrnchPO"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>horizontal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-branchone" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph starting with &quot;<INPUT> -> brnchPO&quot; which has three arrows to &quot;removeconstants -> yeojohnson&quot;, &quot;nop&quot;, and &quot;pca&quot;, which all then point to &quot;unbrnchPO -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-branchone-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-branchone-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Graph starting with &quot;<INPUT> -> brnchPO&quot; which has three arrows to &quot;removeconstants -> yeojohnson&quot;, &quot;nop&quot;, and &quot;pca&quot;, which all then point to &quot;unbrnchPO -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-branchone-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.10: Graph with branching to three different paths that are split with <code>po("branch")</code> and combined with <code>po("unbranch")</code>.
</figcaption></figure>
</div>
</div>
</div>
<p>We can see how the output of this <code>Graph</code> depends on the setting of the <code>branch.selection</code> hyperparameter:</p>
<div class="cell">
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># use the "PCA" path</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span><span class="op">$</span><span class="va">brnchPO.selection</span> <span class="op">=</span> <span class="st">"pca"</span></span>
<span><span class="co"># new PCA columns</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_mnist</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">feature_names</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "PC1" "PC2" "PC3" "PC4" "PC5" "PC6"</code></pre>
</div>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># use the "No-Op" path</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span><span class="op">$</span><span class="va">brnchPO.selection</span> <span class="op">=</span> <span class="st">"nop"</span></span>
<span><span class="co"># same features</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_mnist</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">feature_names</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "pixel4"  "pixel8"  "pixel10" "pixel11" "pixel14" "pixel39"</code></pre>
</div>
</div>
<p><code>ppl("branch")</code> simplifies the above by allowing you to just pass the different paths to the <code>graphs</code> argument (omitting “<code>rm_const</code>” for simplicity here):</p>
<div class="cell">
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl</a></span><span class="op">(</span><span class="st">"branch"</span>, graphs <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">pos</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"nop"</span>, <span class="st">"pca"</span>, <span class="st">"yeojohnson"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Branching can even be used to tune which of several learners is most appropriate for a given dataset. We extend our example further and add the choice between a decision tree and KKNN:</p>
<div class="cell">
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph_learner</span> <span class="op">=</span> <span class="va">graph</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl</a></span><span class="op">(</span><span class="st">"branch"</span>, <span class="fu">lrns</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph_learner</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>horizontal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-branchtwo" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph starts with &quot;<INPUT> -> brnchPO&quot; which has three arrows to &quot;removeconstants -> yeojohnson&quot;, &quot;nop&quot;, and &quot;pca&quot;, which all then point to &quot;unbrnchPO -> branch&quot;, which then has two arrows to &quot;classif.rpart&quot; and &quot;classif.kknn&quot; which then both point to &quot;unbranch -> <OUTPUT>&quot;.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-branchtwo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-pipelines-branchtwo-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Graph starts with &quot;<INPUT> -> brnchPO&quot; which has three arrows to &quot;removeconstants -> yeojohnson&quot;, &quot;nop&quot;, and &quot;pca&quot;, which all then point to &quot;unbrnchPO -> branch&quot;, which then has two arrows to &quot;classif.rpart&quot; and &quot;classif.kknn&quot; which then both point to &quot;unbranch -> <OUTPUT>&quot;.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-branchtwo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.11: Graph with branching to three different paths that are split with <code>po("branch")</code> and combined with <code>po("unbranch")</code> then branch and recombine again.
</figcaption></figure>
</div>
</div>
</div>
<p>Tuning the <code>selection</code> hyperparameters can help determine which of the possible options work best in combination. We additionally tune the <code>k</code> hyperparameter of the KNN learner, as it may depend on the type of preprocessing performed. As this hyperparameter is only active when the <code>"classif.kknn"</code> path is chosen we will set a dependency (<a href="../chapter4/hyperparameter_optimization.html#sec-optimization-depends" class="quarto-xref"><span>Section 4.4.4</span></a>):</p>
<div class="cell">
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph_learner</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="va">graph_learner</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph_learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span></span>
<span>  brnchPO.selection <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="va">paths</span><span class="op">)</span>,</span>
<span>  branch.selection <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  classif.kknn.k <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu">p_int</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">32</span>,</span>
<span>    depends <span class="op">=</span> <span class="va">branch.selection</span> <span class="op">==</span> <span class="st">"classif.kknn"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">tune</span><span class="op">(</span><span class="fu">tnr</span><span class="op">(</span><span class="st">"grid_search"</span><span class="op">)</span>, <span class="va">tsk_mnist</span>, <span class="va">graph_learner</span>,</span>
<span>  <span class="fu">rsmp</span><span class="op">(</span><span class="st">"repeated_cv"</span>, folds <span class="op">=</span> <span class="fl">3</span>, repeats <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">$</span><span class="va">data</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">classif.ce</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">brnchPO.selection</span>, <span class="va">classif.kknn.k</span>, <span class="va">branch.selection</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   brnchPO.selection classif.kknn.k branch.selection classif.ce
1:        yeojohnson             11     classif.kknn     0.2387
2:        yeojohnson             15     classif.kknn     0.2403
3:        yeojohnson              8     classif.kknn     0.2410
4:        yeojohnson             22     classif.kknn     0.2443
5:        yeojohnson             18     classif.kknn     0.2447</code></pre>
</div>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-nonseq-instance" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Three scatter plots all with y-axis 'classif.ce' from around 0.25 to 0.5. Left plot is 'brnchPO.selection', middle is 'classif.knn.k', right is 'branch.selection'. x-axis text is the hyperparameter values to tune. Each 'row' of the y-axis indicates a different hyperparameter configuration (also separated by colored dots). The bottom row (and therefore best configuration) is at around 0.22 and shows the same results as in the instance output. Other 'rows' show a trade-off between KKNN `k` parameter, choice of learner, and choice of operators.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-nonseq-instance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-nonseq-instance-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Three scatter plots all with y-axis 'classif.ce' from around 0.25 to 0.5. Left plot is 'brnchPO.selection', middle is 'classif.knn.k', right is 'branch.selection'. x-axis text is the hyperparameter values to tune. Each 'row' of the y-axis indicates a different hyperparameter configuration (also separated by colored dots). The bottom row (and therefore best configuration) is at around 0.22 and shows the same results as in the instance output. Other 'rows' show a trade-off between KKNN `k` parameter, choice of learner, and choice of operators.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-nonseq-instance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.12: Instance after tuning preprocessing branch choice (<code>brnchPO.selection</code>), KNN <code>k</code> parameter (<code>classif.kknn.k</code>), and learning branch choice (<code>branch.selection</code>). Dots are different hyperparameter configurations that were tested during tuning, colors separate hyperparameter configurations.
</figcaption></figure>
</div>
</div>
</div>
<p>As we can see in the results and <a href="#fig-nonseq-instance" class="quarto-xref">Figure&nbsp;<span>8.12</span></a>, the KNN-learner with <code>k</code> set to 11 was selected, which performs best in combination with the Yeo-Johnson transform.</p>
</section><section id="sec-pipelines-proxy" class="level3" data-number="8.4.3"><h3 data-number="8.4.3" class="anchored" data-anchor-id="sec-pipelines-proxy">
<span class="header-section-number">8.4.3</span> Tuning with po(“proxy”)</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p><code>po("proxy")</code> is a meta-operator that performs the operation that is stored in its <code>content</code> hyperparameter, which could be another <a href="https://mlr3pipelines.mlr-org.com/reference/PipeOp.html"><code>PipeOp</code></a> or <a href="https://mlr3pipelines.mlr-org.com/reference/Graph.html"><code>Graph</code></a>. It can therefore be used to tune over and select different <code>PipeOp</code>s or <code>Graph</code>s that could be passed to this hyperparameter (<a href="#fig-pipelines-alternatives" class="quarto-xref">Figure&nbsp;<span>8.13</span></a>).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-pipelines-alternatives" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Graph with &quot;Dtrain -> po(&quot;proxy&quot;, content = PCA) -> po(&quot;proxy&quot;, content = XGBoost)&quot;; &quot;PCA&quot; and &quot;XGBoost&quot; are represented as boxes that imply PipeOps.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-pipelines-alternatives-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-25.svg" class="img-fluid figure-img" style="width:70.0%" alt="Graph with &quot;Dtrain -> po(&quot;proxy&quot;, content = PCA) -> po(&quot;proxy&quot;, content = XGBoost)&quot;; &quot;PCA&quot; and &quot;XGBoost&quot; are represented as boxes that imply PipeOps.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipelines-alternatives-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.13: Figure demonstrates the <code>po("proxy")</code> operator with a <code>PipeOp</code> as its argument.
</figcaption></figure>
</div>
</div>
</div>
<p>To recreate the example above with <code>po("proxy")</code>, the first step is to create placeholder <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_proxy.html"><code>PipeOpProxy</code></a> operators to stand in for the operations (i.e., different paths) that should be tuned.</p>
<div class="cell">
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph_learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"proxy"</span>, id <span class="op">=</span> <span class="st">"preproc"</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"proxy"</span>, id <span class="op">=</span> <span class="st">"learner"</span><span class="op">)</span></span>
<span><span class="va">graph_learner</span> <span class="op">=</span> <span class="fu">as_learner</span><span class="op">(</span><span class="va">graph_learner</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The tuning space for the <code>content</code> hyperparameters should be a discrete set of possibilities to be evaluated, passed as a <a href="https://paradox.mlr-org.com/reference/Domain.html"><code>p_fct</code></a> (<a href="../chapter4/hyperparameter_optimization.html#sec-tune-ps" class="quarto-xref"><span>Section 4.4.2</span></a>). For the <code>"preproc"</code> proxy operator this would simply be the different <code>PipeOp</code>s that we want to consider:</p>
<div class="cell">
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># define content for the preprocessing proxy operator</span></span>
<span><span class="va">preproc.content</span> <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>  nop <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"nop"</span><span class="op">)</span>,</span>
<span>  pca <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"pca"</span><span class="op">)</span>,</span>
<span>  yeojohnson <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"removeconstants"</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"yeojohnson"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For the <code>"learner"</code> proxy, this is more complicated as the selection of the learner depends on more than one search space component: The choice of the learner itself (<code>lrn("classif.rpart")</code> or <code>lrn("classif.kknn")</code>) and the tuned <code>k</code> hyperparameter of the KNN learner. To enable this we pass a transformation to <code>.extra_trafo</code> (<a href="../chapter4/hyperparameter_optimization.html#sec-tune-trafo" class="quarto-xref"><span>Section 4.4.3</span></a>). Note that inside this transformation we clone <code>learner.content</code>, otherwise, we would end up modifying the original <a href="https://mlr3.mlr-org.com/reference/Learner.html"><code>Learner</code></a> object inside the search space by reference (<a href="../chapter1/introduction_and_overview.html#sec-r6" class="quarto-xref"><span>Section 1.5.1</span></a>).</p>
<div class="cell">
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># define content for the learner proxy operator</span></span>
<span><span class="va">learner.content</span> <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span></span>
<span>    classif.rpart <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>    classif.kknn <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.kknn"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># define transformation to set the content values</span></span>
<span><span class="va">trafo</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">param_set</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NULL.html">is.null</a></span><span class="op">(</span><span class="va">x</span><span class="op">$</span><span class="va">classif.kknn.k</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">x</span><span class="op">$</span><span class="va">learner.content</span> <span class="op">=</span> <span class="va">x</span><span class="op">$</span><span class="va">learner.content</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span>deep <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>      <span class="va">x</span><span class="op">$</span><span class="va">learner.content</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span><span class="op">$</span><span class="va">k</span> <span class="op">=</span> <span class="va">x</span><span class="op">$</span><span class="va">classif.kknn.k</span></span>
<span>      <span class="va">x</span><span class="op">$</span><span class="va">classif.kknn.k</span> <span class="op">=</span> <span class="cn">NULL</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">x</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now put this all together, add the KNN tuning, and run the experiment.</p>
<div class="cell">
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  preproc.content <span class="op">=</span> <span class="va">preproc.content</span>,</span>
<span>  learner.content <span class="op">=</span> <span class="va">learner.content</span>,</span>
<span>  <span class="co"># tune KKNN parameter as normal</span></span>
<span>  classif.kknn.k <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">32</span>,</span>
<span>    depends <span class="op">=</span> <span class="va">learner.content</span> <span class="op">==</span> <span class="st">"classif.kknn"</span><span class="op">)</span>,</span>
<span>  .extra_trafo <span class="op">=</span> <span class="va">trafo</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">tune</span><span class="op">(</span><span class="fu">tnr</span><span class="op">(</span><span class="st">"grid_search"</span><span class="op">)</span>, <span class="va">tsk_mnist</span>, <span class="va">graph_learner</span>,</span>
<span>  <span class="fu">rsmp</span><span class="op">(</span><span class="st">"repeated_cv"</span>, folds <span class="op">=</span> <span class="fl">3</span>, repeats <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  search_space <span class="op">=</span> <span class="va">search_space</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/data.table/man/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">)</span><span class="op">[</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">preproc.content</span>,</span>
<span>    classif.kknn.k <span class="op">=</span> <span class="va">x_domain</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">learner.content</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span><span class="op">$</span><span class="va">k</span>,</span>
<span>    <span class="va">learner.content</span>, <span class="va">classif.ce</span><span class="op">)</span></span>
<span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   preproc.content classif.kknn.k learner.content classif.ce
1:      yeojohnson             11    classif.kknn     0.2367</code></pre>
</div>
</div>
<p>Once again, the best configuration is a KNN learner with the Yeo-Johnson transform. In practice <code>po("proxy")</code> offers complete flexibility and may be more useful for more complicated use cases, whereas <code>ppl("branch")</code> is more efficient in more straightforward scenarios.</p>
</section><section id="sec-hyperband-example-svm" class="level3" data-number="8.4.4"><h3 data-number="8.4.4" class="anchored" data-anchor-id="sec-hyperband-example-svm">
<span class="header-section-number">8.4.4</span> Hyperband with Subsampling</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>In <a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-hyperband" class="quarto-xref"><span>Section 5.3</span></a> we learned about the Hyperband tuner and how it can make use of fidelity parameters to efficiently tune learners. Now that you have learned about pipelines and how to tune them, in this short section we will briefly return to Hyperband to showcase how we can put together everything we have learned in this chapter to allow Hyperband to be used with any <code>Learner</code>.</p>
<p>We previously saw how some learners have hyperparameters that can act naturally as fidelity parameters, such as the number of trees in a random forest. However, using pipelines, we can now create a fidelity parameter for any model using <code>po("subsample")</code>. The <code>frac</code> parameter of <code>po("subsample")</code> controls the amount of data fed into the subsequent <code>Learner</code>. In general, feeding less data to a <code>Learner</code> results in quicker model training but poorer quality predictions compared to when more training data is supplied. Resampling with less data will still give us some information about the relative performance of different model configurations, thus making the fraction of data to subsample the perfect candidate for a fidelity parameter.</p>
<p>In this example, we will optimize the SVM hyperparameters, <code>cost</code> and <code>gamma</code>, on <code>tsk("sonar")</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3tuning.mlr-org.com">mlr3tuning</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.svm"</span>, id <span class="op">=</span> <span class="st">"svm"</span>, type <span class="op">=</span> <span class="st">"C-classification"</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>, cost  <span class="op">=</span> <span class="fu"><a href="https://paradox.mlr-org.com/reference/to_tune.html">to_tune</a></span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu"><a href="https://paradox.mlr-org.com/reference/to_tune.html">to_tune</a></span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We then construct <code>po("subsample")</code> and specify that we want to use the <code>frac</code> parameter between <span class="math inline">\([3^{-3}, 1]\)</span> as our fidelity parameter and set the <code>"budget"</code> tag to pass this information to Hyperband. We add this to our SVM and create a <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_learners_graph.html"><code>GraphLearner</code></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph_learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/as_learner.html">as_learner</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"subsample"</span>, frac <span class="op">=</span> <span class="fu"><a href="https://paradox.mlr-org.com/reference/to_tune.html">to_tune</a></span><span class="op">(</span><span class="fu"><a href="https://paradox.mlr-org.com/reference/Domain.html">p_dbl</a></span><span class="op">(</span><span class="fl">3</span><span class="op">^</span><span class="op">-</span><span class="fl">3</span>, <span class="fl">1</span>, tags <span class="op">=</span> <span class="st">"budget"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="va">learner</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As good practice, we encapsulate our learner and add a fallback to prevent fatal errors (<a href="../chapter5/advanced_tuning_methods_and_black_box_optimization.html#sec-tuning-errors" class="quarto-xref"><span>Section 5.1</span></a>).</p>
<div class="cell">
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph_learner</span><span class="op">$</span><span class="fu">encapsulate</span><span class="op">(</span><span class="st">"evaluate"</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.featureless"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph_learner</span><span class="op">$</span><span class="va">timeout</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>train <span class="op">=</span> <span class="fl">30</span>, predict <span class="op">=</span> <span class="fl">30</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can tune our SVM by tuning our <code>GraphLearner</code> as normal, below we set <code>eta = 3</code> for Hyperband.</p>
<div class="cell">
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/tune.html">tune</a></span><span class="op">(</span><span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/tnr.html">tnr</a></span><span class="op">(</span><span class="st">"hyperband"</span>, eta <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>, <span class="va">graph_learner</span>,</span>
<span>  <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span><span class="op">$</span><span class="va">result_x_domain</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$subsample.frac
[1] 1

$svm.cost
[1] 5.435

$svm.gamma
[1] 0.008318</code></pre>
</div>
</div>
</section><section id="sec-pipelines-featsel" class="level3" data-number="8.4.5"><h3 data-number="8.4.5" class="anchored" data-anchor-id="sec-pipelines-featsel">
<span class="header-section-number">8.4.5</span> Feature Selection with Filter Pipelines</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>In <a href="../chapter6/feature_selection.html#sec-fs-filter-based" class="quarto-xref"><span>Section 6.1.4</span></a> we learnt about filter-based feature selection and how we can manually run a filter and then extract the selected features, often using an arbitrary choice of thresholds that were not tuned. Now that we have covered pipelines and tuning, we will briefly return to feature selection to demonstrate how to automate filter-based feature selection by making use of <code>po("filter")</code>. <code>po("filter")</code> includes the <code>filter</code> construction argument, which takes a <a href="https://www.rdocumentation.org/packages/base/topics/funprog"><code>Filter</code></a> object to be used as the filter method as well as a choice of parameters for different methods of selecting features:</p>
<ul>
<li>
<code>filter.nfeat</code> – Number of features to select</li>
<li>
<code>filter.frac</code> – Fraction of features to select</li>
<li>
<code>filter.cutoff</code> – Minimum value of filter such that features with filter values greater than or equal to the cutoff are kept</li>
<li>
<code>filter.permuted</code> – Random permutation of features added to task before applying the filter and all features before the <code>permuted</code>-th permuted features are kept</li>
</ul>
<p>Below we use the information gain filter and select the top three features:</p>
<div class="cell">
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3filters.mlr-org.com">mlr3filters</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3fselect.mlr-org.com">mlr3fselect</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">task_pen</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># combine filter (keep top 3 features) with learner</span></span>
<span><span class="va">po_flt</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"filter"</span>, filter <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span>, filter.nfeat <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="va">po_flt</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner"</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"filter"</span>, filter <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span>, filter.nfeat <span class="op">=</span> <span class="fl">3</span><span class="op">)</span><span class="op">$</span></span>
<span>  <span class="fu">train</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">task_pen</span><span class="op">)</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">feature_names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "bill_depth"     "bill_length"    "flipper_length"</code></pre>
</div>
</div>
<p>Choosing <code>3</code> as the cutoff was fairly arbitrary but by tuning a graph we can optimize this cutoff:</p>
<div class="cell">
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># tune between 1 and total number of features</span></span>
<span><span class="va">po_filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"filter"</span>, filter <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span>,</span>
<span>  filter.nfeat <span class="op">=</span> <span class="fu"><a href="https://paradox.mlr-org.com/reference/to_tune.html">to_tune</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">task_pen</span><span class="op">$</span><span class="va">ncol</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/as_learner.html">as_learner</a></span><span class="op">(</span><span class="va">po_filter</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner"</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/tune.html">tune</a></span><span class="op">(</span><span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/tnr.html">tnr</a></span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span>, <span class="va">task_pen</span>, <span class="va">graph</span>,</span>
<span>  <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>, term_evals <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">instance</span><span class="op">$</span><span class="va">result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   information_gain.filter.nfeat learner_param_vals  x_domain classif.ce
1:                             5          &lt;list[2]&gt; &lt;list[1]&gt;     0.0552</code></pre>
</div>
</div>
<p>In this example, <code>5</code> is the optimal number of features. It can be especially useful in feature selection to visualize the tuning results as there may be cases where the optimal result is only marginally better than a result with less features (which would lead to a model that is quicker to train and possibly easier to interpret).</p>
<div class="cell">
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-tunefilter" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Plot showing model performance in filter-based feature selection, showing that adding a second, third, and fourth feature to the model improves performance, while adding more features achieves no further performance gain.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-tunefilter-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="non-sequential_pipelines_and_tuning_files/figure-html/fig-tunefilter-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Plot showing model performance in filter-based feature selection, showing that adding a second, third, and fourth feature to the model improves performance, while adding more features achieves no further performance gain.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tunefilter-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.14: Model performance with different numbers of features, selected by an information gain filter.
</figcaption></figure>
</div>
</div>
</div>
<p>Now we can see that four variables may be equally as good in this case so we could consider going forward by selecting four features and not six as suggested by <code>instance$result</code>.</p>
</section></section><section id="conclusion" class="level2" data-number="8.5"><h2 data-number="8.5" class="anchored" data-anchor-id="conclusion">
<span class="header-section-number">8.5</span> Conclusion</h2>
<p>In this chapter, we built on what we learned in <a href="../chapter7/sequential_pipelines.html" class="quarto-xref"><span>Chapter 7</span></a> to develop complex non-sequential <code>Graph</code>s. We saw how to build our own graphs, as well as how to make use of <code><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html">ppl()</a></code> to load <code>Graph</code>s that are available in <a href="https://mlr3pipelines.mlr-org.com"><code>mlr3pipelines</code></a>. We then looked at different ways to tune pipelines, including joint tuning of hyperparameters and tuning the selection of <code>PipeOp</code>s in a <code>Graph</code>, enabling the construction of simple, custom AutoML systems. In <a href="../chapter9/preprocessing.html" class="quarto-xref"><span>Chapter 9</span></a> we will study in more detail how to use pipelines for data preprocessing.</p>
<div id="tbl-api-pipelines-nonseq" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-api-pipelines-nonseq-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;8.1: Important classes and functions covered in this chapter with underlying class (if applicable), class constructor or function, and important class fields and methods (if applicable).
</figcaption><div aria-describedby="tbl-api-pipelines-nonseq-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead><tr class="header">
<th>Class</th>
<th>Constructor/Function</th>
<th>Fields/Methods</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://mlr3pipelines.mlr-org.com/reference/Graph.html"><code>Graph</code></a></td>
<td><a href="https://mlr3pipelines.mlr-org.com/reference/ppl.html"><code>ppl()</code></a></td>
<td>
<code>$train()</code>; <code>$predict()</code>
</td>
</tr>
<tr class="even">
<td><a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>Selector</code></a></td>
<td>
<a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_grep()</code></a>; <a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_type()</code></a>; <a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html"><code>selector_invert()</code></a>
</td>
<td>-</td>
</tr>
<tr class="odd">
<td>
<a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_branch.html"><code>PipeOpBranch</code></a>; <a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_unbranch.html"><code>PipeOpUnbranch</code></a>
</td>
<td>
<code>po("branch")</code>; <code>po("unbranch")</code>
</td>
<td>-</td>
</tr>
<tr class="even">
<td><a href="https://mlr3pipelines.mlr-org.com/reference/mlr_pipeops_proxy.html"><code>PipeOpProxy</code></a></td>
<td><code>po("proxy")</code></td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section><section id="exercises" class="level2" data-number="8.6"><h2 data-number="8.6" class="anchored" data-anchor-id="exercises">
<span class="header-section-number">8.6</span> Exercises</h2>
<ol type="1">
<li>Create a graph that replaces all numeric columns that do not contain missing values with their PCA transform. Solve this in two ways, using <code>affect_columns</code> in a sequential graph, and using <code>po("select")</code> in a non-sequential graph. Train the graph on <code>tsk("pima")</code> to check your result. Hint: You may find <code><a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html">selector_missing()</a></code> useful.</li>
<li>The <code>po("select")</code> in <a href="#sec-pipelines-stack" class="quarto-xref"><span>Section 8.3.2</span></a> is necessary to remove redundant predictions (recall this is a binary classification task so we do not require predictions of both classes). However, if this was a multiclass classification task, then using <code><a href="https://mlr3pipelines.mlr-org.com/reference/Selector.html">selector_grep()</a></code> would need to be called with a pattern for <em>all</em> prediction columns that should be <em>kept</em>, which would be inefficient. Instead it would be more appropriate to provide a pattern for the single class to remove. How would you do this using the <code>Selector</code> functions provided by <code>mlr3pipelines</code>? Implement this and train the modified stacking pipeline on <code>tsk("wine")</code>, using <code>lrn("classif.multinom")</code> as the level 1 learner.</li>
<li>How would you solve the previous exercise without explicitly naming the class you want to exclude, so that your graph works for any classification task? Hint: look at the <code>selector_subsample</code> in <a href="#sec-pipelines-bagging" class="quarto-xref"><span>Section 8.3.1</span></a>.</li>
<li>(*) Create your own “minimal AutoML system” by combining pipelines, branching and tuning. It should allow automatic preprocessing and the automatic selection of a well-performing learning algorithm. Both your <code>PipeOp</code>s and models should be tuned. Your system should feature options for two preprocessing steps (imputation and factor encoding) and at least three learning algorithms to choose from. You can optimize this via random search, or try to use a more advanced tuning algorithm. Test it on at least three different data sets and compare its performance against an untuned random forest via nested resampling.</li>
</ol></section><section id="citation" class="level2" data-number="8.7"><h2 data-number="8.7" class="anchored" data-anchor-id="citation">
<span class="header-section-number">8.7</span> Citation</h2>
<p>Please cite this chapter as:</p>
<p>Binder M, Pfisterer F, Becker M, Wright MN. (2024). Non-sequential Pipelines and Tuning. In Bischl B, Sonabend R, Kotthoff L, Lang M, (Eds.), <em>Applied Machine Learning Using mlr3 in R</em>. CRC Press. https://mlr3book.mlr-org.com/non-sequential_pipelines_and_tuning.html.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode bibtex code-with-copy"><code class="sourceCode bibtex"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="va">@incollection</span>{<span class="ot">citekey</span>,</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">author</span> = "<span class="st">Martin Binder and Florian Pfisterer and Marc Becker and Marvin N. Wright</span>",</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">title</span> = "<span class="st">Non-sequential Pipelines and Tuning</span>",</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">booktitle</span> = "<span class="st">Applied Machine Learning Using {m}lr3 in {R}</span>",</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">publisher</span> = "<span class="st">CRC Press</span>", <span class="st">year</span> = "<span class="st">2024</span>",</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">editor</span> = "<span class="st">Bernd Bischl and Raphael Sonabend and Lars Kotthoff and Michel Lang</span>",</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">url</span> = "<span class="st">https://mlr3book.mlr-org.com/non-sequential_pipelines_and_tuning.html</span>"</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Breiman1996" class="csl-entry" role="listitem">
Breiman, Leo. 1996. <span>“Bagging Predictors.”</span> <em>Machine Learning</em> 24 (2): 123–40. <a href="https://doi.org/10.1007/BF00058655">https://doi.org/10.1007/BF00058655</a>.
</div>
<div id="ref-hutter2019automated" class="csl-entry" role="listitem">
Hutter, Frank, Lars Kotthoff, and Joaquin Vanschoren, eds. 2019. <em>Automated Machine Learning - Methods, Systems, Challenges</em>. Springer.
</div>
<div id="ref-lecun1998gradient" class="csl-entry" role="listitem">
LeCun, Yann, Léon Bottou, Yoshua Bengio, and Patrick Haffner. 1998. <span>“Gradient-Based Learning Applied to Document Recognition.”</span> <em>Proceedings of the IEEE</em> 86 (11): 2278–2324. <a href="https://doi.org/10.1109/5.726791">https://doi.org/10.1109/5.726791</a>.
</div>
<div id="ref-Thornton2013" class="csl-entry" role="listitem">
Thornton, Chris, Frank Hutter, Holger H. Hoos, and Kevin Leyton-Brown. 2013. <span>“Auto-<span>WEKA</span>.”</span> In <em>Proceedings of the 19th <span>ACM</span> <span>SIGKDD</span> International Conference on Knowledge Discovery and Data Mining</em>. <span>ACM</span>. <a href="https://doi.org/10.1145/2487575.2487629">https://doi.org/10.1145/2487575.2487629</a>.
</div>
<div id="ref-Wolpert1992" class="csl-entry" role="listitem">
Wolpert, David H. 1992. <span>“Stacked Generalization.”</span> <em>Neural Networks</em> 5 (2): 241–59. <a href="https://doi.org/10.1016/S0893-6080(05)80023-1">https://doi.org/10.1016/S0893-6080(05)80023-1</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter7/sequential_pipelines.html" class="pagination-link" aria-label="Sequential Pipelines">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter9/preprocessing.html" class="pagination-link" aria-label="Preprocessing">
        <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Preprocessing</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb61" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="an">aliases:</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co">  - "/non-sequential_pipelines_and_tuning.html"</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="fu"># Non-sequential Pipelines and Tuning {#sec-pipelines-nonseq}</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_setup.qmd &gt;}}</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a><span class="in">`r chapter = "Non-sequential Pipelines and Tuning"`</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="in">`r authors(chapter)`</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-001, include = FALSE, cache = FALSE}</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3oml)</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a><span class="fu">dir.create</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"book"</span>, <span class="st">"openml"</span>), <span class="at">showWarnings =</span> <span class="cn">FALSE</span>, <span class="at">recursive =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a><span class="fu">options</span>(<span class="at">mlr3oml.cache =</span> here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"book"</span>, <span class="st">"openml"</span>, <span class="st">"cache"</span>))</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>In @sec-pipelines we looked at simple sequential pipelines that can be built using the <span class="in">`r ref("Graph")`</span> class and a few <span class="in">`r ref("PipeOp")`</span> objects.</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>In this chapter, we will take this further and look at non-sequential pipelines that can perform more complex operations.</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>We will then look at tuning pipelines by combining methods in <span class="in">`r mlr3tuning`</span> and <span class="in">`r mlr3pipelines`</span> and will consider some concrete examples using multi-fidelity tuning (@sec-hyperband) and feature selection (@sec-feature-selection).</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>We saw the power of the <span class="in">`%&gt;&gt;%`</span>-operator in @sec-pipelines to assemble graphs from combinations of multiple <span class="in">`PipeOp`</span>s and <span class="in">`Learner`</span>s.</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>Given a single <span class="in">`PipeOp`</span> or <span class="in">`r ref("Learner")`</span>, the <span class="in">`%&gt;&gt;%`</span>-operator will arrange these objects into a linear <span class="in">`Graph`</span> with each <span class="in">`PipeOp`</span> acting in sequence.</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>However, by using the <span class="in">`r ref("gunion()")`</span> function, we can instead combine multiple <span class="in">`PipeOp`</span>s, <span class="in">`Graph`</span>s, or a mixture of both, into a parallel <span class="in">`Graph`</span>.</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>In the following example, we create a <span class="in">`Graph`</span> that centers its inputs (<span class="in">`po("scale")`</span>) and then copies the centered data to two parallel streams: one replaces the data with columns that indicate whether data is missing (<span class="in">`po("missind")`</span>), and the other imputes missing data using the median (<span class="in">`po("imputemedian")`</span>), which we will return to in @sec-preprocessing-missing.</span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>The outputs of both streams are then combined into a single dataset using <span class="in">`po("featureunion")`</span>.</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-002, eval = FALSE}</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3pipelines)</span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"scale"</span>, <span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale =</span> <span class="cn">FALSE</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gunion</span>(<span class="fu">list</span>(</span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"missind"</span>),</span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"imputemedian"</span>)</span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>  )) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-003, fig.width = 8, eval = TRUE, echo = FALSE}</span></span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-parallel-plot</span></span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Simple parallel pipeline plot showing a common data source being scaled then the same data being passed to two `PipeOp`s in parallel whose outputs are combined and returned to the user.'</span></span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Six boxes where first two are "&lt;INPUT&gt; -&gt; scale", then "scale" has two arrows to "missind" and "imputemedian" which both have an arrow to "featureunion -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-46"><a href="#cb61-46" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3pipelines)</span>
<span id="cb61-47"><a href="#cb61-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-48"><a href="#cb61-48" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"scale"</span>, <span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale =</span> <span class="cn">FALSE</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-49"><a href="#cb61-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gunion</span>(<span class="fu">list</span>(</span>
<span id="cb61-50"><a href="#cb61-50" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"missind"</span>),</span>
<span id="cb61-51"><a href="#cb61-51" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"imputemedian"</span>)</span>
<span id="cb61-52"><a href="#cb61-52" aria-hidden="true" tabindex="-1"></a>  )) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-53"><a href="#cb61-53" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-54"><a href="#cb61-54" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">1500</span>, <span class="at">height =</span> <span class="dv">1000</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">24</span>)</span>
<span id="cb61-55"><a href="#cb61-55" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-56"><a href="#cb61-56" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-57"><a href="#cb61-57" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-58"><a href="#cb61-58" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-59"><a href="#cb61-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-60"><a href="#cb61-60" aria-hidden="true" tabindex="-1"></a>When applied to the first three rows of the <span class="in">`"pima"`</span> task we can see how this imputes missing data and adds a column indicating where values were missing.</span>
<span id="cb61-61"><a href="#cb61-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-62"><a href="#cb61-62" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-004, eval = TRUE}</span></span>
<span id="cb61-63"><a href="#cb61-63" aria-hidden="true" tabindex="-1"></a>tsk_pima_head <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"pima"</span>)<span class="sc">$</span><span class="fu">filter</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb61-64"><a href="#cb61-64" aria-hidden="true" tabindex="-1"></a>tsk_pima_head<span class="sc">$</span><span class="fu">data</span>(<span class="at">cols =</span> <span class="fu">c</span>(<span class="st">"diabetes"</span>, <span class="st">"insulin"</span>, <span class="st">"triceps"</span>))</span>
<span id="cb61-65"><a href="#cb61-65" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> graph<span class="sc">$</span><span class="fu">train</span>(tsk_pima_head)[[<span class="dv">1</span>]]</span>
<span id="cb61-66"><a href="#cb61-66" aria-hidden="true" tabindex="-1"></a>result<span class="sc">$</span><span class="fu">data</span>(<span class="at">cols =</span> <span class="fu">c</span>(<span class="st">"diabetes"</span>, <span class="st">"insulin"</span>, <span class="st">"missing_insulin"</span>, <span class="st">"triceps"</span>,</span>
<span id="cb61-67"><a href="#cb61-67" aria-hidden="true" tabindex="-1"></a>  <span class="st">"missing_triceps"</span>))</span>
<span id="cb61-68"><a href="#cb61-68" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-69"><a href="#cb61-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-70"><a href="#cb61-70" aria-hidden="true" tabindex="-1"></a><span class="fu">## Selectors and Parallel Pipelines</span></span>
<span id="cb61-71"><a href="#cb61-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-72"><a href="#cb61-72" aria-hidden="true" tabindex="-1"></a>It is common in <span class="in">`r ref("Graph")`</span>s for an operation to be applied to a subset of features.</span>
<span id="cb61-73"><a href="#cb61-73" aria-hidden="true" tabindex="-1"></a>In <span class="in">`mlr3pipelines`</span> this can be achieved in two ways (@fig-pipelines-select-affect): either by passing the column subset to the <span class="in">`affect_columns`</span> hyperparameter of a <span class="in">`r ref("PipeOp")`</span> (assuming it has that hyperparameter), which controls which columns should be affected by the <span class="in">`PipeOp`</span>; or, one can use the <span class="in">`r ref("PipeOpSelect", index = TRUE)`</span> operator to create operations in parallel on specified feature subsets, and then unite the result using <span class="in">`r ref("PipeOpFeatureUnion")`</span>.</span>
<span id="cb61-74"><a href="#cb61-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-75"><a href="#cb61-75" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-005, echo = FALSE, out.width = "70%"}</span></span>
<span id="cb61-76"><a href="#cb61-76" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-select-affect</span></span>
<span id="cb61-77"><a href="#cb61-77" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-nrow: 2</span></span>
<span id="cb61-78"><a href="#cb61-78" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Two methods of setting up `PipeOp`s (`po(op1)` and `po(op2)`) that operate on complementary features (X and ¬X) of an input task."</span></span>
<span id="cb61-79"><a href="#cb61-79" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Top plot shows the sequential pipeline "po(op1, affected_columns: ¬X") -&gt; po(op2, affected_columns: X"). Bottom plot shows the parallel pipeline that starts with an arrow splitting and then pointing to both  po("select", ¬X) and po("select", X). These respectively point to po(op1) and po(op2), which then both point to the same po("featureunion").'</span></span>
<span id="cb61-80"><a href="#cb61-80" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb61-81"><a href="#cb61-81" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - 'The `affect_columns` hyperparameter can be used to restrict operations to a subset of features. When used, pipelines may still be run in sequence.'</span></span>
<span id="cb61-82"><a href="#cb61-82" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - 'Operating on subsets of tasks using concurrent paths by first splitting the inputs with `po("select")` and then combining outputs with `po("featureunion")`.'</span></span>
<span id="cb61-83"><a href="#cb61-83" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-28"</span>)</span>
<span id="cb61-84"><a href="#cb61-84" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-29"</span>)</span>
<span id="cb61-85"><a href="#cb61-85" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-86"><a href="#cb61-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-87"><a href="#cb61-87" aria-hidden="true" tabindex="-1"></a>Both methods make use of <span class="in">`r ref("Selector", aside = TRUE)`</span>-functions.</span>
<span id="cb61-88"><a href="#cb61-88" aria-hidden="true" tabindex="-1"></a>These are helper functions that indicate to a <span class="in">`PipeOp`</span> which features it should apply to.</span>
<span id="cb61-89"><a href="#cb61-89" aria-hidden="true" tabindex="-1"></a><span class="in">`Selectors`</span> may match column names by regular expressions (<span class="in">`r ref("selector_grep()")`</span>), or by column type (<span class="in">`r ref("selector_type()")`</span>).</span>
<span id="cb61-90"><a href="#cb61-90" aria-hidden="true" tabindex="-1"></a><span class="in">`Selectors`</span> can also be used to join variables (<span class="in">`r ref("selector_union()")`</span>), return their set difference (<span class="in">`r ref("selector_setdiff()")`</span>), or select the complement of features from another <span class="in">`Selector`</span> (<span class="in">`r ref("selector_invert()")`</span>).</span>
<span id="cb61-91"><a href="#cb61-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-92"><a href="#cb61-92" aria-hidden="true" tabindex="-1"></a>For example, in @sec-pipelines-pipeops we applied PCA to the bill length and depth of penguins from <span class="in">`tsk("penguins_simple")`</span> by first selecting these columns using the <span class="in">`Task`</span> method <span class="in">`$select()`</span> and then applying the <span class="in">`PipeOp`</span>.</span>
<span id="cb61-93"><a href="#cb61-93" aria-hidden="true" tabindex="-1"></a>We can now do this more simply with <span class="in">`selector_grep`</span>, and could go on to use <span class="in">`selector_invert`</span> to apply some other <span class="in">`PipeOp`</span> to other features, below we use <span class="in">`po("scale")`</span> and make use of the <span class="in">`affect_columns`</span> hyperparameter:</span>
<span id="cb61-94"><a href="#cb61-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-95"><a href="#cb61-95" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-006, eval = TRUE}</span></span>
<span id="cb61-96"><a href="#cb61-96" aria-hidden="true" tabindex="-1"></a>sel_bill <span class="ot">=</span> <span class="fu">selector_grep</span>(<span class="st">"^bill"</span>)</span>
<span id="cb61-97"><a href="#cb61-97" aria-hidden="true" tabindex="-1"></a>sel_not_bill <span class="ot">=</span> <span class="fu">selector_invert</span>(sel_bill)</span>
<span id="cb61-98"><a href="#cb61-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-99"><a href="#cb61-99" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"scale"</span>, <span class="at">affect_columns =</span> sel_not_bill) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-100"><a href="#cb61-100" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">affect_columns =</span> sel_bill)</span>
<span id="cb61-101"><a href="#cb61-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-102"><a href="#cb61-102" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> graph<span class="sc">$</span><span class="fu">train</span>(<span class="fu">tsk</span>(<span class="st">"penguins_simple"</span>))</span>
<span id="cb61-103"><a href="#cb61-103" aria-hidden="true" tabindex="-1"></a>result[[<span class="dv">1</span>]]<span class="sc">$</span><span class="fu">data</span>()[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb61-104"><a href="#cb61-104" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-105"><a href="#cb61-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-106"><a href="#cb61-106" aria-hidden="true" tabindex="-1"></a>The biggest advantage of this method is that it creates a very simple, sequential <span class="in">`Graph`</span>.</span>
<span id="cb61-107"><a href="#cb61-107" aria-hidden="true" tabindex="-1"></a>However, one disadvantage of the <span class="in">`affect_columns`</span> method is that it is relatively easy to have unexpected results if the ordering of <span class="in">`PipeOp`</span>s is mixed up.</span>
<span id="cb61-108"><a href="#cb61-108" aria-hidden="true" tabindex="-1"></a>For example, if we had reversed the order of <span class="in">`po("pca")`</span> and <span class="in">`po("scale")`</span> above then we would have first created columns <span class="in">`"PC1"`</span> and <span class="in">`"PC2"`</span> and then erroneously scaled these, since their names do not start with "bill" and they are therefore matched by <span class="in">`sel_not_bill`</span>.</span>
<span id="cb61-109"><a href="#cb61-109" aria-hidden="true" tabindex="-1"></a>Creating parallel paths with <span class="in">`po("select")`</span> can help mitigate such errors by selecting features given by the <span class="in">`Selector`</span> and creating independent data processing streams with the given feature subset.</span>
<span id="cb61-110"><a href="#cb61-110" aria-hidden="true" tabindex="-1"></a>Below we pass the parallel pipelines to <span class="in">`r ref("gunion()")`</span> as a <span class="in">`list`</span> to ensure they receive the same input, and then combine the outputs with <span class="in">`po("featureunion")`</span>.</span>
<span id="cb61-111"><a href="#cb61-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-112"><a href="#cb61-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-007, eval = FALSE}</span></span>
<span id="cb61-113"><a href="#cb61-113" aria-hidden="true" tabindex="-1"></a>po_select_bill <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"select"</span>, <span class="at">id =</span> <span class="st">"s_bill"</span>, <span class="at">selector =</span> sel_bill)</span>
<span id="cb61-114"><a href="#cb61-114" aria-hidden="true" tabindex="-1"></a>po_select_not_bill <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"select"</span>, <span class="at">id =</span> <span class="st">"s_notbill"</span>,</span>
<span id="cb61-115"><a href="#cb61-115" aria-hidden="true" tabindex="-1"></a>  <span class="at">selector =</span> sel_not_bill)</span>
<span id="cb61-116"><a href="#cb61-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-117"><a href="#cb61-117" aria-hidden="true" tabindex="-1"></a>path_pca <span class="ot">=</span>  po_select_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"pca"</span>)</span>
<span id="cb61-118"><a href="#cb61-118" aria-hidden="true" tabindex="-1"></a>path_scale <span class="ot">=</span> po_select_not_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"scale"</span>)</span>
<span id="cb61-119"><a href="#cb61-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-120"><a href="#cb61-120" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">gunion</span>(<span class="fu">list</span>(path_pca, path_scale)) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-121"><a href="#cb61-121" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-122"><a href="#cb61-122" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-123"><a href="#cb61-123" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-008, fig.width = 8, eval = TRUE, echo = FALSE}</span></span>
<span id="cb61-124"><a href="#cb61-124" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-pcascale</span></span>
<span id="cb61-125"><a href="#cb61-125" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Visualization of a `Graph` where features are split into two paths, one with PCA and one with scaling, then combined and returned.</span></span>
<span id="cb61-126"><a href="#cb61-126" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Seven boxes where first is "&lt;INPUT&gt;" which points to "s_bill -&gt; pca" and "s_notbill" -&gt; scale", then both "pca" and "scale" point to "featureunion -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-127"><a href="#cb61-127" aria-hidden="true" tabindex="-1"></a>po_select_bill <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"select"</span>, <span class="at">id =</span> <span class="st">"s_bill"</span>, <span class="at">selector =</span> sel_bill)</span>
<span id="cb61-128"><a href="#cb61-128" aria-hidden="true" tabindex="-1"></a>po_select_not_bill <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"select"</span>, <span class="at">id =</span> <span class="st">"s_notbill"</span>,</span>
<span id="cb61-129"><a href="#cb61-129" aria-hidden="true" tabindex="-1"></a>  <span class="at">selector =</span> sel_not_bill)</span>
<span id="cb61-130"><a href="#cb61-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-131"><a href="#cb61-131" aria-hidden="true" tabindex="-1"></a>path_pca <span class="ot">=</span>  po_select_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"pca"</span>)</span>
<span id="cb61-132"><a href="#cb61-132" aria-hidden="true" tabindex="-1"></a>path_scale <span class="ot">=</span> po_select_not_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"scale"</span>)</span>
<span id="cb61-133"><a href="#cb61-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-134"><a href="#cb61-134" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">gunion</span>(<span class="fu">list</span>(path_pca, path_scale)) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-135"><a href="#cb61-135" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">1500</span>, <span class="at">height =</span> <span class="dv">1000</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">24</span>)</span>
<span id="cb61-136"><a href="#cb61-136" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-137"><a href="#cb61-137" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-138"><a href="#cb61-138" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-139"><a href="#cb61-139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-140"><a href="#cb61-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-141"><a href="#cb61-141" aria-hidden="true" tabindex="-1"></a>The <span class="in">`po("select")`</span> method also has the significant advantage that it allows the same set of features to be used in multiple operations simultaneously, or to both transform features and keep their untransformed versions (by using <span class="in">`po("nop")`</span> in one path).</span>
<span id="cb61-142"><a href="#cb61-142" aria-hidden="true" tabindex="-1"></a><span class="in">`r ref("PipeOpNOP")`</span> performs no operation on its inputs and is thus useful when you only want to perform a transformation on a subset of features and leave the others untouched:</span>
<span id="cb61-143"><a href="#cb61-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-144"><a href="#cb61-144" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-009, eval = FALSE}</span></span>
<span id="cb61-145"><a href="#cb61-145" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">gunion</span>(<span class="fu">list</span>(</span>
<span id="cb61-146"><a href="#cb61-146" aria-hidden="true" tabindex="-1"></a>  po_select_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"scale"</span>),</span>
<span id="cb61-147"><a href="#cb61-147" aria-hidden="true" tabindex="-1"></a>  po_select_not_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"nop"</span>)</span>
<span id="cb61-148"><a href="#cb61-148" aria-hidden="true" tabindex="-1"></a>)) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-149"><a href="#cb61-149" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-150"><a href="#cb61-150" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-151"><a href="#cb61-151" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-010, fig.width = 8, eval = TRUE, echo = FALSE}</span></span>
<span id="cb61-152"><a href="#cb61-152" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-selectnop</span></span>
<span id="cb61-153"><a href="#cb61-153" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Visualization of our `Graph` where features are split into two paths, features that start with 'bill' are scaled and the rest are untransformed.</span></span>
<span id="cb61-154"><a href="#cb61-154" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Seven boxes where first is "&lt;INPUT&gt;" which points to "s_bill -&gt; scale" and "s_notbill -&gt; nop", then both "scale" and "nop" point to "featureunion -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-155"><a href="#cb61-155" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">gunion</span>(<span class="fu">list</span>(</span>
<span id="cb61-156"><a href="#cb61-156" aria-hidden="true" tabindex="-1"></a>  po_select_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"scale"</span>),</span>
<span id="cb61-157"><a href="#cb61-157" aria-hidden="true" tabindex="-1"></a>  po_select_not_bill <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"nop"</span>)</span>
<span id="cb61-158"><a href="#cb61-158" aria-hidden="true" tabindex="-1"></a>)) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-159"><a href="#cb61-159" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">1500</span>, <span class="at">height =</span> <span class="dv">1000</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">24</span>)</span>
<span id="cb61-160"><a href="#cb61-160" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-161"><a href="#cb61-161" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-162"><a href="#cb61-162" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-163"><a href="#cb61-163" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-164"><a href="#cb61-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-165"><a href="#cb61-165" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-011, eval = TRUE}</span></span>
<span id="cb61-166"><a href="#cb61-166" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">train</span>(<span class="fu">tsk</span>(<span class="st">"penguins_simple"</span>))[[<span class="dv">1</span>]]<span class="sc">$</span><span class="fu">data</span>()[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb61-167"><a href="#cb61-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-168"><a href="#cb61-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-169"><a href="#cb61-169" aria-hidden="true" tabindex="-1"></a><span class="fu">##  Common Patterns and ppl() {#sec-pipelines-ppl}</span></span>
<span id="cb61-170"><a href="#cb61-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-171"><a href="#cb61-171" aria-hidden="true" tabindex="-1"></a>Now you have the tools to create sequential and non-sequential pipelines, you can create an infinite number of transformations on <span class="in">`r ref("Task")`</span>, <span class="in">`r ref("Learner")`</span>, and <span class="in">`r ref("Prediction")`</span> objects.</span>
<span id="cb61-172"><a href="#cb61-172" aria-hidden="true" tabindex="-1"></a>In @sec-pipelines-bagging and @sec-pipelines-stack we will work through two examples to demonstrate how you can make complex and powerful graphs using the methods and classes we have already looked at.</span>
<span id="cb61-173"><a href="#cb61-173" aria-hidden="true" tabindex="-1"></a>However, many common problems in ML can be well solved by the same pipelines, and so to make your life easier we have implemented and saved these pipelines in the <span class="in">`r ref("mlr_graphs", index = TRUE)`</span> dictionary; pipelines in the dictionary can be accessed with the <span class="in">`r ref("ppl()", aside = TRUE)`</span> sugar function.</span>
<span id="cb61-174"><a href="#cb61-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-175"><a href="#cb61-175" aria-hidden="true" tabindex="-1"></a>At the time of writing, this dictionary includes seven <span class="in">`r ref("Graph")`</span>s (required arguments included below):</span>
<span id="cb61-176"><a href="#cb61-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-177"><a href="#cb61-177" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("bagging", graph)`</span>: In <span class="in">`mlr3pipelines`</span>, <span class="in">`r index('bagging')`</span> is the process of running a <span class="in">`graph`</span> multiple times on different data samples and then averaging the results. This is discussed in detail in @sec-pipelines-bagging.</span>
<span id="cb61-178"><a href="#cb61-178" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("branch", graphs)`</span>: Uses <span class="in">`r ref("PipeOpBranch")`</span> to create different path branches from the given <span class="in">`graphs`</span> where only one branch is evaluated. This is returned to in more detail in @sec-pipelines-branch.</span>
<span id="cb61-179"><a href="#cb61-179" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("greplicate", graph, n)`</span>: Create a <span class="in">`Graph`</span> that replicates <span class="in">`graph`</span> (which can also be a single <span class="in">`PipeOp`</span>) <span class="in">`n`</span> times. The pipeline avoids ID clashes by adding a suffix to each <span class="in">`PipeOp`</span>, we will see this pipeline in use in @sec-pipelines-bagging.</span>
<span id="cb61-180"><a href="#cb61-180" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("ovr", graph)`</span>: <span class="in">`r index('One-versus-rest classification')`</span> for converting <span class="in">`r index('multiclass classification', 'multiclass', parent = 'classification')`</span> tasks into several binary classification tasks with one task for each class in the original. These tasks are then evaluated by the given <span class="in">`graph`</span>, which should be a learner (or a pipeline containing a learner that emits a prediction). The predictions made on the binary tasks are combined into the multiclass prediction needed for the original task.</span>
<span id="cb61-181"><a href="#cb61-181" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("robustify")`</span>: Performs common preprocessing steps to make any <span class="in">`Task`</span> compatible with a given <span class="in">`Learner`</span>. This pipeline is demonstrated in @sec-prepro-robustify.</span>
<span id="cb61-182"><a href="#cb61-182" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("stacking", base_learners, super_learner)`</span>: <span class="in">`r index('Stacking')`</span>, returned to in detail in @sec-pipelines-stack, is the process of using predictions from one or more models (<span class="in">`base_learners`</span>) as features in a subsequent model (<span class="in">`super_learner`</span>)</span>
<span id="cb61-183"><a href="#cb61-183" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`ppl("targettrafo", graph)`</span>: Create a <span class="in">`Graph`</span> that transforms the prediction target of a task and ensures that any transformations applied during training (using the function passed to the <span class="in">`targetmutate.trafo`</span> hyperparameter) are inverted in the resulting predictions (using the function passed to the <span class="in">`targetmutate.inverter`</span> hyperparameter); an example is given in @sec-prepro-scale.</span>
<span id="cb61-184"><a href="#cb61-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-185"><a href="#cb61-185" aria-hidden="true" tabindex="-1"></a><span class="fu">## Practical Pipelines by Example</span></span>
<span id="cb61-186"><a href="#cb61-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-187"><a href="#cb61-187" aria-hidden="true" tabindex="-1"></a>In this section, we will put pipelines into practice by demonstrating how to turn weak learners into powerful machine learning models using <span class="in">`r index('bagging')`</span> and <span class="in">`r index('stacking')`</span>.</span>
<span id="cb61-188"><a href="#cb61-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-189"><a href="#cb61-189" aria-hidden="true" tabindex="-1"></a><span class="fu">### Bagging with "greplicate" and "subsample" {#sec-pipelines-bagging}</span></span>
<span id="cb61-190"><a href="#cb61-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-191"><a href="#cb61-191" aria-hidden="true" tabindex="-1"></a>The basic idea of <span class="in">`r index('bagging')`</span> (from **b**ootstrapp **agg**regat**ing**), introduced by @Breiman1996, is to aggregate multiple predictors into a single, more powerful predictor (@fig-pipelines-bagging).</span>
<span id="cb61-192"><a href="#cb61-192" aria-hidden="true" tabindex="-1"></a>Predictions are usually aggregated by the arithmetic mean for regression tasks or majority vote for classification.</span>
<span id="cb61-193"><a href="#cb61-193" aria-hidden="true" tabindex="-1"></a>The underlying intuition behind bagging is that averaging a set of unstable and diverse (i.e., only weakly correlated) predictors can reduce the variance of the overall prediction.</span>
<span id="cb61-194"><a href="#cb61-194" aria-hidden="true" tabindex="-1"></a>Each learner is trained on a different random sample of the original data.</span>
<span id="cb61-195"><a href="#cb61-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-196"><a href="#cb61-196" aria-hidden="true" tabindex="-1"></a>Although we have already seen that a pre-constructed bagging pipeline is available with <span class="in">`ppl("bagging")`</span>, in this section we will build our own pipeline from scratch to showcase how to construct a complex <span class="in">`r ref("Graph")`</span>, which will look something like @fig-pipelines-bagging.</span>
<span id="cb61-197"><a href="#cb61-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-198"><a href="#cb61-198" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-012, echo = FALSE, out.width = "70%"}</span></span>
<span id="cb61-199"><a href="#cb61-199" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-bagging</span></span>
<span id="cb61-200"><a href="#cb61-200" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Graph that performs Bagging by independently subsampling data and fitting individual decision tree learners. The resulting predictions are aggregated by a majority vote `PipeOp`."</span></span>
<span id="cb61-201"><a href="#cb61-201" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph shows "Dtrain" with arrows to four separate po("subsample") boxes that each have a separate arrow to four more po("classif.rpart") boxes that each have an arrow to the same one po("classif.avg") box.'</span></span>
<span id="cb61-202"><a href="#cb61-202" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-26"</span>)</span>
<span id="cb61-203"><a href="#cb61-203" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-204"><a href="#cb61-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-205"><a href="#cb61-205" aria-hidden="true" tabindex="-1"></a>To begin, we use <span class="in">`po("subsample")`</span> to sample a fraction of the data (here 70%), which is then passed to a classification tree (note by default <span class="in">`po("subsample")`</span> samples without replacement).</span>
<span id="cb61-206"><a href="#cb61-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-207"><a href="#cb61-207" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-013, eval = TRUE}</span></span>
<span id="cb61-208"><a href="#cb61-208" aria-hidden="true" tabindex="-1"></a>gr_single_pred <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"subsample"</span>, <span class="at">frac =</span> <span class="fl">0.7</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb61-209"><a href="#cb61-209" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-210"><a href="#cb61-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-211"><a href="#cb61-211" aria-hidden="true" tabindex="-1"></a>Next, we use <span class="in">`ppl("greplicate")`</span> to copy the graph, <span class="in">`gr_single_pred`</span>, 10 times (<span class="in">`n = 10`</span>) and finally <span class="in">`po("classifavg")`</span> to take the majority vote of all predictions, note that we pass <span class="in">`innum = 10`</span> to <span class="in">`"classifavg"`</span> to tell the <span class="in">`r ref("PipeOp")`</span> to expect 10 inputs.</span>
<span id="cb61-212"><a href="#cb61-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-213"><a href="#cb61-213" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-014, eval = FALSE}</span></span>
<span id="cb61-214"><a href="#cb61-214" aria-hidden="true" tabindex="-1"></a>gr_pred_set <span class="ot">=</span> <span class="fu">ppl</span>(<span class="st">"greplicate"</span>, <span class="at">graph =</span> gr_single_pred, <span class="at">n =</span> <span class="dv">10</span>)</span>
<span id="cb61-215"><a href="#cb61-215" aria-hidden="true" tabindex="-1"></a>gr_bagging <span class="ot">=</span> gr_pred_set <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"classifavg"</span>, <span class="at">innum =</span> <span class="dv">10</span>)</span>
<span id="cb61-216"><a href="#cb61-216" aria-hidden="true" tabindex="-1"></a>gr_bagging<span class="sc">$</span><span class="fu">plot</span>()</span>
<span id="cb61-217"><a href="#cb61-217" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-218"><a href="#cb61-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-219"><a href="#cb61-219" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-015, echo = FALSE}</span></span>
<span id="cb61-220"><a href="#cb61-220" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-bagginggraph</span></span>
<span id="cb61-221"><a href="#cb61-221" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Constructed bagging `Graph` with one input being sampled many times for 10 different learners.</span></span>
<span id="cb61-222"><a href="#cb61-222" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Parallel pipeline showing "&lt;INPUT&gt;" pointing to ten PipeOps "subsample_1",...,"subsample_10" that each separately point to "classif.rpart_1",...,"classif.rpart_10" respectively, which all point to the same "classifavg -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-223"><a href="#cb61-223" aria-hidden="true" tabindex="-1"></a>gr_pred_set <span class="ot">=</span> <span class="fu">ppl</span>(<span class="st">"greplicate"</span>, <span class="at">graph =</span> gr_single_pred, <span class="at">n =</span> <span class="dv">10</span>)</span>
<span id="cb61-224"><a href="#cb61-224" aria-hidden="true" tabindex="-1"></a>gr_bagging <span class="ot">=</span> gr_pred_set <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"classifavg"</span>, <span class="at">innum =</span> <span class="dv">10</span>)</span>
<span id="cb61-225"><a href="#cb61-225" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">2000</span>, <span class="at">height =</span> <span class="dv">1000</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">17</span>)</span>
<span id="cb61-226"><a href="#cb61-226" aria-hidden="true" tabindex="-1"></a>gr_bagging<span class="sc">$</span><span class="fu">plot</span>()</span>
<span id="cb61-227"><a href="#cb61-227" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-228"><a href="#cb61-228" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-229"><a href="#cb61-229" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-230"><a href="#cb61-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-231"><a href="#cb61-231" aria-hidden="true" tabindex="-1"></a>Now let us see how well our bagging pipeline compares to the single decision tree and a random forest when benchmarked against <span class="in">`tsk("sonar")`</span>.</span>
<span id="cb61-232"><a href="#cb61-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-233"><a href="#cb61-233" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-016}</span></span>
<span id="cb61-234"><a href="#cb61-234" aria-hidden="true" tabindex="-1"></a><span class="co"># turn graph into learner</span></span>
<span id="cb61-235"><a href="#cb61-235" aria-hidden="true" tabindex="-1"></a>glrn_bagging <span class="ot">=</span> <span class="fu">as_learner</span>(gr_bagging)</span>
<span id="cb61-236"><a href="#cb61-236" aria-hidden="true" tabindex="-1"></a>glrn_bagging<span class="sc">$</span>id <span class="ot">=</span> <span class="st">"bagging"</span></span>
<span id="cb61-237"><a href="#cb61-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-238"><a href="#cb61-238" aria-hidden="true" tabindex="-1"></a>lrn_rpart <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb61-239"><a href="#cb61-239" aria-hidden="true" tabindex="-1"></a>learners <span class="ot">=</span> <span class="fu">c</span>(glrn_bagging, lrn_rpart, <span class="fu">lrn</span>(<span class="st">"classif.ranger"</span>))</span>
<span id="cb61-240"><a href="#cb61-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-241"><a href="#cb61-241" aria-hidden="true" tabindex="-1"></a>bmr <span class="ot">=</span> <span class="fu">benchmark</span>(<span class="fu">benchmark_grid</span>(<span class="fu">tsk</span>(<span class="st">"sonar"</span>), learners,</span>
<span id="cb61-242"><a href="#cb61-242" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>)))</span>
<span id="cb61-243"><a href="#cb61-243" aria-hidden="true" tabindex="-1"></a>bmr<span class="sc">$</span><span class="fu">aggregate</span>()[, .(learner_id, classif.ce)]</span>
<span id="cb61-244"><a href="#cb61-244" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-245"><a href="#cb61-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-246"><a href="#cb61-246" aria-hidden="true" tabindex="-1"></a>The bagged learner performs better than the decision tree but worse than the random forest.</span>
<span id="cb61-247"><a href="#cb61-247" aria-hidden="true" tabindex="-1"></a>To automatically recreate this pipeline, you can construct <span class="in">`ppl("bagging")`</span> by specifying the learner to 'bag', the number of iterations, the fraction of data to sample, and the <span class="in">`r ref("PipeOp")`</span> to average the predictions, as shown in the code below.</span>
<span id="cb61-248"><a href="#cb61-248" aria-hidden="true" tabindex="-1"></a>Note we set <span class="in">`collect_multiplicity = TRUE`</span> which collects the predictions across paths, that technically use the <span class="in">`r ref("Multiplicity")`</span> method, which we will not discuss here but refer the reader to the documentation.</span>
<span id="cb61-249"><a href="#cb61-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-250"><a href="#cb61-250" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-017, eval = FALSE}</span></span>
<span id="cb61-251"><a href="#cb61-251" aria-hidden="true" tabindex="-1"></a><span class="fu">ppl</span>(<span class="st">"bagging"</span>, <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb61-252"><a href="#cb61-252" aria-hidden="true" tabindex="-1"></a>  <span class="at">iterations =</span> <span class="dv">10</span>, <span class="at">frac =</span> <span class="fl">0.7</span>,</span>
<span id="cb61-253"><a href="#cb61-253" aria-hidden="true" tabindex="-1"></a>  <span class="at">averager =</span> <span class="fu">po</span>(<span class="st">"classifavg"</span>, <span class="at">collect_multiplicity =</span> <span class="cn">TRUE</span>))</span>
<span id="cb61-254"><a href="#cb61-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-255"><a href="#cb61-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-256"><a href="#cb61-256" aria-hidden="true" tabindex="-1"></a>The main difference between our pipeline and a random forest is that the latter also performs feature subsampling, where only a random subset of available features is considered at each split point.</span>
<span id="cb61-257"><a href="#cb61-257" aria-hidden="true" tabindex="-1"></a>While we cannot implement this directly with <span class="in">`mlr3pipelines`</span>, we can use a custom <span class="in">`r ref("Selector")`</span> method to approximate this method.</span>
<span id="cb61-258"><a href="#cb61-258" aria-hidden="true" tabindex="-1"></a>We will create this <span class="in">`Selector`</span> by passing a function that takes as input the task and returns a sample of the features, we sample the square root of the number of features to mimic the implementation in <span class="in">`r ref("ranger::ranger")`</span>.</span>
<span id="cb61-259"><a href="#cb61-259" aria-hidden="true" tabindex="-1"></a>For efficiency, we will now use <span class="in">`ppl("bagging")`</span> to recreate the steps above:</span>
<span id="cb61-260"><a href="#cb61-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-261"><a href="#cb61-261" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-018}</span></span>
<span id="cb61-262"><a href="#cb61-262" aria-hidden="true" tabindex="-1"></a><span class="co"># custom selector</span></span>
<span id="cb61-263"><a href="#cb61-263" aria-hidden="true" tabindex="-1"></a>selector_subsample <span class="ot">=</span> <span class="cf">function</span>(task) {</span>
<span id="cb61-264"><a href="#cb61-264" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sample</span>(task<span class="sc">$</span>feature_names, <span class="fu">sqrt</span>(<span class="fu">length</span>(task<span class="sc">$</span>feature_names)))</span>
<span id="cb61-265"><a href="#cb61-265" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb61-266"><a href="#cb61-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-267"><a href="#cb61-267" aria-hidden="true" tabindex="-1"></a><span class="co"># bagging pipeline with our selector</span></span>
<span id="cb61-268"><a href="#cb61-268" aria-hidden="true" tabindex="-1"></a>gr_bagging_quasi_rf <span class="ot">=</span> <span class="fu">ppl</span>(<span class="st">"bagging"</span>,</span>
<span id="cb61-269"><a href="#cb61-269" aria-hidden="true" tabindex="-1"></a>  <span class="at">graph =</span> <span class="fu">po</span>(<span class="st">"select"</span>, <span class="at">selector =</span> selector_subsample) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-270"><a href="#cb61-270" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>, <span class="at">minsplit =</span> <span class="dv">1</span>),</span>
<span id="cb61-271"><a href="#cb61-271" aria-hidden="true" tabindex="-1"></a>  <span class="at">iterations =</span> <span class="dv">100</span>,</span>
<span id="cb61-272"><a href="#cb61-272" aria-hidden="true" tabindex="-1"></a>  <span class="at">averager =</span> <span class="fu">po</span>(<span class="st">"classifavg"</span>, <span class="at">collect_multiplicity =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-273"><a href="#cb61-273" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-274"><a href="#cb61-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-275"><a href="#cb61-275" aria-hidden="true" tabindex="-1"></a><span class="co"># bootstrap resampling</span></span>
<span id="cb61-276"><a href="#cb61-276" aria-hidden="true" tabindex="-1"></a>gr_bagging_quasi_rf<span class="sc">$</span>param_set<span class="sc">$</span>values<span class="sc">$</span>subsample.replace <span class="ot">=</span> <span class="cn">TRUE</span></span>
<span id="cb61-277"><a href="#cb61-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-278"><a href="#cb61-278" aria-hidden="true" tabindex="-1"></a><span class="co"># convert to learner</span></span>
<span id="cb61-279"><a href="#cb61-279" aria-hidden="true" tabindex="-1"></a>glrn_quasi_rf <span class="ot">=</span> <span class="fu">as_learner</span>(gr_bagging_quasi_rf)</span>
<span id="cb61-280"><a href="#cb61-280" aria-hidden="true" tabindex="-1"></a>glrn_quasi_rf<span class="sc">$</span>id <span class="ot">=</span> <span class="st">"quasi.rf"</span></span>
<span id="cb61-281"><a href="#cb61-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-282"><a href="#cb61-282" aria-hidden="true" tabindex="-1"></a><span class="co"># benchmark</span></span>
<span id="cb61-283"><a href="#cb61-283" aria-hidden="true" tabindex="-1"></a>design <span class="ot">=</span> <span class="fu">benchmark_grid</span>(<span class="fu">tsks</span>(<span class="st">"sonar"</span>),</span>
<span id="cb61-284"><a href="#cb61-284" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(glrn_quasi_rf, <span class="fu">lrn</span>(<span class="st">"classif.ranger"</span>, <span class="at">num.trees =</span> <span class="dv">100</span>)),</span>
<span id="cb61-285"><a href="#cb61-285" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">5</span>)</span>
<span id="cb61-286"><a href="#cb61-286" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-287"><a href="#cb61-287" aria-hidden="true" tabindex="-1"></a>bmr <span class="ot">=</span> <span class="fu">benchmark</span>(design)</span>
<span id="cb61-288"><a href="#cb61-288" aria-hidden="true" tabindex="-1"></a>bmr<span class="sc">$</span><span class="fu">aggregate</span>()[, .(learner_id, classif.ce)]</span>
<span id="cb61-289"><a href="#cb61-289" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-290"><a href="#cb61-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-291"><a href="#cb61-291" aria-hidden="true" tabindex="-1"></a>In only a few lines of code, we took a weaker learner and turned it into a powerful model that we can see is comparable to the implementation in <span class="in">`ranger::ranger`</span>.</span>
<span id="cb61-292"><a href="#cb61-292" aria-hidden="true" tabindex="-1"></a>In the next section, we will look at a second example, which makes use of cross-validation within pipelines.</span>
<span id="cb61-293"><a href="#cb61-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-294"><a href="#cb61-294" aria-hidden="true" tabindex="-1"></a><span class="fu">### Stacking with po("learner_cv") {#sec-pipelines-stack}</span></span>
<span id="cb61-295"><a href="#cb61-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-296"><a href="#cb61-296" aria-hidden="true" tabindex="-1"></a><span class="in">`r index('Stacking')`</span> <span class="co">[</span><span class="ot">@Wolpert1992</span><span class="co">]</span> is another very popular ensembling technique that can significantly improve predictive performance.</span>
<span id="cb61-297"><a href="#cb61-297" aria-hidden="true" tabindex="-1"></a>The basic idea behind stacking is to use predictions from multiple models (usually referred to as level 0 models) as features for a subsequent model (the level 1 model) which in turn combines these predictions (@fig-pipelines-stacking).</span>
<span id="cb61-298"><a href="#cb61-298" aria-hidden="true" tabindex="-1"></a>A simple combination can be a linear model (possibly regularized if you have many level 0 models), since a weighted sum of level 0 models is often plausible and good enough.</span>
<span id="cb61-299"><a href="#cb61-299" aria-hidden="true" tabindex="-1"></a>Though, non-linear level 1 models can also be used, and it is also possible for the level 1 model to access the input features as well as the level 0 predictions.</span>
<span id="cb61-300"><a href="#cb61-300" aria-hidden="true" tabindex="-1"></a>Stacking can be built with more than two levels (both conceptually, and in <span class="in">`mlr3`</span>) but we limit ourselves to this simpler setup here, which often also performs well in practice.</span>
<span id="cb61-301"><a href="#cb61-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-302"><a href="#cb61-302" aria-hidden="true" tabindex="-1"></a>As with bagging, we will demonstrate how to create a stacking pipeline manually, although a pre-constructed pipeline is available with <span class="in">`ppl("stacking")`</span>.</span>
<span id="cb61-303"><a href="#cb61-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-304"><a href="#cb61-304" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-019, echo = FALSE, out.width = "70%"}</span></span>
<span id="cb61-305"><a href="#cb61-305" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-stacking</span></span>
<span id="cb61-306"><a href="#cb61-306" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Graph that performs Stacking by fitting three models and using their outputs as features for another model after combining with `PipeOpFeatureUnion`."</span></span>
<span id="cb61-307"><a href="#cb61-307" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph shows "Dtrain" with arrows to three boxes: "Decision Tree", "KNN", and "Lasso Regression". Each of these points to the same "Feature Union -&gt; Logistic Regression".'</span></span>
<span id="cb61-308"><a href="#cb61-308" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-27"</span>)</span>
<span id="cb61-309"><a href="#cb61-309" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-310"><a href="#cb61-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-311"><a href="#cb61-311" aria-hidden="true" tabindex="-1"></a>Stacking pipelines depend on the level 0 learners returning predictions during the <span class="in">`$train()`</span> phase.</span>
<span id="cb61-312"><a href="#cb61-312" aria-hidden="true" tabindex="-1"></a>This is possible in <span class="in">`mlr3pipelines`</span> with <span class="in">`r ref("PipeOpLearnerCV", index = TRUE)`</span>.</span>
<span id="cb61-313"><a href="#cb61-313" aria-hidden="true" tabindex="-1"></a>During training, this operator performs cross-validation and passes the out-of-sample predictions to the level 1 model.</span>
<span id="cb61-314"><a href="#cb61-314" aria-hidden="true" tabindex="-1"></a>Using cross-validated predictions is recommended to reduce the risk of overfitting.</span>
<span id="cb61-315"><a href="#cb61-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-316"><a href="#cb61-316" aria-hidden="true" tabindex="-1"></a>We first create the level 0 learners to produce the predictions that will be used as features.</span>
<span id="cb61-317"><a href="#cb61-317" aria-hidden="true" tabindex="-1"></a>In this example, we use a classification tree\index{decision tree}, <span class="in">`r index('k-nearest neighbors')`</span> (KNN)\index{KNN|see{k-nearest neighbors}}, and a regularized GLM\index{generalized linear model}.</span>
<span id="cb61-318"><a href="#cb61-318" aria-hidden="true" tabindex="-1"></a>Each learner is wrapped in <span class="in">`po("learner_cv")`</span> which performs cross-validation on the input data and then outputs the predictions from the <span class="in">`r ref("Learner")`</span> in a new <span class="in">`r ref("Task")`</span> object.</span>
<span id="cb61-319"><a href="#cb61-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-320"><a href="#cb61-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-020}</span></span>
<span id="cb61-321"><a href="#cb61-321" aria-hidden="true" tabindex="-1"></a>lrn_rpart <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>, <span class="at">predict_type =</span> <span class="st">"prob"</span>)</span>
<span id="cb61-322"><a href="#cb61-322" aria-hidden="true" tabindex="-1"></a>po_rpart_cv <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"learner_cv"</span>, <span class="at">learner =</span> lrn_rpart,</span>
<span id="cb61-323"><a href="#cb61-323" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling.folds =</span> <span class="dv">2</span>, <span class="at">id =</span> <span class="st">"rpart_cv"</span></span>
<span id="cb61-324"><a href="#cb61-324" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-325"><a href="#cb61-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-326"><a href="#cb61-326" aria-hidden="true" tabindex="-1"></a>lrn_knn <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.kknn"</span>, <span class="at">predict_type =</span> <span class="st">"prob"</span>)</span>
<span id="cb61-327"><a href="#cb61-327" aria-hidden="true" tabindex="-1"></a>po_knn_cv <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"learner_cv"</span>,</span>
<span id="cb61-328"><a href="#cb61-328" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_knn,</span>
<span id="cb61-329"><a href="#cb61-329" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling.folds =</span> <span class="dv">2</span>, <span class="at">id =</span> <span class="st">"knn_cv"</span></span>
<span id="cb61-330"><a href="#cb61-330" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-331"><a href="#cb61-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-332"><a href="#cb61-332" aria-hidden="true" tabindex="-1"></a>lrn_glmnet <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.glmnet"</span>, <span class="at">predict_type =</span> <span class="st">"prob"</span>)</span>
<span id="cb61-333"><a href="#cb61-333" aria-hidden="true" tabindex="-1"></a>po_glmnet_cv <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"learner_cv"</span>,</span>
<span id="cb61-334"><a href="#cb61-334" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_glmnet,</span>
<span id="cb61-335"><a href="#cb61-335" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling.folds =</span> <span class="dv">2</span>, <span class="at">id =</span> <span class="st">"glmnet_cv"</span></span>
<span id="cb61-336"><a href="#cb61-336" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-337"><a href="#cb61-337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-338"><a href="#cb61-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-339"><a href="#cb61-339" aria-hidden="true" tabindex="-1"></a>These learners are combined using <span class="in">`r ref("gunion()")`</span>, and <span class="in">`po("featureunion")`</span> is used to merge their predictions.</span>
<span id="cb61-340"><a href="#cb61-340" aria-hidden="true" tabindex="-1"></a>This is demonstrated in the output of <span class="in">`$train()`</span>:</span>
<span id="cb61-341"><a href="#cb61-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-342"><a href="#cb61-342" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-021, warning = FALSE}</span></span>
<span id="cb61-343"><a href="#cb61-343" aria-hidden="true" tabindex="-1"></a>gr_level_0 <span class="ot">=</span> <span class="fu">gunion</span>(<span class="fu">list</span>(po_rpart_cv, po_knn_cv, po_glmnet_cv))</span>
<span id="cb61-344"><a href="#cb61-344" aria-hidden="true" tabindex="-1"></a>gr_combined <span class="ot">=</span> gr_level_0 <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"featureunion"</span>)</span>
<span id="cb61-345"><a href="#cb61-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-346"><a href="#cb61-346" aria-hidden="true" tabindex="-1"></a>gr_combined<span class="sc">$</span><span class="fu">train</span>(<span class="fu">tsk</span>(<span class="st">"sonar"</span>))[[<span class="dv">1</span>]]<span class="sc">$</span><span class="fu">head</span>()</span>
<span id="cb61-347"><a href="#cb61-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-348"><a href="#cb61-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-349"><a href="#cb61-349" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb61-350"><a href="#cb61-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-351"><a href="#cb61-351" aria-hidden="true" tabindex="-1"></a><span class="fu">## Retaining Features</span></span>
<span id="cb61-352"><a href="#cb61-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-353"><a href="#cb61-353" aria-hidden="true" tabindex="-1"></a>In this example, the original features were removed as each <span class="in">`PipeOp`</span> only returns the predictions made by the respective learners.</span>
<span id="cb61-354"><a href="#cb61-354" aria-hidden="true" tabindex="-1"></a>To retain the original features, include <span class="in">`po("nop")`</span> in the list passed to <span class="in">`r ref("gunion()")`</span>.</span>
<span id="cb61-355"><a href="#cb61-355" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb61-356"><a href="#cb61-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-357"><a href="#cb61-357" aria-hidden="true" tabindex="-1"></a>The resulting task contains the predicted probabilities for both classes made from each of the level 0 learners.</span>
<span id="cb61-358"><a href="#cb61-358" aria-hidden="true" tabindex="-1"></a>However, as the probabilities always add up to $1$, we only need the predictions for one of the classes (as this is a binary classification task), so we can use <span class="in">`po("select")`</span> to only keep predictions for one class (we choose <span class="in">`"M"`</span> in this example).</span>
<span id="cb61-359"><a href="#cb61-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-360"><a href="#cb61-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-361"><a href="#cb61-361" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-022}</span></span>
<span id="cb61-362"><a href="#cb61-362" aria-hidden="true" tabindex="-1"></a>gr_stack <span class="ot">=</span> gr_combined <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-363"><a href="#cb61-363" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"select"</span>, <span class="at">selector =</span> <span class="fu">selector_grep</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">.M$"</span>))</span>
<span id="cb61-364"><a href="#cb61-364" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-365"><a href="#cb61-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-366"><a href="#cb61-366" aria-hidden="true" tabindex="-1"></a>Finally, we can combine our pipeline with the final model that will take these predictions as its input.</span>
<span id="cb61-367"><a href="#cb61-367" aria-hidden="true" tabindex="-1"></a>Below we use <span class="in">`r index('logistic regression')`</span>, which combines the level 0 predictions in a weighted linear sum.</span>
<span id="cb61-368"><a href="#cb61-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-369"><a href="#cb61-369" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-023, eval = FALSE}</span></span>
<span id="cb61-370"><a href="#cb61-370" aria-hidden="true" tabindex="-1"></a>gr_stack <span class="ot">=</span> gr_stack <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"learner"</span>, <span class="fu">lrn</span>(<span class="st">"classif.log_reg"</span>))</span>
<span id="cb61-371"><a href="#cb61-371" aria-hidden="true" tabindex="-1"></a>gr_stack<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-372"><a href="#cb61-372" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-373"><a href="#cb61-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-374"><a href="#cb61-374" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-024, fig.width = 10, echo = FALSE}</span></span>
<span id="cb61-375"><a href="#cb61-375" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-stackinggraph</span></span>
<span id="cb61-376"><a href="#cb61-376" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Constructed stacking Graph with one input being passed to three weak learners whose predictions are passed to the logistic regression.'</span></span>
<span id="cb61-377"><a href="#cb61-377" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph with "&lt;INPUT&gt;" in the first box with arrows to three boxes: "rpart_cv", "knn_cv", "glmnet_cv", which all have arrows pointing to the same boxes: "featureunion -&gt; select -&gt; classif.log_reg -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-378"><a href="#cb61-378" aria-hidden="true" tabindex="-1"></a>gr_stack <span class="ot">=</span> gr_stack <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"learner"</span>, <span class="fu">lrn</span>(<span class="st">"classif.log_reg"</span>))</span>
<span id="cb61-379"><a href="#cb61-379" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">2000</span>, <span class="at">height =</span> <span class="dv">1000</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">24</span>)</span>
<span id="cb61-380"><a href="#cb61-380" aria-hidden="true" tabindex="-1"></a>gr_stack<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-381"><a href="#cb61-381" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-382"><a href="#cb61-382" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-383"><a href="#cb61-383" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-384"><a href="#cb61-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-385"><a href="#cb61-385" aria-hidden="true" tabindex="-1"></a>As our final model was an interpretable logistic regression, we can inspect the weights of the level 0 learners by looking at the final trained model:</span>
<span id="cb61-386"><a href="#cb61-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-387"><a href="#cb61-387" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-025, warning = FALSE}</span></span>
<span id="cb61-388"><a href="#cb61-388" aria-hidden="true" tabindex="-1"></a>glrn_stack <span class="ot">=</span> <span class="fu">as_learner</span>(gr_stack)</span>
<span id="cb61-389"><a href="#cb61-389" aria-hidden="true" tabindex="-1"></a>glrn_stack<span class="sc">$</span><span class="fu">train</span>(<span class="fu">tsk</span>(<span class="st">"sonar"</span>))</span>
<span id="cb61-390"><a href="#cb61-390" aria-hidden="true" tabindex="-1"></a>glrn_stack<span class="sc">$</span><span class="fu">base_learner</span>()<span class="sc">$</span>model</span>
<span id="cb61-391"><a href="#cb61-391" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-392"><a href="#cb61-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-393"><a href="#cb61-393" aria-hidden="true" tabindex="-1"></a>The model weights suggest that <span class="in">`r c("rpart", "knn", "glmnet")[which.max(glrn_stack$base_learner()$model$coefficients[-1])]`</span> influences the predictions the most with the largest coefficient.</span>
<span id="cb61-394"><a href="#cb61-394" aria-hidden="true" tabindex="-1"></a>To confirm this we can benchmark the individual models alongside the stacking pipeline.</span>
<span id="cb61-395"><a href="#cb61-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-396"><a href="#cb61-396" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-026, warning = FALSE}</span></span>
<span id="cb61-397"><a href="#cb61-397" aria-hidden="true" tabindex="-1"></a>glrn_stack<span class="sc">$</span>id <span class="ot">=</span> <span class="st">"stacking"</span></span>
<span id="cb61-398"><a href="#cb61-398" aria-hidden="true" tabindex="-1"></a>design <span class="ot">=</span> <span class="fu">benchmark_grid</span>(<span class="fu">tsk</span>(<span class="st">"sonar"</span>),</span>
<span id="cb61-399"><a href="#cb61-399" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(lrn_rpart, lrn_knn, lrn_glmnet, glrn_stack), <span class="fu">rsmp</span>(<span class="st">"repeated_cv"</span>))</span>
<span id="cb61-400"><a href="#cb61-400" aria-hidden="true" tabindex="-1"></a>bmr <span class="ot">=</span> <span class="fu">benchmark</span>(design)</span>
<span id="cb61-401"><a href="#cb61-401" aria-hidden="true" tabindex="-1"></a>bmr<span class="sc">$</span><span class="fu">aggregate</span>()[, .(learner_id, classif.ce)]</span>
<span id="cb61-402"><a href="#cb61-402" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-403"><a href="#cb61-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-404"><a href="#cb61-404" aria-hidden="true" tabindex="-1"></a>This experiment confirms that of the individual models, the KNN learner performs the best, however, our stacking pipeline outperforms them all.</span>
<span id="cb61-405"><a href="#cb61-405" aria-hidden="true" tabindex="-1"></a>Now that we have seen the inner workings of this pipeline, next time you might want to more efficiently create it using <span class="in">`ppl("stacking")`</span>, to copy the example above you would run:</span>
<span id="cb61-406"><a href="#cb61-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-407"><a href="#cb61-407" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-027, eval = FALSE}</span></span>
<span id="cb61-408"><a href="#cb61-408" aria-hidden="true" tabindex="-1"></a><span class="fu">ppl</span>(<span class="st">"stacking"</span>,</span>
<span id="cb61-409"><a href="#cb61-409" aria-hidden="true" tabindex="-1"></a>  <span class="at">base_learners =</span> <span class="fu">lrns</span>(<span class="fu">c</span>(<span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span>,</span>
<span id="cb61-410"><a href="#cb61-410" aria-hidden="true" tabindex="-1"></a>    <span class="st">"classif.glmnet"</span>)),</span>
<span id="cb61-411"><a href="#cb61-411" aria-hidden="true" tabindex="-1"></a>  <span class="at">super_learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.log_reg"</span>)</span>
<span id="cb61-412"><a href="#cb61-412" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-413"><a href="#cb61-413" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-414"><a href="#cb61-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-415"><a href="#cb61-415" aria-hidden="true" tabindex="-1"></a>Having covered the building blocks of <span class="in">`mlr3pipelines`</span> and seen these in practice, we will now turn to more advanced functionality, combining pipelines with tuning.</span>
<span id="cb61-416"><a href="#cb61-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-417"><a href="#cb61-417" aria-hidden="true" tabindex="-1"></a><span class="fu">## `r index('Tuning')` Graphs {#sec-pipelines-tuning}</span></span>
<span id="cb61-418"><a href="#cb61-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-419"><a href="#cb61-419" aria-hidden="true" tabindex="-1"></a>By wrapping a pipeline inside a <span class="in">`r ref("GraphLearner")`</span>, we can tune it at two levels of complexity using <span class="in">`r mlr3tuning`</span>:</span>
<span id="cb61-420"><a href="#cb61-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-421"><a href="#cb61-421" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Tuning of a fixed, usually sequential pipeline, where preprocessing is combined with a given learner.</span>
<span id="cb61-422"><a href="#cb61-422" aria-hidden="true" tabindex="-1"></a>  This simply means the joint tuning of any subset of selected hyperparameters of operations in the pipeline.</span>
<span id="cb61-423"><a href="#cb61-423" aria-hidden="true" tabindex="-1"></a>  Conceptually and also technically in <span class="in">`mlr3`</span>, this is not much different from tuning a learner that is not part of a pipeline.</span>
<span id="cb61-424"><a href="#cb61-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-425"><a href="#cb61-425" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Tuning not only the hyperparameters of a pipeline, whose structure is not completely fixed in terms of its included operations, but also which concrete <span class="in">`r ref("PipeOp")`</span>s should be applied to data.</span>
<span id="cb61-426"><a href="#cb61-426" aria-hidden="true" tabindex="-1"></a>  This allows us to select these operations (e.g. which learner to use, which preprocessing to perform) in a data-driven manner known as "<span class="in">`r index('Combined Algorithm Selection and Hyperparameter optimization')`</span>"\index{CASH|see{combined algorithm selection and hyperparameter optimization}} <span class="co">[</span><span class="ot">@Thornton2013</span><span class="co">]</span>.</span>
<span id="cb61-427"><a href="#cb61-427" aria-hidden="true" tabindex="-1"></a>  As we will soon see, we can do this in <span class="in">`mlr3pipelines`</span> by using the powerful branching (@sec-pipelines-branch) and proxy (@sec-pipelines-proxy) meta operators.</span>
<span id="cb61-428"><a href="#cb61-428" aria-hidden="true" tabindex="-1"></a>  Through this, we can conveniently create our own "mini AutoML systems" <span class="co">[</span><span class="ot">@hutter2019automated</span><span class="co">]</span> in <span class="in">`mlr3`</span>, which can even be geared for specific tasks.</span>
<span id="cb61-429"><a href="#cb61-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-430"><a href="#cb61-430" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Graph Hyperparameters {#sec-pipelines-combined}</span></span>
<span id="cb61-431"><a href="#cb61-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-432"><a href="#cb61-432" aria-hidden="true" tabindex="-1"></a>Let us consider a simple, sequential pipeline using <span class="in">`po("pca")`</span> followed by <span class="in">`lrn("classif.kknn")`</span>:</span>
<span id="cb61-433"><a href="#cb61-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-434"><a href="#cb61-434" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-028}</span></span>
<span id="cb61-435"><a href="#cb61-435" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> <span class="fu">as_learner</span>(<span class="fu">po</span>(<span class="st">"pca"</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">lrn</span>(<span class="st">"classif.kknn"</span>))</span>
<span id="cb61-436"><a href="#cb61-436" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-437"><a href="#cb61-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-438"><a href="#cb61-438" aria-hidden="true" tabindex="-1"></a>The optimal setting of the <span class="in">`rank.`</span> hyperparameter of our PCA <span class="in">`r ref("PipeOp")`</span> may realistically depend on the value of the <span class="in">`k`</span> hyperparameter of the KNN model so jointly tuning them is reasonable.</span>
<span id="cb61-439"><a href="#cb61-439" aria-hidden="true" tabindex="-1"></a>For this, we can simply use the syntax for tuning <span class="in">`Learner`</span>s, which was introduced in @sec-optimization.</span>
<span id="cb61-440"><a href="#cb61-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-441"><a href="#cb61-441" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-029}</span></span>
<span id="cb61-442"><a href="#cb61-442" aria-hidden="true" tabindex="-1"></a>lrn_knn <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.kknn"</span>, <span class="at">k =</span> <span class="fu">to_tune</span>(<span class="dv">1</span>, <span class="dv">32</span>))</span>
<span id="cb61-443"><a href="#cb61-443" aria-hidden="true" tabindex="-1"></a>po_pca <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">rank. =</span> <span class="fu">to_tune</span>(<span class="dv">2</span>, <span class="dv">20</span>))</span>
<span id="cb61-444"><a href="#cb61-444" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> <span class="fu">as_learner</span>(po_pca <span class="sc">%&gt;&gt;%</span> lrn_knn)</span>
<span id="cb61-445"><a href="#cb61-445" aria-hidden="true" tabindex="-1"></a>graph_learner<span class="sc">$</span>param_set<span class="sc">$</span>values</span>
<span id="cb61-446"><a href="#cb61-446" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-447"><a href="#cb61-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-448"><a href="#cb61-448" aria-hidden="true" tabindex="-1"></a>We can see how the pipeline's <span class="in">`$param_set`</span> includes the tune tokens for all selected hyperparameters, creating a joint search space.</span>
<span id="cb61-449"><a href="#cb61-449" aria-hidden="true" tabindex="-1"></a>We can compare the tuned and untuned pipeline in a benchmark experiment with nested resampling by using an <span class="in">`AutoTuner`</span>:</span>
<span id="cb61-450"><a href="#cb61-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-451"><a href="#cb61-451" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-030}</span></span>
<span id="cb61-452"><a href="#cb61-452" aria-hidden="true" tabindex="-1"></a>glrn_tuned <span class="ot">=</span> <span class="fu">auto_tuner</span>(<span class="fu">tnr</span>(<span class="st">"random_search"</span>), graph_learner,</span>
<span id="cb61-453"><a href="#cb61-453" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"holdout"</span>), <span class="at">term_evals =</span> <span class="dv">10</span>)</span>
<span id="cb61-454"><a href="#cb61-454" aria-hidden="true" tabindex="-1"></a>glrn_untuned <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"pca"</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">lrn</span>(<span class="st">"classif.kknn"</span>)</span>
<span id="cb61-455"><a href="#cb61-455" aria-hidden="true" tabindex="-1"></a>design <span class="ot">=</span> <span class="fu">benchmark_grid</span>(<span class="fu">tsk</span>(<span class="st">"sonar"</span>), <span class="fu">c</span>(glrn_tuned, glrn_untuned),</span>
<span id="cb61-456"><a href="#cb61-456" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">5</span>))</span>
<span id="cb61-457"><a href="#cb61-457" aria-hidden="true" tabindex="-1"></a><span class="fu">benchmark</span>(design)<span class="sc">$</span><span class="fu">aggregate</span>()[, .(learner_id, classif.ce)]</span>
<span id="cb61-458"><a href="#cb61-458" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-459"><a href="#cb61-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-460"><a href="#cb61-460" aria-hidden="true" tabindex="-1"></a>Tuning pipelines will usually take longer than tuning individual learners as training steps are often more complex and the search space will be larger.</span>
<span id="cb61-461"><a href="#cb61-461" aria-hidden="true" tabindex="-1"></a>Therefore, parallelization is often appropriate (@sec-parallelization) and/or more efficient tuning methods for searching large tuning spaces such as <span class="in">`r index('Bayesian optimization', lower = FALSE)`</span> (@sec-bayesian-optimization).</span>
<span id="cb61-462"><a href="#cb61-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-463"><a href="#cb61-463" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Alternative Paths with po("branch") {#sec-pipelines-branch}</span></span>
<span id="cb61-464"><a href="#cb61-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-465"><a href="#cb61-465" aria-hidden="true" tabindex="-1"></a>In the previous section, we tuned the KKNN and <span class="in">`r index('decision tree')`</span> in the stacking pipeline, as well as tuning the rank of the PCA.</span>
<span id="cb61-466"><a href="#cb61-466" aria-hidden="true" tabindex="-1"></a>However, we tuned the PCA without first considering if it was even beneficial at all, in this section we will answer that question by making use of <span class="in">`r ref("PipeOpBranch")`</span> and <span class="in">`r ref("PipeOpUnbranch")`</span>, which make it possible to specify multiple alternative paths in a pipeline.</span>
<span id="cb61-467"><a href="#cb61-467" aria-hidden="true" tabindex="-1"></a><span class="in">`po("branch")`</span> creates multiple paths such that data can only flow through *one* of these as determined by the <span class="in">`selection`</span> hyperparameter (@fig-pipelines-alternatives).</span>
<span id="cb61-468"><a href="#cb61-468" aria-hidden="true" tabindex="-1"></a>This concept makes it possible to use tuning to decide which <span class="in">`r ref("PipeOp")`</span>s and <span class="in">`r ref("Learner")`</span>s to include in the pipeline, while also allowing all options in every path to be tuned.</span>
<span id="cb61-469"><a href="#cb61-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-470"><a href="#cb61-470" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-031, echo = FALSE, out.width = "100%"}</span></span>
<span id="cb61-471"><a href="#cb61-471" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-branching</span></span>
<span id="cb61-472"><a href="#cb61-472" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Figure demonstrates the `po("branch")` and `po("unbranch")` operators where three separate branches are created and data only flows through the PCA, which is specified with the argument to `selection`.'</span></span>
<span id="cb61-473"><a href="#cb61-473" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph with "Dtrain" on the left with an arrow to `po("branch", selection = "pca")` which then has a dark shaded arrow to a box that says "PCA". Above this box is a transparent box that says "PipeOpNOP" and below the "PCA" box is another transparent box that says "YeoJohnson", the implication is that only the "PCA" box is active. The "PCA" box then has an arrow to `po("unbranch")` -&gt; po("branch", selection = "XGBoost")` which has three arrows to another three boxes with "XGBoost" highlighted and "Random Forest" and "Decision Tree" transparent again. These finally have arrows to the same `po("unbranch")`.'</span></span>
<span id="cb61-474"><a href="#cb61-474" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-24"</span>)</span>
<span id="cb61-475"><a href="#cb61-475" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-476"><a href="#cb61-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-477"><a href="#cb61-477" aria-hidden="true" tabindex="-1"></a>To demonstrate alternative paths we will make use of the MNIST <span class="co">[</span><span class="ot">@lecun1998gradient</span><span class="co">]</span> data, which is useful for demonstrating preprocessing.</span>
<span id="cb61-478"><a href="#cb61-478" aria-hidden="true" tabindex="-1"></a>The data is loaded from OpenML, which is described in @sec-openml, we subset the data to make the example run faster.</span>
<span id="cb61-479"><a href="#cb61-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-480"><a href="#cb61-480" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-032}</span></span>
<span id="cb61-481"><a href="#cb61-481" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3oml)</span>
<span id="cb61-482"><a href="#cb61-482" aria-hidden="true" tabindex="-1"></a>otsk_mnist <span class="ot">=</span> <span class="fu">otsk</span>(<span class="at">id =</span> <span class="dv">3573</span>)</span>
<span id="cb61-483"><a href="#cb61-483" aria-hidden="true" tabindex="-1"></a>tsk_mnist <span class="ot">=</span> <span class="fu">as_task</span>(otsk_mnist)<span class="sc">$</span></span>
<span id="cb61-484"><a href="#cb61-484" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">sample</span>(<span class="dv">70000</span>, <span class="dv">1000</span>))<span class="sc">$</span></span>
<span id="cb61-485"><a href="#cb61-485" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(otsk_mnist<span class="sc">$</span>feature_names[<span class="fu">sample</span>(<span class="dv">700</span>, <span class="dv">100</span>)])</span>
<span id="cb61-486"><a href="#cb61-486" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-487"><a href="#cb61-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-488"><a href="#cb61-488" aria-hidden="true" tabindex="-1"></a><span class="in">`po("branch")`</span> is initialized either with the number of branches or with a <span class="in">`character`</span>-vector indicating the names of the branches, the latter makes the <span class="in">`selection`</span> hyperparameter (discussed below) more readable.</span>
<span id="cb61-489"><a href="#cb61-489" aria-hidden="true" tabindex="-1"></a>Below we create three branches: do nothing (<span class="in">`po("nop")`</span>), apply PCA (<span class="in">`po("pca")`</span>), remove constant features (<span class="in">`po("removeconstants")`</span>) then apply the <span class="in">`r index('Yeo-Johnson', lower = FALSE)`</span> transform (<span class="in">`po("yeojohnson")`</span>).</span>
<span id="cb61-490"><a href="#cb61-490" aria-hidden="true" tabindex="-1"></a>It is important to use <span class="in">`po("unbranch")`</span> (with the same arguments as <span class="in">`"branch"`</span>) to ensure that the outputs are merged into one result object.</span>
<span id="cb61-491"><a href="#cb61-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-492"><a href="#cb61-492" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-033, eval = FALSE}</span></span>
<span id="cb61-493"><a href="#cb61-493" aria-hidden="true" tabindex="-1"></a>paths <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"nop"</span>, <span class="st">"pca"</span>, <span class="st">"yeojohnson"</span>)</span>
<span id="cb61-494"><a href="#cb61-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-495"><a href="#cb61-495" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"branch"</span>, paths, <span class="at">id =</span> <span class="st">"brnchPO"</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-496"><a href="#cb61-496" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gunion</span>(<span class="fu">list</span>(</span>
<span id="cb61-497"><a href="#cb61-497" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"nop"</span>),</span>
<span id="cb61-498"><a href="#cb61-498" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"pca"</span>),</span>
<span id="cb61-499"><a href="#cb61-499" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"removeconstants"</span>, <span class="at">id =</span> <span class="st">"rm_const"</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-500"><a href="#cb61-500" aria-hidden="true" tabindex="-1"></a>      <span class="fu">po</span>(<span class="st">"yeojohnson"</span>, <span class="at">id =</span> <span class="st">"YJ"</span>)</span>
<span id="cb61-501"><a href="#cb61-501" aria-hidden="true" tabindex="-1"></a>  )) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"unbranch"</span>, paths, <span class="at">id =</span> <span class="st">"unbrnchPO"</span>)</span>
<span id="cb61-502"><a href="#cb61-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-503"><a href="#cb61-503" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-504"><a href="#cb61-504" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-505"><a href="#cb61-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-506"><a href="#cb61-506" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-034, fig.width = 10, echo = FALSE}</span></span>
<span id="cb61-507"><a href="#cb61-507" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-branchone</span></span>
<span id="cb61-508"><a href="#cb61-508" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Graph with branching to three different paths that are split with `po("branch")` and combined with `po("unbranch")`.'</span></span>
<span id="cb61-509"><a href="#cb61-509" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph starting with "&lt;INPUT&gt; -&gt; brnchPO" which has three arrows to "removeconstants -&gt; yeojohnson", "nop", and "pca", which all then point to "unbrnchPO -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-510"><a href="#cb61-510" aria-hidden="true" tabindex="-1"></a>paths <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"nop"</span>, <span class="st">"pca"</span>, <span class="st">"yeojohnson"</span>)</span>
<span id="cb61-511"><a href="#cb61-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-512"><a href="#cb61-512" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"branch"</span>, paths, <span class="at">id =</span> <span class="st">"brnchPO"</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-513"><a href="#cb61-513" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gunion</span>(<span class="fu">list</span>(</span>
<span id="cb61-514"><a href="#cb61-514" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"nop"</span>),</span>
<span id="cb61-515"><a href="#cb61-515" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"pca"</span>),</span>
<span id="cb61-516"><a href="#cb61-516" aria-hidden="true" tabindex="-1"></a>    <span class="fu">po</span>(<span class="st">"removeconstants"</span>, <span class="at">id =</span> <span class="st">"rm_const"</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"yeojohnson"</span>, <span class="at">id =</span> <span class="st">"YJ"</span>)</span>
<span id="cb61-517"><a href="#cb61-517" aria-hidden="true" tabindex="-1"></a>  )) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"unbranch"</span>, paths, <span class="at">id =</span> <span class="st">"unbrnchPO"</span>)</span>
<span id="cb61-518"><a href="#cb61-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-519"><a href="#cb61-519" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">2000</span>, <span class="at">height =</span> <span class="dv">900</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">24</span>)</span>
<span id="cb61-520"><a href="#cb61-520" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-521"><a href="#cb61-521" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-522"><a href="#cb61-522" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-523"><a href="#cb61-523" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-524"><a href="#cb61-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-525"><a href="#cb61-525" aria-hidden="true" tabindex="-1"></a>We can see how the output of this <span class="in">`Graph`</span> depends on the setting of the <span class="in">`branch.selection`</span> hyperparameter:</span>
<span id="cb61-526"><a href="#cb61-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-527"><a href="#cb61-527" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-035}</span></span>
<span id="cb61-528"><a href="#cb61-528" aria-hidden="true" tabindex="-1"></a><span class="co"># use the "PCA" path</span></span>
<span id="cb61-529"><a href="#cb61-529" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span>param_set<span class="sc">$</span>values<span class="sc">$</span>brnchPO.selection <span class="ot">=</span> <span class="st">"pca"</span></span>
<span id="cb61-530"><a href="#cb61-530" aria-hidden="true" tabindex="-1"></a><span class="co"># new PCA columns</span></span>
<span id="cb61-531"><a href="#cb61-531" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(graph<span class="sc">$</span><span class="fu">train</span>(tsk_mnist)[[<span class="dv">1</span>]]<span class="sc">$</span>feature_names)</span>
<span id="cb61-532"><a href="#cb61-532" aria-hidden="true" tabindex="-1"></a><span class="co"># use the "No-Op" path</span></span>
<span id="cb61-533"><a href="#cb61-533" aria-hidden="true" tabindex="-1"></a>graph<span class="sc">$</span>param_set<span class="sc">$</span>values<span class="sc">$</span>brnchPO.selection <span class="ot">=</span> <span class="st">"nop"</span></span>
<span id="cb61-534"><a href="#cb61-534" aria-hidden="true" tabindex="-1"></a><span class="co"># same features</span></span>
<span id="cb61-535"><a href="#cb61-535" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(graph<span class="sc">$</span><span class="fu">train</span>(tsk_mnist)[[<span class="dv">1</span>]]<span class="sc">$</span>feature_names)</span>
<span id="cb61-536"><a href="#cb61-536" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-537"><a href="#cb61-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-538"><a href="#cb61-538" aria-hidden="true" tabindex="-1"></a><span class="in">`ppl("branch")`</span> simplifies the above by allowing you to just pass the different paths to the <span class="in">`graphs`</span> argument (omitting "<span class="in">`rm_const`</span>" for simplicity here):</span>
<span id="cb61-539"><a href="#cb61-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-540"><a href="#cb61-540" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-036, eval = FALSE}</span></span>
<span id="cb61-541"><a href="#cb61-541" aria-hidden="true" tabindex="-1"></a><span class="fu">ppl</span>(<span class="st">"branch"</span>, <span class="at">graphs =</span> <span class="fu">pos</span>(<span class="fu">c</span>(<span class="st">"nop"</span>, <span class="st">"pca"</span>, <span class="st">"yeojohnson"</span>)))</span>
<span id="cb61-542"><a href="#cb61-542" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-543"><a href="#cb61-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-544"><a href="#cb61-544" aria-hidden="true" tabindex="-1"></a>Branching can even be used to tune which of several learners is most appropriate for a given dataset.</span>
<span id="cb61-545"><a href="#cb61-545" aria-hidden="true" tabindex="-1"></a>We extend our example further and add the choice between a decision tree and KKNN:</span>
<span id="cb61-546"><a href="#cb61-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-547"><a href="#cb61-547" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-037, eval = FALSE}</span></span>
<span id="cb61-548"><a href="#cb61-548" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> graph <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-549"><a href="#cb61-549" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ppl</span>(<span class="st">"branch"</span>, <span class="fu">lrns</span>(<span class="fu">c</span>(<span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span>)))</span>
<span id="cb61-550"><a href="#cb61-550" aria-hidden="true" tabindex="-1"></a>graph_learner<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-551"><a href="#cb61-551" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-552"><a href="#cb61-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-553"><a href="#cb61-553" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-038, fig.width = 8, fig.height = 6, echo = FALSE, out.width = "100%"}</span></span>
<span id="cb61-554"><a href="#cb61-554" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-branchtwo</span></span>
<span id="cb61-555"><a href="#cb61-555" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Graph with branching to three different paths that are split with `po("branch")` and combined with `po("unbranch")` then branch and recombine again.'</span></span>
<span id="cb61-556"><a href="#cb61-556" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph starts with "&lt;INPUT&gt; -&gt; brnchPO" which has three arrows to "removeconstants -&gt; yeojohnson", "nop", and "pca", which all then point to "unbrnchPO -&gt; branch", which then has two arrows to "classif.rpart" and "classif.kknn" which then both point to "unbranch -&gt; &lt;OUTPUT&gt;".'</span></span>
<span id="cb61-557"><a href="#cb61-557" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> graph <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-558"><a href="#cb61-558" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ppl</span>(<span class="st">"branch"</span>, <span class="fu">lrns</span>(<span class="fu">c</span>(<span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span>)))</span>
<span id="cb61-559"><a href="#cb61-559" aria-hidden="true" tabindex="-1"></a>fig <span class="ot">=</span> magick<span class="sc">::</span><span class="fu">image_graph</span>(<span class="at">width =</span> <span class="dv">2000</span>, <span class="at">height =</span> <span class="dv">900</span>, <span class="at">res =</span> <span class="dv">100</span>, <span class="at">pointsize =</span> <span class="dv">22</span>)</span>
<span id="cb61-560"><a href="#cb61-560" aria-hidden="true" tabindex="-1"></a>graph_learner<span class="sc">$</span><span class="fu">plot</span>(<span class="at">horizontal =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-561"><a href="#cb61-561" aria-hidden="true" tabindex="-1"></a><span class="fu">invisible</span>(<span class="fu">dev.off</span>())</span>
<span id="cb61-562"><a href="#cb61-562" aria-hidden="true" tabindex="-1"></a>magick<span class="sc">::</span><span class="fu">image_trim</span>(fig)</span>
<span id="cb61-563"><a href="#cb61-563" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-564"><a href="#cb61-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-565"><a href="#cb61-565" aria-hidden="true" tabindex="-1"></a>Tuning the <span class="in">`selection`</span> hyperparameters can help determine which of the possible options work best in combination.</span>
<span id="cb61-566"><a href="#cb61-566" aria-hidden="true" tabindex="-1"></a>We additionally tune the <span class="in">`k`</span> hyperparameter of the KNN learner, as it may depend on the type of preprocessing performed.</span>
<span id="cb61-567"><a href="#cb61-567" aria-hidden="true" tabindex="-1"></a>As this hyperparameter is only active when the <span class="in">`"classif.kknn"`</span> path is chosen we will set a dependency (@sec-optimization-depends):</span>
<span id="cb61-568"><a href="#cb61-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-569"><a href="#cb61-569" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-039, echo = FALSE}</span></span>
<span id="cb61-570"><a href="#cb61-570" aria-hidden="true" tabindex="-1"></a><span class="co"># instead of plotting, we make autoplot() save the plot so we can edit it afterwards</span></span>
<span id="cb61-571"><a href="#cb61-571" aria-hidden="true" tabindex="-1"></a><span class="co"># This is *not* the same as ggplot::last_plot(), but the result is easier to handle in a loop.</span></span>
<span id="cb61-572"><a href="#cb61-572" aria-hidden="true" tabindex="-1"></a>plt_container <span class="ot">=</span> <span class="fu">new.env</span>()</span>
<span id="cb61-573"><a href="#cb61-573" aria-hidden="true" tabindex="-1"></a>autoplot <span class="ot">=</span> <span class="cf">function</span>(...) {</span>
<span id="cb61-574"><a href="#cb61-574" aria-hidden="true" tabindex="-1"></a>  <span class="co"># &lt;&lt;- doesn't seem to work on CI for some reason</span></span>
<span id="cb61-575"><a href="#cb61-575" aria-hidden="true" tabindex="-1"></a>  plt_container<span class="sc">$</span>plt <span class="ot">=</span> ggplot2<span class="sc">::</span><span class="fu">autoplot</span>(...)</span>
<span id="cb61-576"><a href="#cb61-576" aria-hidden="true" tabindex="-1"></a>  <span class="fu">invisible</span>(<span class="cn">NULL</span>)</span>
<span id="cb61-577"><a href="#cb61-577" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb61-578"><a href="#cb61-578" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-579"><a href="#cb61-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-580"><a href="#cb61-580" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-040}</span></span>
<span id="cb61-581"><a href="#cb61-581" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> <span class="fu">as_learner</span>(graph_learner)</span>
<span id="cb61-582"><a href="#cb61-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-583"><a href="#cb61-583" aria-hidden="true" tabindex="-1"></a>graph_learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(</span>
<span id="cb61-584"><a href="#cb61-584" aria-hidden="true" tabindex="-1"></a>  <span class="at">brnchPO.selection =</span> <span class="fu">to_tune</span>(paths),</span>
<span id="cb61-585"><a href="#cb61-585" aria-hidden="true" tabindex="-1"></a>  <span class="at">branch.selection =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="st">"classif.rpart"</span>, <span class="st">"classif.kknn"</span>)),</span>
<span id="cb61-586"><a href="#cb61-586" aria-hidden="true" tabindex="-1"></a>  <span class="at">classif.kknn.k =</span> <span class="fu">to_tune</span>(<span class="fu">p_int</span>(<span class="dv">1</span>, <span class="dv">32</span>,</span>
<span id="cb61-587"><a href="#cb61-587" aria-hidden="true" tabindex="-1"></a>    <span class="at">depends =</span> branch.selection <span class="sc">==</span> <span class="st">"classif.kknn"</span>))</span>
<span id="cb61-588"><a href="#cb61-588" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-589"><a href="#cb61-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-590"><a href="#cb61-590" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(<span class="fu">tnr</span>(<span class="st">"grid_search"</span>), tsk_mnist, graph_learner,</span>
<span id="cb61-591"><a href="#cb61-591" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"repeated_cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>, <span class="at">repeats =</span> <span class="dv">3</span>), <span class="fu">msr</span>(<span class="st">"classif.ce"</span>))</span>
<span id="cb61-592"><a href="#cb61-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-593"><a href="#cb61-593" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>archive<span class="sc">$</span>data[<span class="fu">order</span>(classif.ce)[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>],</span>
<span id="cb61-594"><a href="#cb61-594" aria-hidden="true" tabindex="-1"></a>  .(brnchPO.selection, classif.kknn.k, branch.selection, classif.ce)]</span>
<span id="cb61-595"><a href="#cb61-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-596"><a href="#cb61-596" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(instance)</span>
<span id="cb61-597"><a href="#cb61-597" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-598"><a href="#cb61-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-599"><a href="#cb61-599" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-041, echo = FALSE, message = FALSE, warning = FALSE}</span></span>
<span id="cb61-600"><a href="#cb61-600" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-nonseq-instance</span></span>
<span id="cb61-601"><a href="#cb61-601" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Instance after tuning preprocessing branch choice (`brnchPO.selection`), KNN `k` parameter (`classif.kknn.k`), and learning branch choice (`branch.selection`). Dots are different hyperparameter configurations that were tested during tuning, colors separate hyperparameter configurations.</span></span>
<span id="cb61-602"><a href="#cb61-602" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: "Three scatter plots all with y-axis 'classif.ce' from around 0.25 to 0.5. Left plot is 'brnchPO.selection', middle is 'classif.knn.k', right is 'branch.selection'. x-axis text is the hyperparameter values to tune. Each 'row' of the y-axis indicates a different hyperparameter configuration (also separated by colored dots). The bottom row (and therefore best configuration) is at around 0.22 and shows the same results as in the instance output. Other 'rows' show a trade-off between KKNN `k` parameter, choice of learner, and choice of operators."</span></span>
<span id="cb61-603"><a href="#cb61-603" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb61-604"><a href="#cb61-604" aria-hidden="true" tabindex="-1"></a>plt <span class="ot">=</span> plt_container<span class="sc">$</span>plt</span>
<span id="cb61-605"><a href="#cb61-605" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(plt)) {</span>
<span id="cb61-606"><a href="#cb61-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-607"><a href="#cb61-607" aria-hidden="true" tabindex="-1"></a>  <span class="co"># remove axis labels and text,</span></span>
<span id="cb61-608"><a href="#cb61-608" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (i <span class="sc">!=</span> <span class="dv">1</span>) {</span>
<span id="cb61-609"><a href="#cb61-609" aria-hidden="true" tabindex="-1"></a>    plt[[i]]<span class="sc">$</span>labels<span class="sc">$</span>y <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb61-610"><a href="#cb61-610" aria-hidden="true" tabindex="-1"></a>    plt[[i]]<span class="sc">$</span>theme<span class="sc">$</span>axis.text.y <span class="ot">=</span> <span class="fu">element_blank</span>()</span>
<span id="cb61-611"><a href="#cb61-611" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb61-612"><a href="#cb61-612" aria-hidden="true" tabindex="-1"></a>  <span class="co"># bring axes to same scale</span></span>
<span id="cb61-613"><a href="#cb61-613" aria-hidden="true" tabindex="-1"></a>  plt[[i]]<span class="sc">$</span>coordinates<span class="sc">$</span>limits<span class="sc">$</span>y <span class="ot">=</span> <span class="fu">range</span>(plt[[<span class="dv">1</span>]]<span class="sc">$</span>data<span class="sc">$</span>classif.ce)  <span class="co"># hard-coding y var here...</span></span>
<span id="cb61-614"><a href="#cb61-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-615"><a href="#cb61-615" aria-hidden="true" tabindex="-1"></a>  <span class="do">## The following removes the legend and rotates the x-axis labels</span></span>
<span id="cb61-616"><a href="#cb61-616" aria-hidden="true" tabindex="-1"></a>  <span class="do">## We do this in the hidden part of the document to avoid cluttering the</span></span>
<span id="cb61-617"><a href="#cb61-617" aria-hidden="true" tabindex="-1"></a>  <span class="do">## example. If you want the example to be "exact" (except for the modifications above),</span></span>
<span id="cb61-618"><a href="#cb61-618" aria-hidden="true" tabindex="-1"></a>  <span class="do">## use the following instead:</span></span>
<span id="cb61-619"><a href="#cb61-619" aria-hidden="true" tabindex="-1"></a>  <span class="co"># autoplot(instance, theme = theme_minimal() + theme(</span></span>
<span id="cb61-620"><a href="#cb61-620" aria-hidden="true" tabindex="-1"></a>  <span class="co">#     axis.text.x = element_text(angle = 45),</span></span>
<span id="cb61-621"><a href="#cb61-621" aria-hidden="true" tabindex="-1"></a>  <span class="co">#     legend.position = "none"))</span></span>
<span id="cb61-622"><a href="#cb61-622" aria-hidden="true" tabindex="-1"></a>  <span class="do">### Angle the x-axis labels</span></span>
<span id="cb61-623"><a href="#cb61-623" aria-hidden="true" tabindex="-1"></a>  et <span class="ot">=</span> <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">45</span>)</span>
<span id="cb61-624"><a href="#cb61-624" aria-hidden="true" tabindex="-1"></a>  plt[[i]]<span class="sc">$</span>theme<span class="sc">$</span>axis.text.x <span class="ot">=</span> et</span>
<span id="cb61-625"><a href="#cb61-625" aria-hidden="true" tabindex="-1"></a>  <span class="do">### Remove the legends</span></span>
<span id="cb61-626"><a href="#cb61-626" aria-hidden="true" tabindex="-1"></a>  plt[[i]]<span class="sc">$</span>theme<span class="sc">$</span>legend.position <span class="ot">=</span> <span class="st">"none"</span></span>
<span id="cb61-627"><a href="#cb61-627" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb61-628"><a href="#cb61-628" aria-hidden="true" tabindex="-1"></a><span class="fu">rm</span>(autoplot) <span class="co"># reset to original function</span></span>
<span id="cb61-629"><a href="#cb61-629" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(plt)</span>
<span id="cb61-630"><a href="#cb61-630" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-631"><a href="#cb61-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-632"><a href="#cb61-632" aria-hidden="true" tabindex="-1"></a>As we can see in the results and @fig-nonseq-instance, the KNN-learner with <span class="in">`k`</span> set to <span class="in">`r instance$result$classif.kknn.k`</span> was selected, which performs best in combination with the Yeo-Johnson transform.</span>
<span id="cb61-633"><a href="#cb61-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-634"><a href="#cb61-634" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning with po("proxy") {#sec-pipelines-proxy}</span></span>
<span id="cb61-635"><a href="#cb61-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-636"><a href="#cb61-636" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb61-637"><a href="#cb61-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-638"><a href="#cb61-638" aria-hidden="true" tabindex="-1"></a><span class="in">`po("proxy")`</span> is a meta-operator that performs the operation that is stored in its <span class="in">`content`</span> hyperparameter, which could be another <span class="in">`r ref("PipeOp")`</span> or <span class="in">`r ref("Graph")`</span>.</span>
<span id="cb61-639"><a href="#cb61-639" aria-hidden="true" tabindex="-1"></a>It can therefore be used to tune over and select different <span class="in">`PipeOp`</span>s or <span class="in">`Graph`</span>s that could be passed to this hyperparameter (@fig-pipelines-alternatives).</span>
<span id="cb61-640"><a href="#cb61-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-641"><a href="#cb61-641" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-042, echo = FALSE, out.width = "70%"}</span></span>
<span id="cb61-642"><a href="#cb61-642" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-pipelines-alternatives</span></span>
<span id="cb61-643"><a href="#cb61-643" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: 'Figure demonstrates the `po("proxy")` operator with a `PipeOp` as its argument.'</span></span>
<span id="cb61-644"><a href="#cb61-644" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: 'Graph with "Dtrain -&gt; po("proxy", content = PCA) -&gt; po("proxy", content = XGBoost)"; "PCA" and "XGBoost" are represented as boxes that imply PipeOps.'</span></span>
<span id="cb61-645"><a href="#cb61-645" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"mlr3book_figures-25"</span>)</span>
<span id="cb61-646"><a href="#cb61-646" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-647"><a href="#cb61-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-648"><a href="#cb61-648" aria-hidden="true" tabindex="-1"></a>To recreate the example above with <span class="in">`po("proxy")`</span>, the first step is to create placeholder <span class="in">`r ref("PipeOpProxy")`</span> operators to stand in for the operations (i.e., different paths) that should be tuned.</span>
<span id="cb61-649"><a href="#cb61-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-650"><a href="#cb61-650" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-043}</span></span>
<span id="cb61-651"><a href="#cb61-651" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"proxy"</span>, <span class="at">id =</span> <span class="st">"preproc"</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-652"><a href="#cb61-652" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"proxy"</span>, <span class="at">id =</span> <span class="st">"learner"</span>)</span>
<span id="cb61-653"><a href="#cb61-653" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> <span class="fu">as_learner</span>(graph_learner)</span>
<span id="cb61-654"><a href="#cb61-654" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-655"><a href="#cb61-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-656"><a href="#cb61-656" aria-hidden="true" tabindex="-1"></a>The tuning space for the <span class="in">`content`</span> hyperparameters should be a discrete set of possibilities to be evaluated, passed as a <span class="in">`r ref("p_fct")`</span> (@sec-tune-ps).</span>
<span id="cb61-657"><a href="#cb61-657" aria-hidden="true" tabindex="-1"></a>For the <span class="in">`"preproc"`</span> proxy operator this would simply be the different <span class="in">`PipeOp`</span>s that we want to consider:</span>
<span id="cb61-658"><a href="#cb61-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-659"><a href="#cb61-659" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-044}</span></span>
<span id="cb61-660"><a href="#cb61-660" aria-hidden="true" tabindex="-1"></a><span class="co"># define content for the preprocessing proxy operator</span></span>
<span id="cb61-661"><a href="#cb61-661" aria-hidden="true" tabindex="-1"></a>preproc.content <span class="ot">=</span> <span class="fu">p_fct</span>(<span class="fu">list</span>(</span>
<span id="cb61-662"><a href="#cb61-662" aria-hidden="true" tabindex="-1"></a>  <span class="at">nop =</span> <span class="fu">po</span>(<span class="st">"nop"</span>),</span>
<span id="cb61-663"><a href="#cb61-663" aria-hidden="true" tabindex="-1"></a>  <span class="at">pca =</span> <span class="fu">po</span>(<span class="st">"pca"</span>),</span>
<span id="cb61-664"><a href="#cb61-664" aria-hidden="true" tabindex="-1"></a>  <span class="at">yeojohnson =</span> <span class="fu">po</span>(<span class="st">"removeconstants"</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"yeojohnson"</span>)</span>
<span id="cb61-665"><a href="#cb61-665" aria-hidden="true" tabindex="-1"></a>))</span>
<span id="cb61-666"><a href="#cb61-666" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-667"><a href="#cb61-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-668"><a href="#cb61-668" aria-hidden="true" tabindex="-1"></a>For the <span class="in">`"learner"`</span> proxy, this is more complicated as the selection of the learner depends on more than one search space component:</span>
<span id="cb61-669"><a href="#cb61-669" aria-hidden="true" tabindex="-1"></a>The choice of the learner itself (<span class="in">`lrn("classif.rpart")`</span> or <span class="in">`lrn("classif.kknn")`</span>) and the tuned <span class="in">`k`</span> hyperparameter of the KNN learner.</span>
<span id="cb61-670"><a href="#cb61-670" aria-hidden="true" tabindex="-1"></a>To enable this we pass a transformation to <span class="in">`.extra_trafo`</span> (@sec-tune-trafo).</span>
<span id="cb61-671"><a href="#cb61-671" aria-hidden="true" tabindex="-1"></a>Note that inside this transformation we clone <span class="in">`learner.content`</span>, otherwise, we would end up modifying the original <span class="in">`r ref("Learner")`</span> object inside the search space by reference (@sec-r6).</span>
<span id="cb61-672"><a href="#cb61-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-673"><a href="#cb61-673" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-045}</span></span>
<span id="cb61-674"><a href="#cb61-674" aria-hidden="true" tabindex="-1"></a><span class="co"># define content for the learner proxy operator</span></span>
<span id="cb61-675"><a href="#cb61-675" aria-hidden="true" tabindex="-1"></a>learner.content <span class="ot">=</span> <span class="fu">p_fct</span>(<span class="fu">list</span>(</span>
<span id="cb61-676"><a href="#cb61-676" aria-hidden="true" tabindex="-1"></a>    <span class="at">classif.rpart =</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb61-677"><a href="#cb61-677" aria-hidden="true" tabindex="-1"></a>    <span class="at">classif.kknn =</span> <span class="fu">lrn</span>(<span class="st">"classif.kknn"</span>)</span>
<span id="cb61-678"><a href="#cb61-678" aria-hidden="true" tabindex="-1"></a>))</span>
<span id="cb61-679"><a href="#cb61-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-680"><a href="#cb61-680" aria-hidden="true" tabindex="-1"></a><span class="co"># define transformation to set the content values</span></span>
<span id="cb61-681"><a href="#cb61-681" aria-hidden="true" tabindex="-1"></a>trafo <span class="ot">=</span> <span class="cf">function</span>(x, param_set) {</span>
<span id="cb61-682"><a href="#cb61-682" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(x<span class="sc">$</span>classif.kknn.k)) {</span>
<span id="cb61-683"><a href="#cb61-683" aria-hidden="true" tabindex="-1"></a>      x<span class="sc">$</span>learner.content <span class="ot">=</span> x<span class="sc">$</span>learner.content<span class="sc">$</span><span class="fu">clone</span>(<span class="at">deep =</span> <span class="cn">TRUE</span>)</span>
<span id="cb61-684"><a href="#cb61-684" aria-hidden="true" tabindex="-1"></a>      x<span class="sc">$</span>learner.content<span class="sc">$</span>param_set<span class="sc">$</span>values<span class="sc">$</span>k <span class="ot">=</span> x<span class="sc">$</span>classif.kknn.k</span>
<span id="cb61-685"><a href="#cb61-685" aria-hidden="true" tabindex="-1"></a>      x<span class="sc">$</span>classif.kknn.k <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb61-686"><a href="#cb61-686" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb61-687"><a href="#cb61-687" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb61-688"><a href="#cb61-688" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb61-689"><a href="#cb61-689" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-690"><a href="#cb61-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-691"><a href="#cb61-691" aria-hidden="true" tabindex="-1"></a>We can now put this all together, add the KNN tuning, and run the experiment.</span>
<span id="cb61-692"><a href="#cb61-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-693"><a href="#cb61-693" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-046}</span></span>
<span id="cb61-694"><a href="#cb61-694" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb61-695"><a href="#cb61-695" aria-hidden="true" tabindex="-1"></a>  <span class="at">preproc.content =</span> preproc.content,</span>
<span id="cb61-696"><a href="#cb61-696" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner.content =</span> learner.content,</span>
<span id="cb61-697"><a href="#cb61-697" aria-hidden="true" tabindex="-1"></a>  <span class="co"># tune KKNN parameter as normal</span></span>
<span id="cb61-698"><a href="#cb61-698" aria-hidden="true" tabindex="-1"></a>  <span class="at">classif.kknn.k =</span> <span class="fu">p_int</span>(<span class="dv">1</span>, <span class="dv">32</span>,</span>
<span id="cb61-699"><a href="#cb61-699" aria-hidden="true" tabindex="-1"></a>    <span class="at">depends =</span> learner.content <span class="sc">==</span> <span class="st">"classif.kknn"</span>),</span>
<span id="cb61-700"><a href="#cb61-700" aria-hidden="true" tabindex="-1"></a>  <span class="at">.extra_trafo =</span> trafo</span>
<span id="cb61-701"><a href="#cb61-701" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-702"><a href="#cb61-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-703"><a href="#cb61-703" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(<span class="fu">tnr</span>(<span class="st">"grid_search"</span>), tsk_mnist, graph_learner,</span>
<span id="cb61-704"><a href="#cb61-704" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"repeated_cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>, <span class="at">repeats =</span> <span class="dv">3</span>), <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb61-705"><a href="#cb61-705" aria-hidden="true" tabindex="-1"></a>  <span class="at">search_space =</span> search_space)</span>
<span id="cb61-706"><a href="#cb61-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-707"><a href="#cb61-707" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>result)[,</span>
<span id="cb61-708"><a href="#cb61-708" aria-hidden="true" tabindex="-1"></a>  .(preproc.content,</span>
<span id="cb61-709"><a href="#cb61-709" aria-hidden="true" tabindex="-1"></a>    <span class="at">classif.kknn.k =</span> x_domain[[<span class="dv">1</span>]]<span class="sc">$</span>learner.content<span class="sc">$</span>param_set<span class="sc">$</span>values<span class="sc">$</span>k,</span>
<span id="cb61-710"><a href="#cb61-710" aria-hidden="true" tabindex="-1"></a>    learner.content, classif.ce)</span>
<span id="cb61-711"><a href="#cb61-711" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb61-712"><a href="#cb61-712" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-713"><a href="#cb61-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-714"><a href="#cb61-714" aria-hidden="true" tabindex="-1"></a>Once again, the best configuration is a KNN learner with the Yeo-Johnson transform.</span>
<span id="cb61-715"><a href="#cb61-715" aria-hidden="true" tabindex="-1"></a>In practice <span class="in">`po("proxy")`</span> offers complete flexibility and may be more useful for more complicated use cases, whereas <span class="in">`ppl("branch")`</span> is more efficient in more straightforward scenarios.</span>
<span id="cb61-716"><a href="#cb61-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-717"><a href="#cb61-717" aria-hidden="true" tabindex="-1"></a><span class="fu">### Hyperband with Subsampling {#sec-hyperband-example-svm}</span></span>
<span id="cb61-718"><a href="#cb61-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-719"><a href="#cb61-719" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb61-720"><a href="#cb61-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-721"><a href="#cb61-721" aria-hidden="true" tabindex="-1"></a>In @sec-hyperband we learned about the <span class="in">`r index('Hyperband')`</span> tuner and how it can make use of <span class="in">`r index('fidelity parameters')`</span> to efficiently tune learners.</span>
<span id="cb61-722"><a href="#cb61-722" aria-hidden="true" tabindex="-1"></a>Now that you have learned about pipelines and how to tune them, in this short section we will briefly return to Hyperband to showcase how we can put together everything we have learned in this chapter to allow Hyperband to be used with any <span class="in">`Learner`</span>.</span>
<span id="cb61-723"><a href="#cb61-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-724"><a href="#cb61-724" aria-hidden="true" tabindex="-1"></a>We previously saw how some learners have hyperparameters that can act naturally as fidelity parameters, such as the number of trees in a random forest.</span>
<span id="cb61-725"><a href="#cb61-725" aria-hidden="true" tabindex="-1"></a>However, using pipelines, we can now create a fidelity parameter for any model using <span class="in">`po("subsample")`</span>.</span>
<span id="cb61-726"><a href="#cb61-726" aria-hidden="true" tabindex="-1"></a>The <span class="in">`frac`</span> parameter of <span class="in">`po("subsample")`</span> controls the amount of data fed into the subsequent <span class="in">`Learner`</span>.</span>
<span id="cb61-727"><a href="#cb61-727" aria-hidden="true" tabindex="-1"></a>In general, feeding less data to a <span class="in">`Learner`</span> results in quicker model training but poorer quality predictions compared to when more training data is supplied.</span>
<span id="cb61-728"><a href="#cb61-728" aria-hidden="true" tabindex="-1"></a>Resampling with less data will still give us some information about the relative performance of different model configurations, thus making the fraction of data to subsample the perfect candidate for a fidelity parameter.</span>
<span id="cb61-729"><a href="#cb61-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-730"><a href="#cb61-730" aria-hidden="true" tabindex="-1"></a>In this example, we will optimize the SVM\index{support vector machine} hyperparameters, <span class="in">`cost`</span> and <span class="in">`gamma`</span>, on <span class="in">`tsk("sonar")`</span>:</span>
<span id="cb61-731"><a href="#cb61-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-732"><a href="#cb61-732" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-047}</span></span>
<span id="cb61-733"><a href="#cb61-733" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3tuning)</span>
<span id="cb61-734"><a href="#cb61-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-735"><a href="#cb61-735" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">id =</span> <span class="st">"svm"</span>, <span class="at">type =</span> <span class="st">"C-classification"</span>,</span>
<span id="cb61-736"><a href="#cb61-736" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>, <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb61-737"><a href="#cb61-737" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>))</span>
<span id="cb61-738"><a href="#cb61-738" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-739"><a href="#cb61-739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-740"><a href="#cb61-740" aria-hidden="true" tabindex="-1"></a>We then construct <span class="in">`po("subsample")`</span> and specify that we want to use the <span class="in">`frac`</span> parameter between $<span class="co">[</span><span class="ot">3^{-3}, 1</span><span class="co">]</span>$ as our fidelity parameter and set the <span class="in">`"budget"`</span> tag to pass this information to Hyperband.</span>
<span id="cb61-741"><a href="#cb61-741" aria-hidden="true" tabindex="-1"></a>We add this to our SVM and create a <span class="in">`r ref("GraphLearner")`</span>.</span>
<span id="cb61-742"><a href="#cb61-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-743"><a href="#cb61-743" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-048}</span></span>
<span id="cb61-744"><a href="#cb61-744" aria-hidden="true" tabindex="-1"></a>graph_learner <span class="ot">=</span> <span class="fu">as_learner</span>(</span>
<span id="cb61-745"><a href="#cb61-745" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"subsample"</span>, <span class="at">frac =</span> <span class="fu">to_tune</span>(<span class="fu">p_dbl</span>(<span class="dv">3</span><span class="sc">^-</span><span class="dv">3</span>, <span class="dv">1</span>, <span class="at">tags =</span> <span class="st">"budget"</span>))) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb61-746"><a href="#cb61-746" aria-hidden="true" tabindex="-1"></a>  learner</span>
<span id="cb61-747"><a href="#cb61-747" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-748"><a href="#cb61-748" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-749"><a href="#cb61-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-750"><a href="#cb61-750" aria-hidden="true" tabindex="-1"></a>As good practice, we encapsulate our learner and add a fallback to prevent fatal errors (@sec-tuning-errors).</span>
<span id="cb61-751"><a href="#cb61-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-752"><a href="#cb61-752" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-049}</span></span>
<span id="cb61-753"><a href="#cb61-753" aria-hidden="true" tabindex="-1"></a>graph_learner<span class="sc">$</span><span class="fu">encapsulate</span>(<span class="st">"evaluate"</span>, <span class="fu">lrn</span>(<span class="st">"classif.featureless"</span>))</span>
<span id="cb61-754"><a href="#cb61-754" aria-hidden="true" tabindex="-1"></a>graph_learner<span class="sc">$</span>timeout <span class="ot">=</span> <span class="fu">c</span>(<span class="at">train =</span> <span class="dv">30</span>, <span class="at">predict =</span> <span class="dv">30</span>)</span>
<span id="cb61-755"><a href="#cb61-755" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-756"><a href="#cb61-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-757"><a href="#cb61-757" aria-hidden="true" tabindex="-1"></a>Now we can tune our SVM by tuning our <span class="in">`GraphLearner`</span> as normal, below we set <span class="in">`eta = 3`</span> for Hyperband.</span>
<span id="cb61-758"><a href="#cb61-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-759"><a href="#cb61-759" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-050}</span></span>
<span id="cb61-760"><a href="#cb61-760" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(<span class="fu">tnr</span>(<span class="st">"hyperband"</span>, <span class="at">eta =</span> <span class="dv">3</span>), <span class="fu">tsk</span>(<span class="st">"sonar"</span>), graph_learner,</span>
<span id="cb61-761"><a href="#cb61-761" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>), <span class="fu">msr</span>(<span class="st">"classif.ce"</span>))</span>
<span id="cb61-762"><a href="#cb61-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-763"><a href="#cb61-763" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result_x_domain</span>
<span id="cb61-764"><a href="#cb61-764" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-765"><a href="#cb61-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-766"><a href="#cb61-766" aria-hidden="true" tabindex="-1"></a><span class="fu">### Feature Selection with Filter Pipelines {#sec-pipelines-featsel}</span></span>
<span id="cb61-767"><a href="#cb61-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-768"><a href="#cb61-768" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb61-769"><a href="#cb61-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-770"><a href="#cb61-770" aria-hidden="true" tabindex="-1"></a>In @sec-fs-filter-based we learnt about filter-based <span class="in">`r index('feature selection')`</span> and how we can manually run a filter and then extract the selected features, often using an arbitrary choice of thresholds that were not tuned.</span>
<span id="cb61-771"><a href="#cb61-771" aria-hidden="true" tabindex="-1"></a>Now that we have covered pipelines and tuning, we will briefly return to feature selection to demonstrate how to automate filter-based feature selection by making use of <span class="in">`po("filter")`</span>.</span>
<span id="cb61-772"><a href="#cb61-772" aria-hidden="true" tabindex="-1"></a><span class="in">`po("filter")`</span> includes the <span class="in">`filter`</span> construction argument, which takes a <span class="in">`r ref("Filter")`</span> object to be used as the filter method as well as a choice of parameters for different methods of selecting features:</span>
<span id="cb61-773"><a href="#cb61-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-774"><a href="#cb61-774" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`filter.nfeat`</span> -- Number of features to select</span>
<span id="cb61-775"><a href="#cb61-775" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`filter.frac`</span> -- Fraction of features to select</span>
<span id="cb61-776"><a href="#cb61-776" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`filter.cutoff`</span> -- Minimum value of filter such that features with filter values greater than or equal to the cutoff are kept</span>
<span id="cb61-777"><a href="#cb61-777" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`filter.permuted`</span> -- Random permutation of features added to task before applying the filter and all features before the <span class="in">`permuted`</span>-th permuted features are kept</span>
<span id="cb61-778"><a href="#cb61-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-779"><a href="#cb61-779" aria-hidden="true" tabindex="-1"></a>Below we use the information gain filter and select the top three features:</span>
<span id="cb61-780"><a href="#cb61-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-781"><a href="#cb61-781" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-051, warning = FALSE, message = FALSE}</span></span>
<span id="cb61-782"><a href="#cb61-782" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3filters)</span>
<span id="cb61-783"><a href="#cb61-783" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3fselect)</span>
<span id="cb61-784"><a href="#cb61-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-785"><a href="#cb61-785" aria-hidden="true" tabindex="-1"></a>task_pen <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb61-786"><a href="#cb61-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-787"><a href="#cb61-787" aria-hidden="true" tabindex="-1"></a><span class="co"># combine filter (keep top 3 features) with learner</span></span>
<span id="cb61-788"><a href="#cb61-788" aria-hidden="true" tabindex="-1"></a>po_flt <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"filter"</span>, <span class="at">filter =</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>), <span class="at">filter.nfeat =</span> <span class="dv">3</span>)</span>
<span id="cb61-789"><a href="#cb61-789" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> po_flt <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"learner"</span>, <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>))</span>
<span id="cb61-790"><a href="#cb61-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-791"><a href="#cb61-791" aria-hidden="true" tabindex="-1"></a><span class="fu">po</span>(<span class="st">"filter"</span>, <span class="at">filter =</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>), <span class="at">filter.nfeat =</span> <span class="dv">3</span>)<span class="sc">$</span></span>
<span id="cb61-792"><a href="#cb61-792" aria-hidden="true" tabindex="-1"></a>  <span class="fu">train</span>(<span class="fu">list</span>(task_pen))[[<span class="dv">1</span>]]<span class="sc">$</span>feature_names</span>
<span id="cb61-793"><a href="#cb61-793" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-794"><a href="#cb61-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-795"><a href="#cb61-795" aria-hidden="true" tabindex="-1"></a>Choosing <span class="in">`3`</span> as the cutoff was fairly arbitrary but by tuning a graph we can optimize this cutoff:</span>
<span id="cb61-796"><a href="#cb61-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-797"><a href="#cb61-797" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-052}</span></span>
<span id="cb61-798"><a href="#cb61-798" aria-hidden="true" tabindex="-1"></a><span class="co"># tune between 1 and total number of features</span></span>
<span id="cb61-799"><a href="#cb61-799" aria-hidden="true" tabindex="-1"></a>po_filter <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"filter"</span>, <span class="at">filter =</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>),</span>
<span id="cb61-800"><a href="#cb61-800" aria-hidden="true" tabindex="-1"></a>  <span class="at">filter.nfeat =</span> <span class="fu">to_tune</span>(<span class="dv">1</span>, task_pen<span class="sc">$</span>ncol))</span>
<span id="cb61-801"><a href="#cb61-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-802"><a href="#cb61-802" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">as_learner</span>(po_filter <span class="sc">%&gt;&gt;%</span> <span class="fu">po</span>(<span class="st">"learner"</span>, <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)))</span>
<span id="cb61-803"><a href="#cb61-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-804"><a href="#cb61-804" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(<span class="fu">tnr</span>(<span class="st">"random_search"</span>), task_pen, graph,</span>
<span id="cb61-805"><a href="#cb61-805" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>), <span class="at">term_evals =</span> <span class="dv">10</span>)</span>
<span id="cb61-806"><a href="#cb61-806" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result</span>
<span id="cb61-807"><a href="#cb61-807" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-808"><a href="#cb61-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-809"><a href="#cb61-809" aria-hidden="true" tabindex="-1"></a>In this example, ``r instance$result$information_gain.filter.nfeat`` is the optimal number of features.</span>
<span id="cb61-810"><a href="#cb61-810" aria-hidden="true" tabindex="-1"></a>It can be especially useful in feature selection to visualize the tuning results as there may be cases where the optimal result is only marginally better than a result with less features (which would lead to a model that is quicker to train and possibly easier to interpret).</span>
<span id="cb61-811"><a href="#cb61-811" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-812"><a href="#cb61-812" aria-hidden="true" tabindex="-1"></a><span class="in">```{r non-sequential_pipelines_and_tuning-053}</span></span>
<span id="cb61-813"><a href="#cb61-813" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-tunefilter</span></span>
<span id="cb61-814"><a href="#cb61-814" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Model performance with different numbers of features, selected by an information gain filter.</span></span>
<span id="cb61-815"><a href="#cb61-815" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Plot showing model performance in filter-based feature selection, showing that adding a second, third, and fourth feature to the model improves performance, while adding more features achieves no further performance gain.</span></span>
<span id="cb61-816"><a href="#cb61-816" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(instance)</span>
<span id="cb61-817"><a href="#cb61-817" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb61-818"><a href="#cb61-818" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-819"><a href="#cb61-819" aria-hidden="true" tabindex="-1"></a>Now we can see that four variables may be equally as good in this case so we could consider going forward by selecting four features and not six as suggested by <span class="in">`instance$result`</span>.</span>
<span id="cb61-820"><a href="#cb61-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-821"><a href="#cb61-821" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb61-822"><a href="#cb61-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-823"><a href="#cb61-823" aria-hidden="true" tabindex="-1"></a>In this chapter, we built on what we learned in @sec-pipelines to develop complex non-sequential <span class="in">`Graph`</span>s.</span>
<span id="cb61-824"><a href="#cb61-824" aria-hidden="true" tabindex="-1"></a>We saw how to build our own graphs, as well as how to make use of <span class="in">`ppl()`</span> to load <span class="in">`Graph`</span>s that are available in <span class="in">`r mlr3pipelines`</span>.</span>
<span id="cb61-825"><a href="#cb61-825" aria-hidden="true" tabindex="-1"></a>We then looked at different ways to tune pipelines, including joint tuning of hyperparameters and tuning the selection of <span class="in">`PipeOp`</span>s in a <span class="in">`Graph`</span>, enabling the construction of simple, custom AutoML systems.</span>
<span id="cb61-826"><a href="#cb61-826" aria-hidden="true" tabindex="-1"></a>In @sec-preprocessing we will study in more detail how to use pipelines for data preprocessing.</span>
<span id="cb61-827"><a href="#cb61-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-828"><a href="#cb61-828" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Class <span class="pp">|</span> Constructor/Function <span class="pp">|</span> Fields/Methods <span class="pp">|</span></span>
<span id="cb61-829"><a href="#cb61-829" aria-hidden="true" tabindex="-1"></a><span class="pp">| ---</span> <span class="pp">| ---</span> <span class="pp">| ---</span> <span class="pp">|</span></span>
<span id="cb61-830"><a href="#cb61-830" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("Graph")`</span> <span class="pp">|</span> <span class="in">`r ref("ppl()")`</span> <span class="pp">|</span> <span class="in">`$train()`</span>; <span class="in">`$predict()`</span> <span class="pp">|</span></span>
<span id="cb61-831"><a href="#cb61-831" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("Selector")`</span> <span class="pp">|</span> <span class="in">`r ref("selector_grep()")`</span>; <span class="in">`r ref("selector_type()")`</span>; <span class="in">`r ref("selector_invert()")`</span> <span class="pp">|</span> - <span class="pp">|</span></span>
<span id="cb61-832"><a href="#cb61-832" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("PipeOpBranch")`</span>; <span class="in">`r ref("PipeOpUnbranch")`</span> <span class="pp">|</span> <span class="in">`po("branch")`</span>; <span class="in">`po("unbranch")`</span> <span class="pp">|</span> - <span class="pp">|</span></span>
<span id="cb61-833"><a href="#cb61-833" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> <span class="in">`r ref("PipeOpProxy")`</span> <span class="pp">|</span> <span class="in">`po("proxy")`</span> <span class="pp">|</span> - <span class="pp">|</span></span>
<span id="cb61-834"><a href="#cb61-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-835"><a href="#cb61-835" aria-hidden="true" tabindex="-1"></a>: Important classes and functions covered in this chapter with underlying class (if applicable), class constructor or function, and important class fields and methods (if applicable). {#tbl-api-pipelines-nonseq}</span>
<span id="cb61-836"><a href="#cb61-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-837"><a href="#cb61-837" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercises</span></span>
<span id="cb61-838"><a href="#cb61-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-839"><a href="#cb61-839" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Create a graph that replaces all numeric columns that do not contain missing values with their PCA transform.</span>
<span id="cb61-840"><a href="#cb61-840" aria-hidden="true" tabindex="-1"></a>  Solve this in two ways, using <span class="in">`affect_columns`</span> in a sequential graph, and using <span class="in">`po("select")`</span> in a non-sequential graph.</span>
<span id="cb61-841"><a href="#cb61-841" aria-hidden="true" tabindex="-1"></a>  Train the graph on <span class="in">`tsk("pima")`</span> to check your result.</span>
<span id="cb61-842"><a href="#cb61-842" aria-hidden="true" tabindex="-1"></a>  Hint: You may find <span class="in">`selector_missing()`</span> useful.</span>
<span id="cb61-843"><a href="#cb61-843" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The <span class="in">`po("select")`</span> in @sec-pipelines-stack is necessary to remove redundant predictions (recall this is a binary classification task so we do not require predictions of both classes).</span>
<span id="cb61-844"><a href="#cb61-844" aria-hidden="true" tabindex="-1"></a>  However, if this was a multiclass classification task, then using <span class="in">`selector_grep()`</span> would need to be called with a pattern for *all* prediction columns that should be *kept*, which would be inefficient.</span>
<span id="cb61-845"><a href="#cb61-845" aria-hidden="true" tabindex="-1"></a>  Instead it would be more appropriate to provide a pattern for the single class to remove.</span>
<span id="cb61-846"><a href="#cb61-846" aria-hidden="true" tabindex="-1"></a>  How would you do this using the <span class="in">`Selector`</span> functions provided by <span class="in">`mlr3pipelines`</span>?</span>
<span id="cb61-847"><a href="#cb61-847" aria-hidden="true" tabindex="-1"></a>  Implement this and train the modified stacking pipeline on <span class="in">`tsk("wine")`</span>, using <span class="in">`lrn("classif.multinom")`</span> as the level 1 learner.</span>
<span id="cb61-848"><a href="#cb61-848" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>How would you solve the previous exercise without explicitly naming the class you want to exclude, so that your graph works for any classification task?</span>
<span id="cb61-849"><a href="#cb61-849" aria-hidden="true" tabindex="-1"></a>  Hint: look at the <span class="in">`selector_subsample`</span> in @sec-pipelines-bagging.</span>
<span id="cb61-850"><a href="#cb61-850" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>(*) Create your own "minimal AutoML system" by combining pipelines, branching and tuning.</span>
<span id="cb61-851"><a href="#cb61-851" aria-hidden="true" tabindex="-1"></a>  It should allow automatic preprocessing and the automatic selection of a well-performing learning algorithm.</span>
<span id="cb61-852"><a href="#cb61-852" aria-hidden="true" tabindex="-1"></a>  Both your <span class="in">`PipeOp`</span>s and models should be tuned.</span>
<span id="cb61-853"><a href="#cb61-853" aria-hidden="true" tabindex="-1"></a>  Your system should feature options for two preprocessing steps (imputation and factor encoding) and at least three learning algorithms to choose from.</span>
<span id="cb61-854"><a href="#cb61-854" aria-hidden="true" tabindex="-1"></a>  You can optimize this via random search, or try to use a more advanced tuning algorithm.</span>
<span id="cb61-855"><a href="#cb61-855" aria-hidden="true" tabindex="-1"></a>  Test it on at least three different data sets and compare its performance against an untuned random forest via nested resampling.</span>
<span id="cb61-856"><a href="#cb61-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-857"><a href="#cb61-857" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb61-858"><a href="#cb61-858" aria-hidden="true" tabindex="-1"></a><span class="in">`r citeas(chapter)`</span></span>
<span id="cb61-859"><a href="#cb61-859" aria-hidden="true" tabindex="-1"></a>:::</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
<p>All content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> <br> © Bernd Bischl, Raphael Sonabend, Lars Kotthoff, Michel Lang.</p>
</div>   
    <div class="nav-footer-center">
<p><a href="https://mlr-org.com">Website</a> | <a href="https://github.com/mlr-org/mlr3book">GitHub</a> | <a href="https://mlr-org.com/gallery">Gallery</a> | <a href="https://lmmisld-lmu-stats-slds.srv.mwn.de/mlr_invite/">Mattermost</a></p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter8/non-sequential_pipelines_and_tuning.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter8/non-sequential_pipelines_and_tuning.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>


<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>