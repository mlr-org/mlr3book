---
author:
  - name: Raphael Sonabend
    orcid: 0000-0001-9225-4654
    email: raphaelsonabend@gmail.com
    affiliations:
      - name: Imperial College London
  - name: Patrick Schratz
    orcid: 0000-0003-0748-6624
    email:
    affiliations:
      - name: .
  - name: Damir Pulatov
    orcid: 0000-0003-4901-7201
    email:
    affiliations:
      - name: University of Wyoming
  - name: Florian Pfisterer
    orcid: 0000-0001-8867-762X
    email:
    affiliations:
      - name: Ludwig-Maximilians-Universität München
abstract: Previous chapters have considered the core functionality of functions and features in the mlr3 universe and other helper packages, which altogether create a modular ecosystem. This chapter uses that modularity to discuss tasks beyond deterministic regression and single-label classification. The chapter starts with cost-sensitive classification, which makes use of mlr3, mlr3tuning, and mlr3pipelines to implement a classification task in which different types of errors have different costs. Next, the chapter looks at probabilistic regression, which is a regression problem where the prediction is a distribution and not a single point prediction. We first discuss how this is implemented in mlr3 and how this is extended in mlr3proba. We then discuss survival analysis and density estimation, which are both implemented in mlr3proba and make use of the distr6 package for distribution predictions. After these tasks, we look at unsupervised learning in the form of clustering with mlr3cluster, and then finally spatial analysis with mlr3spatial and mlr3spatiotempcv. As some or all of these tasks may be new to some readers, we include an overview to the theory behind each, before looking at the extensions to common mlr3 objects (learners, predictions, tasks, and measures), and then finally consider task-specific extensions.
---

```{r special-001, include = FALSE}
set.seed(8)
```

# Beyond Deterministic Regression and Single-Label Classification {#sec-special}

{{< include _setup.qmd >}}

The chapter title reflects that up until now we have only considered two tasks, regression (specifically deterministic), and classification (specifically single-label).
So far, this book has focused on detailed explanation of the `r mlr3` universe of packages, which is abstracted in such a way that allows users to choose the level of complexity that suits each project.
For example, you could limit your usage of these packages to just `r mlr3` to train a very small subset of regression and classification learners on a set of data and then use your model to make predictions for new unseen data.
You could extend this to many regression and classification learners with `r mlr3learners` and `r mlr3extralearners`.
By making use of `r mlr3tuning` and `r mlr3pipelines` you could optimize your model further including with pre- and post-processing of data and algorithms.
However, the real power of the `r mlr3` universe, is in its ability to take *all* of these features, and extend them to many machine learning tasks.

In @sec-basics we introduced deterministic regression and deterministic & probabilistic single-label classification (@tbl-alltasks).
But our infrastructure also works well for survival analysis, density estimation, clustering, spatiotemporal analysis, time-series forecasting, deep learning architectures, image analysis, multi-label classification, probabilistic regression, and many more.
Some of these tasks are implemented in extension packages as part of the `r mlr3` universe (see @fig-mlr3verse), some are available by creating pipelines with `r mlr3pipelines`, some are in development, and some are waiting to be developed (maybe by some readers of this book).
In this chapter, we will take you through just a subset of these new tasks, focusing on the ones that have a stable API.
As we work through this chapter we will refer to the 'building blocks' of `r mlr3`, this refers to the base classes that must be extended to create new tasks, these are `r ref("Prediction")`, `r ref("Learner")`, `r ref("Measure")`, and `r ref("Task")`.

@tbl-alltasks summarizes available extension tasks, including the package(s) they are implemented in, the stability of the task implementation, and a brief description.
Only tasks with stable APIs are discussed in this chapter, the table also includes tasks in development.

| Task | Package | Status | Description |
| ---- | ------- | ------ | --------------- |
| Deterministic regression | `r mlr3` | Stable | Point prediction of a continuous variable. |
| Probabilistic regression | `r mlr3` and `r mlr3proba` | Stable | Probability distribution prediction of a continuous variable. |
| Deterministic single-label classification | `r mlr3` | Stable | Prediction of a single class an observation falls into. |
| Probabilistic single-label classification | `r mlr3` | Stable | Prediction of the probability of an observation falling into one or more mutually exclusive categories. |
| Cost-sensitive classification | `r mlr3` and `r mlr3pipelines` | Stable | Classification predictions with unequal costs associated with misclassifications. |
| Survival analysis | `r mlr3proba` | Stable | Time-to-event predictions with possible 'censoring'. |
| Density estimation | `r mlr3proba` | Stable | Unsupervised estimation of probability density functions. |
| Spatiotemporal analysis | `r mlr3spatiotempcv` and `r mlr3spatial` | Stable | Supervised prediction of data with spatial (e.g., coordinates) and/or temporal outcomes. |
| Fairness-aware ML | [`mlr3fairness`](https://github.com/mlr-org/mlr3fairness) | Stable | Fairness audits and fair supervised learning. |
| Cluster analysis | `r mlr3cluster` | Stable | Unsupervised estimation of homogeneous clusters of data points. |
| Time series forecasting | [`mlr3temporal`](https://github.com/mlr-org/mlr3temporal) | Developing | Supervised predictions of target over time (e.g., daily temperature). |
| Functional data analysis | [`mlr3fda`](https://github.com/mlr-org/mlr3fda) | Developing | Supervised predictions from functional data. |


: Table of extension tasks that can be used with `r mlr3` infrastructure. 'Stable' tasks have an interface that is unlikely to undergo any major changes in the future, these tasks are discussed in this chapter. 'Developing' tasks are in packages that might have breaking API changes. As we have a growing community of contributors, this list is far from exhaustive and many 'experimental' task implementations exist; this list just represents the tasks that have a functioning interface. {#tbl-alltasks}

## Cost-Sensitive Classification {#cost-sens}

We begin by discussing a task that does not require any additional packages or infrastructure, only the tools we have already learnt about from earlier chapters.
In 'regular' classification, the aim is to optimize a metric (often the misclassification rate) whilst assuming all misclassification errors are deemed equally severe.
A more general setting is `r define("cost-sensitive classification", index = "classification!cost-sensitive classification")`, in which costs caused by different kinds of errors may not be equal.
The objective of cost-sensitive classification is to minimize the expected costs.
As we discuss this task we will work with `r ref("mlr_tasks_german_credit")` (@sec-appendix-tasks) as a running example.

Imagine in this task that an insurance company, InsureU, provides fixed loans of \$5K over a one year period and customers are expected to pay back \$6K at the end of this period.
InsureU needs to be predict if a new customer will have good credit to decide if a loan should be given.
This is a deterministic classification problem where InsureU is classifying if a customer will be in class 'Good' or 'Bad'.
Now we can write up the potential costs associated with each prediction and the eventual truth:

```{r special-002}
costs = matrix(c(-1, 0, 5, 0), nrow = 2, dimnames =
  list("Predicted Credit" = c("good", "bad"),
    Truth = c("good", "bad")))
costs
```

If InsureU thinks a customer has bad credit then there is no profit or loss, the loan is not provided.
If a customer has good credit and returns the loan then InsureU makes a \$1K profit, but if they default then InsureU loses \$5K.
Note that cost-sensitive classification is a minimization problem where we assume lower costs mean higher profits/positive outcomes, hence above we wrote the profit and loss as `-1` and `+5` respectively.

### Cost-sensitive Measure

We will now see how to implement a more nuanced approach to classification errors with `r ref("MeasureClassifCosts")`.
This measure takes one argument, which is a matrix with row and column names corresponding to the class labels in the task of interest.
Let's put our insurance example into practice, notice that we have already named the cost matrix as required for the measure:

```{r special-003}
library(mlr3verse)

task = tsk("german_credit")

cost_measure = msr("classif.costs", costs = costs)
cost_measure

learners = lrns(
  paste0("classif.", c("log_reg", "featureless", "ranger")))
bmr = benchmark(benchmark_grid(task, learners, rsmp("cv", folds = 3)))
bmr$aggregate(cost_measure)[, c(4, 7)]
```

In this experiment we find that the logistic regression learner happens to perform best as it minimizes the expected costs (and maximizes expected profits) and the featureless learner performs the worst.
However, we could improve this prediction by considering thresholding.

### Thresholding

As we have discussed in @sec-basics, `r index("thresholding")` is a method to determine at what probability an observation will fall into one outcome class or another.
Currently in our running example, the models above will predict a customer has good credit (in the class 'Good') if the probability of good credit is greater than 0.5.
However, this may not be a sensible approach as the cost of a false positive and false negative is not equal.
In fact, a false positive results in a cost of +5 whereas a false negative only results in a cost of 0, hence we would prefer a model with a higher false negative rates and lower false positive rates.
This is highlighted in the `"threshold"` `autoplot`:

```{r special-004}
prediction = lrn("classif.log_reg",
  predict_type = "prob")$train(task)$predict(task)
autoplot(prediction, type = "threshold", measure = cost_measure)
```

As expected, the optimal threshold is greater than 0.5, indicating that to maximize profits, the majority of observations should be predicted to have bad credit.

To automate the process of optimizing the threshold, we can make use of `r mlr3tuning` (@sec-optimization) and `r mlr3pipelines` (@sec-pipelines) by creating a graph with `r ref("PipeOpTuneThreshold")`.
Continuing the same example:

```{r special-005}
gr = po("learner_cv", lrn("classif.log_reg", predict_type = "prob")) %>>%
  po("tunethreshold", measure = cost_measure)

learners = list(as_learner(gr), lrn("classif.log_reg"))
bmr = benchmark(benchmark_grid(task, learners, rsmp("cv", folds = 3)))
bmr$aggregate(cost_measure)[, c(4, 7)]
```

As expected, our tuned learner performs much better and may even make InsureU a profit not a loss.

## Probabilistic Regression {#sec-probregr}

`r index("Probabilistic regression")` is a simple extension to deterministic regression in which the goal is to predict a full distribution around a single '`r index("point prediction")`'.
By example, instead of just predicting someone's height, $\mu$, we could also predict how confident we are about our prediction, usually estimated as a standard error, $\sigma$.
This 'confidence' could be expressed as a confidence interval, for example $\mu \pm \sigma$, or by assuming a distribution, for example $\mathcal{N}(\mu, \sigma)$.

### Confidence interval predictions

Predicting a `r index("confidence interval")` is possible using only features in `r mlr3`.
Several (but not all) implemented regression learners can make standard error predictions by setting `predict_type = "se"`.
For compatible learners this means the learner will predict both the 'usual' `response` predict type, as well as the standard error of the prediction, `se`.
Manually combining these predict types leads to a confidence interval.
An example is in @fig-probregrconfint where we assume a symmetric Normal 95% confidence interval.

```{r special-006, warning=FALSE}
#| fig-alt: x-label says "Response plus-minus 1.96se" and y-label says "Truth". Plot shows a black line running through the x=y axis. 7 blue points are plotted with error bars. Plot shows that 3 points are lying on the x=y line. Other points are not on the line and their error bars do not overlap with the line either.
#| fig-cap: Scatter plot of predictions (x) vs truth (y) where the straight line is $x=y$. Points lying on $x=y$ indicate good (mean) predictions, points with error bars overlapping $x=y$ indicates truth is within 95% confidence interval.
#| label: fig-probregrconfint
t = tsk("mtcars")
split = partition(t)
l = lrn("regr.ranger", predict_type = "se")
l$train(t, split$train)
p = l$predict(t, split$test)
p
autoplot(p, type = "confidence", quantile = 1.96)
```

This representation is more informative than a standard 'point prediction' as it includes confidence about the predictions.
For example, the top prediction in @fig-probregrconfint might seem like a 'good' prediction as the mean response is close to the truth.
However, the error bars suggest that we actually have low confidence in the prediction.
On the other hand, the fourth prediction from the top is slightly further from the truth, but we are much more confident about our predictions.
Analogously to classification, we might think of the top prediction as "P(Y = 30) = 0.4" versus the fourth prediction as "P(Y = 23) = 0.7" (numbers not exact).
This level of detail allows more nuanced metrics to be utilized to measure probabilistic predictions, which we will turn to in the next section.

### Probability distribution predictions

In the example above we used the estimated standard error to calculate an approximate symmetric Normal confidence interval.
Instead we could have plugged the predicted `response` and `se` into a `r index("probability distribution")` as an estimate of the distribution mean and standard deviation.
By assuming a probability distribution, we can make our predictions even more detailed by not just considering the mean and standard error of the distribution, but also the probability density function, cumulative distribution function, and all other common properties and methods.

`r ref_pkg("distr6")` implements many probability distributions with `r ref_pkg("R6")` and provides a flexible interface that was originally designed to be used with `r mlr3proba`.
Below we demonstrate construction of two distributions (Uniform and Normal) in `r ref_pkg("distr6")` and how to access their methods and properties, below we call the `pdf` (probability density function) and `cdf` (cumulative distribution function) methods and look at the most important properties with `summary`.
Full details of the `r ref_pkg("distr6")` interface can be found on the `r link("https://alan-turing-institute.github.io/distr6/", "package website")`.

```{r special-007, warning=FALSE, message=FALSE}
library(distr6)
response = 5
se = 2

# construct Uniform distribution
unif = dstr("Uniform",
  lower = response - se * sqrt(3),
  upper = response + se * sqrt(3))
# summary of distribution properties
summary(unif)
# evaluate cdf and pdf
rbind(cdf = unif$cdf(1:6), pdf = unif$pdf(1:6))
```

In the above example we manually transformed the `response` and `se` 'predictions' to be compatible with a Uniform distribution construction, but learning these transformations can be time consuming.
`r mlr3proba` includes a pipeline `r ref("pipeline_probregr()")` that incorporates the key steps of distribution prediction for probabilistic regression, which are:

1. Train and predict a learner to make `response` predictions
2. Train and predict a learner to make `se` predictions
3. Select a probability distribution to model these predictions
4. Transform predictions to parameterize the chosen distribution
5. Return prediction

This pipeline is a wrapper around `r ref("PipeOpProbregr")`, and is showcased in the code below where we specify three inputs: 1) a random forest as the main learner, which predicts `response`; 2) a featureless learner to estimate the standard deviation, which simply predicts the future standard error as the sample standard deviation in the training set; and 3) we assume a Normal distribution for the predicted distribution. We visualize the quality of predictions in @fig-probregrdist.

```{r special-008}
#| fig-alt: Three Normally distributed curves are plotted in blue, red, and green. Each curve has a point of the same color, representing the true value. The x-label says "x" and the y-label says "f(x)". The point on the green curve is very close to the distribution maximum. The point on the red curve is close to, but not exactly the maximum. The point on the blue curve is about a third of the way down from the top of the curve. The title of the plot says "Logloss = 2.82".
#| fig-cap: Three probability distribution predictions plotted as probability density functions. True values are represented as points. Shows fairly good predictions for the green and red observations as the truth is close to the distribution mean/mode but a less good (but not terrible) prediction for the blue observation. The logloss value is low but could be better (0 is the minimum).
#| label: fig-probregrdist
library(mlr3verse)
library(mlr3proba)
library(ggplot2)

# create our pipeline
l = as_learner(ppl("probregr",
  learner = lrn("regr.ranger"),
  learner_se = lrn("regr.featureless"),
  dist = "Normal")
)

# train and predict
task = tsk("mtcars")
split = partition(task)
l$train(task, split$train)
p = l$predict(task, split$test)
p

plot_probregr(p, 3, "point", "random") +
  ggtitle(sprintf("Logloss = %s", round(p$score(msr("regr.logloss")), 2)))
```

The `$distr` column in our `r ref("PredictionRegr")` contains objects inheriting from `r ref("distr6::Distribution")`, which allows querying of all standard probability distribution methods and properties, as we have seen in the code above.
This example shows that although none of our predictions were perfect -- the truth was not exactly in line with the peak of the predicted distributions -- in each case the truth was at least within an area of reasonable confidence.

In future versions of `r mlr3proba` we will extend functionality further by adding models that can make probabilistic predictions (e.g., with Bayesian methods), more losses (e.g., Brier score), and a dedicated predict type for interval predictions.
We now turn to the next task implemented in `r mlr3proba`, which follows closely from probabilistic regression.

## Survival Analysis {#sec-survival}

`r define("Survival analysis")` is a field of statistics concerned with trying to predict/estimate the time until an event takes place.
This predictive problem is unique as survival models are trained and tested on data that may include 'censoring', which occurs when the event of interest does *not* take place.
Survival analysis can be hard to explain in the abstract, so as a working example consider a marathon runner in a race.
Here the 'survival problem' is trying to predict the time when the marathon runner finishes the race.
However, if the event of interest does not take place, i.e., marathon runner gives up and does not finish the race, then they are said to be censored.
Instead of throwing away information about censoring events, survival analysis datasets include a status variable that provides information about the 'status' of an observation.
So in our example we might write the runner's outcome as $(4, 1)$ if they finish the race at 4 hours, otherwise if they give up at 2 hours we would write $(2, 0)$.

The key to modelling in survival analysis is that we assume there exists a hypothetical time the marathon runner would have finished if they had not been censored, it is then the job of a survival learner to estimate what the true survival time would have been for a similar runner, assuming they are *not* censored (see @fig-censoring).
Mathematically, this is represented by the hypothetical event time, $Y$, the hypothetical censoring time, $C$, the observed outcome time, $T = min(Y, C)$, the event indicator $\Delta = (T = Y)$, and as usual some features, $X$.
Learners are trained on $(T, \Delta)$ but, critically, make predictions of $Y$ from previously unseen features.
This means that unlike classification and regression, learners are trained on two variables, $(T, \Delta)$, which, in R, is often captured in a `r ref("survival::Surv")` object.
An example of this is in the code below, where we randomly generate 6 survival times and 6 event indicators, an outcome with a `+` indicates the outcome is censoring, otherwise it is the event of interest.

```{r special-009}
library(survival)
Surv(runif(6), rbinom(6, 1, 0.5))
```

Readers familiar with survival analysis will recognize that the description above applies specifically to 'right censoring'.
Currently, this is the only form of censoring available in the `r mlr3` universe, hence restricting our discussion to that setting.
For a good introduction to survival analysis see @Collett2014 or for machine learning in survival analysis specifically see @MLSA.

For the remainder of this section we will look at how `r mlr3proba` [@mlr3proba] extends the building blocks of `r mlr3` for survival analysis. We will begin by looking at objects used to construct machine learning tasks for survival analysis, then we will turn to the learners we have implemented to solve these tasks, before looking at measures for evaluating survival analysis predictions, and then finally we will consider how to transform prediction types.

```{r special-010, echo=FALSE}
#| fig-alt:
#| fig-cap: Dead and censored subjects (y-axis) over time (x-axis). Black diamonds indicate true death times and white circles indicate censoring times. Vertical line is the study end time. Subjects 1 and 2 die in the study time. Subject 3 is censored in the study and (unknown) dies within the study time. Subject 4 is censored in the study and (unknown) dies after the study. Subject 5 dies after the end of the study. Figure and caption from @Sonabend2021b.
#| label: fig-censoring
library(ggplot2)
ggplot(data.frame(x = c(1, 2, 5, 7, 10), y = 1:5), aes(x = x, y = y)) +
  geom_blank() +
  geom_vline(xintercept = 8) +
  geom_segment(y = 1, yend = 1, x = 0, xend = 7) +
  geom_segment(y = 2, yend = 2, x = 0, xend = 8) +
  geom_segment(y = 3, yend = 3, x = 0, xend = 4) +
  geom_segment(y = 3, yend = 3, x = 4, xend = 6, linetype = 2) +
  geom_segment(y = 4, yend = 4, x = 0, xend = 1) +
  geom_segment(y = 4, yend = 4, x = 1, xend = 9, linetype = 2) +
  geom_segment(y = 5, yend = 5, x = 0, xend = 8) +
  geom_segment(y = 5, yend = 5, x = 8, xend = 9, linetype = 2) +
  geom_point(x = 4, y = 3, shape = 21, color = "black", fill = "white", size = 4) +
  geom_point(x = 6, y = 3, shape = 18, size = 4) +
  geom_point(x = 7, y = 1, shape = 18, size = 4) +
  geom_point(x = 8, y = 2, shape = 18, size = 4) +
  geom_point(x = 9, y = 5, shape = 18, size = 4) +
  geom_point(x = 8, y = 5, shape = 21, size = 4, fill = "white") +
  geom_point(x = 1, y = 4, shape = 21, size = 4, fill = "white") +
  geom_point(x = 9, y = 4, shape = 18, size = 4) +
  labs(y = "Subject", x = "Time") +
  scale_x_continuous(labels = as.character(1:10), breaks = 1:10) +
  theme_minimal() + theme(panel.grid.minor = element_blank())
```

### TaskSurv

As we saw in the introduction to this section, survival algorithms require two targets for training, this means the new `r ref("TaskSurv")` object  expects two targets.
The simplest way to create a survival task is to use `r ref("as_task_surv")`, as in the following code chunk.
Note how `r ref("as_task_surv")` coerces the target columns into a `r ref("survival::Surv")` object.

```{r special-011, warning=FALSE, message=FALSE}
library("mlr3verse")
library("mlr3proba")
library("survival")

task = as_task_surv(survival::rats, time = "time",
  event = "status", type = "right", id = "rats")

task$head()
autoplot(task)
```

In the above example we used the `r ref("survival::rats")` dataset, which looks at predicting if a drug treatment was successful in preventing 150 rats from developing tumors.
Note that the dataset (by its own admission) is not perfect and should generally be treated as 'dummy' data, which is good for examples but not real-world analysis.

As well as creating your own tasks, you can load any of the tasks shipped with `r mlr3proba`:

```{r special-012}
as.data.table(mlr_tasks)[task_type == "surv"]
```

### LearnerSurv, PredictionSurv and predict types

The interface for `r ref("LearnerSurv")` and `r ref("PredictionSurv")` objects is identical to the regression and classification settings discussed in @sec-basics.
Similarly to these settings, survival learners are constructed with `"lrn"`; available learners are listed in @sec-appendix-overview-tables.

The primary difference in constructing a survival learner (and the resulting predictions) is the number of possible `predict_type` options that can be passed to `r ref("lrn")`.

Similarly to deterministic regression (@sec-tasks), a survival model can make a single point prediction, and similarly to probabilistic regression (@sec-probregr), a survival model could also make a prediction of a probability distribution.
`r mlr3proba` has a different predict interface to `r mlr3` as all possible types of prediction ('predict types') are returned for all survival models.
The reason for this decision is that all these predict types can be transformed to one another and it is therefore computationally simpler to return all at once instead of rerunning models to change predict type.
In survival analysis, the following predictions can be made:

* `response` - Predicted survival time.
* `distr` - Predicted survival distribution, either discrete or continuous.
* `lp` - Linear predictor calculated as the fitted coefficients multiplied by the test data.
* `crank` - Continuous risk ranking.

We will go through each of these prediction types in more detail and with examples to make them less abstract.
We will use the following setup for most of the examples.
In this chunk we are partitioning the `r ref("survival::rats")` and training a `r define("Cox Proportional Hazards")` model (`r ref("mlr_learners_surv.coxph")`) on the training set and making predictions for the predict set.
For this model, all predict types except `response` can be computed.

```{r special-013}
t = tsk("rats")
split = partition(t)
p = lrn("surv.coxph")$train(t, split$train)$predict(t, split$test)
p
```

#### `predict_type = "response"`

Counterintuitively for many, the `response` prediction of predicted survival times is actually the least common predict type in survival analysis.
The likely reason for this is due to the presence of censoring.
We rarely observe the true survival time for many observations and therefore it is unlikely any survival model can confidently make predictions for survival times.
This is illustrated in the code below.

In the example below we train and predict from a survival support vector machine (`r ref("mlr_learners_surv.svm")`), note we use `type = "regression"` to select the algorithm that optimizes survival time predictions.
We then compare the predictions from the model to the true data.

```{r special-014}
library(mlr3extralearners)
pred = lrn("surv.svm", type = "regression", gamma.mu = 1e-3)$
  train(t, split$train)$predict(t, split$test)
data.frame(pred = pred$response[1:3], truth = pred$truth[1:3])
```

As can be seen from the output, our predictions are all less than the true observed time, which means we know our model definitely underestimated the truth.
However, because each of the true values are censored times, we have absolutely no way of knowing if these predictions are slightly bad or absolutely terrible, i.e., the true survival times could be $105, 92, 92$ or they could be $300, 1000, 200$.
Hence, with no realistic way to evaluate these models, survival time predictions are rarely useful.

#### `predict_type = "distr"`

So unlike regression in which deterministic/point predictions are most common, in survival analysis distribution predictions are much more common.
You will therefore find that the majority of survival models in `r mlr3proba` will make distribution predictions by default.
As with probabilistic regression, we implement these predictions using the `r ref_pkg("alan-turing-institute/distr6")` interface, which allows visualization and evaluation of survival curves (defined as 1 - cumulative distribution function).
In the example below we train a Cox PH model on the `rats` dataset and then plot the survival function of the first three predictions and evaluation this function for all three predictions at $t = \{40,70,120\}$.

```{r special-015}
t = tsk("rats")
split = partition(t)
p = lrn("surv.coxph")$train(t, split$train)$predict(t, split$test)
plot(p$distr[1:3], fun = "survival")
p$distr[1:3]$survival(c(40, 70, 120))
```

#### `predict_type = "lp"`

`lp`, often written as $\eta$ in academic writing, is computationally the simplest prediction and has a natural analogue in regression modelling.
Readers familiar with linear regression will know that when fitting a simple linear regression model, $Y = X\beta$, we are actually estimating the values for $\beta$, and the estimated `r index("linear predictor")` (lp) is then $X\hat{\beta}$, where $\hat{\beta}$ are our estimated coefficients.
In simple survival models, the linear predictor is the same quantity (but estimated in a slightly more complicated way).
The learner implementations in `r mlr3proba` are primarily machine-learning focused and few of these models have a simple linear form, which means that `lp` cannot be computed for most of these.

#### `predict_type = "crank"`

The final prediction type, `crank`, is the most common in survival analysis and perhaps also the most confusing.
Academic texts will often refer to 'risk' predictions in survival analysis (hence why survival models are often known as 'risk prediction models'), without defining what 'risk' means.
Often risk is defined as $exp(\eta)$ as this is a common quantity found in simple linear survival models.
However, sometimes risk is defined as $exp(-\eta)$, and sometimes it can be an arbitrary quantity that does not have a meaningful interpretation.
To prevent this confusion in `r mlr3proba`, we define the predict type `crank`, which stands for **c**ontinuous **rank**ing.
This is best explained by example.

Continuing from the previous example we output the first three `crank` predictions.
The output tells us that the second rat is at the higher risk of death (larger values represent higher risk) and the third rat is at the lowest risk of death.
The distance between predictions also tells us that the difference in risk between the first and second rat is smaller than the difference between the second and third.
The key points in this interpretation are: 1) lower values represent lower risk; 2) the difference between values has meaning but should not be over-interpreted; and 3) the actual values are meaningless.
The last point is the most important, comparing these values between samples (or papers or experiments) is not meaningful.

```{r special-016}
p$crank[1:3]
```

The `crank` prediction type is informative and common in practice because it allows identifying observations at lower/higher risk to each other, which is useful for resource allocation and prioritization (e.g., which patient should be given an expensive treatment), and clinical trials (e.g., are people in a treatment arm at lower risk of disease X than people in the control arm.).

### MeasureSurv

Survival models in `r mlr3proba` are evaluated with `r ref("MeasureSurv")` objects, which are constructed in the usual way with `"msr"`; measures currently implemented are listed in see @sec-appendix-overview-tables.

In general survival measures can be grouped into the following:

1. Discrimination measures -- Quantify if a model correctly identifies if one observation is at higher risk than another. Evaluate `crank` and/or `lp` predictions.
1. Calibration measures -- Quantify if the average prediction is close to the truth (all definitions of calibration are unfortunately vague in a survival context). Evaluate `crank` and/or `distr` predictions.
1. Scoring rules -- Quantify if probabilistic predictions are close to true values. Evaluates `distr` predictions.

```{r special-017}
head(as.data.table(mlr_measures)[
  task_type == "surv", c("key", "predict_type")])
```

There is a lot of debate in the literature around the 'best' survival measures to use to evaluate models, as a general rule we recommend RCLL (`r ref("mlr_measures_surv.rcll")`) to evaluate the quality of `distr` predictions, concordance index (`r ref("mlr_measures_surv.cindex")`) to evaluate a model's discrimination, and D-Calibration (`r ref("mlr_measures_surv.dcalib")`) to evaluate a model's calibration.

### Composition

Throughout `r mlr3proba` documentation we refer to "native" and "composed" predictions.
We define a 'native' prediction as the prediction made by a model without any post-processing, whereas a 'composed' prediction is one that is returned after post-processing.

#### Internal composition

In `r mlr3proba` we make use of composition internally to return a `"crank"` prediction for every learner.
This is to ensure that we can meaningfully benchmark all models according to at least one criterion.
The package uses the following rules to create `"crank"` predictions:

1. If a model returns a 'risk' prediction then `crank = risk` (we may multiply this by $-1$ to ensure the 'low value low risk' interpretation).
1. Else if a model returns a `response` prediction then we set `crank = -response`.
1. Else if a model returns a `lp` prediction then we set `crank = lp` (or `crank = -lp` if needed).
1. Else if a model returns a `distr` prediction then we set `crank` as the sum of the cumulative hazard function (see @Sonabend2022 for full discussion as to why we picked this method).

#### Explicit composition and pipelines

At the start of this section we mentioned that it is possible to transform prediction types between each other.
In `r mlr3proba` this is possible with 'compositor' pipelines (@sec-pipelines).
There are a number of pipelines implemented in the package but two in particular focus on predict type transformation:

1. `r ref("pipeline_crankcompositor()")` - Transforms a `"distr"` prediction to `"crank"`; and
1. `r ref("pipeline_distrcompositor()")` - Transforms a `"lp"` prediction to `"distr"`.

In practice, the second pipeline is more common as we internally use a version of the first pipeline whenever we return predictions from survival models.
You may want to use the first pipeline to overwrite the default method of transforming distributions to rankings.
For now we will just look at the second pipeline.

In the example below we load the `rats` dataset, remove factor columns, and then partition the data into training and testing.
We construct the `distrcompositor` pipeline around a survival GLMnet learner (`r ref("mlr_learners_surv.glmnet")`) which by default can only make predictions for `"lp"` and `"crank"`.
In the pipeline we specify that we will estimate the baseline distribution with a `r index("Kaplan-Meier")` estimator (`estimator = "kaplan"`) and that we want to assume a proportional hazards form for our estimated distribution.
We then train and predict in the usual way and in our output we can now see a `distr` prediction.

```{r special-018, warning=FALSE}
library(mlr3verse)
library(mlr3extralearners)

task = tsk("rats")
task$select(c("litter", "rx"))
split = partition(task)

learner = lrn("surv.glmnet")

# no distr output
learner$train(task, split$train)$predict(task, split$test)

pipe = as_learner(ppl(
  "distrcompositor",
  learner = learner,
  estimator = "kaplan",
  form = "ph"
))

# now with distr
pipe$train(task, split$train)$predict(task, split$test)
```

Mathematically, we have done the following:

1. Assume our estimated distribution will have the form $h(t) = h_0(t)exp(\eta)$ where $h$ is the hazard function and $h_0$ is the baseline hazard function.
1. Estimate $\hat{\eta}$ prediction using GLMnet
1. Estimate $\hat{h}_0(t)$ with the Kaplan-Meier estimator
1. Put this all together as $h(t) = \hat{h}_0(t)exp(\hat{\eta})$

For more details about prediction types and compositions we recommend @Kalbfleisch2011.


### Putting it all together {#sec-survival-all}

Finally, we will put all the above into practice in a small benchmark experiment.
We first load the `r ref("grace")` dataset and subset to the first 500 rows.
We then select the RCLL, D-Calibration, and C-index to evaluate predictions, setup the same pipeline we used in the previous experiment, and load a Cox PH and Kaplan-Meier estimator.
We run our experiment with 3-fold cross-validation and aggregate the results.

```{r special-019, warning=FALSE}
library(mlr3verse)
library(mlr3extralearners)

task = tsk("grace")$filter(1:500)
msr_txt = paste0("surv.", c("cindex", "dcalib", "rcll"))
measures = msrs(msr_txt)

pipe = as_learner(ppl(
  "distrcompositor",
  learner = lrn("surv.glmnet"),
  estimator = "kaplan",
  form = "ph"
))
pipe$id = "Coxnet"
learners = c(lrns(c("surv.coxph", "surv.kaplan")), pipe)

bmr = benchmark(benchmark_grid(task, learners, rsmp("cv", folds = 3)))
bmr$aggregate(measures)[, c("learner_id", ..msr_txt)]
```

In this small experiment, Coxnet and Cox PH have the best discrimination, Cox PH has the best calibration, and Coxnet and Cox PH have similar overall predictive accuracy.

## Density Estimation {#sec-density}

Density estimation is the learning task to estimate the unknown distribution from which a univariate dataset is generated, or put more simply to estimate the probability density (or mass) function for a variable.
Density estimation is implemented in `r mlr3proba`, similarly to the previous two tasks that can also predict probability distributions (hence the name "**mlr3proba**bilistic").
Unconditional density estimation, i.e., estimation of a target without any covariates, is viewed as an unsupervised task, which means the 'truth' is never known.
For a good overview to density estimation see @Silverman1986.

The package `r mlr3proba` extends `r mlr3` with the following objects for density estimation:

* `r ref("mlr3proba::TaskDens", text = "TaskDens")` to define density tasks
* `r ref("mlr3proba::LearnerDens", text = "LearnerDens")` as the base class for density estimators
* `r ref("mlr3proba::PredictionDens", text = "PredictionDens")` for density predictions
* `r ref("mlr3proba::MeasureDens", text = "MeasureDens")` as specialized class for density performance measures

We will consider each in turn.

### TaskDens

As density estimation is an unsupervised task, there is no target for prediction.
In the code below we construct a density task using `r ref("as_task_dens")` which takes one argument, a `data.frame` type object with exactly one column (which we will use to estimate the underlying distribution).

```{r special-020}
task = as_task_dens(data.frame(x = rnorm(1000)))
task
```

As with other tasks, we have included a couple tasks that come shipped with `r mlr3proba`:

```{r special-021}
as.data.table(mlr_tasks)[task_type == "dens", c(1:2, 4:5)]
```

### LearnerDens and PredictionDens

Density learners can make one of three possible prediction types.

1. `distr` - probability distribution
1. `pdf` - probability density function
1. `cdf` - cumulative distribution function

All learners will return a `distr` and `pdf` prediction but only some can make `cdf` predictions.
Similarly to survival analysis and probabilistic regression, the `distr` predict type is implemented using `r ref_pkg("alan-turing-institute/distr6")`.

```{r special-022}
learn = lrn("dens.hist")
p = learn$train(task, 1:900)$predict(task, 901:1000)
x = seq.int(-2, 2, 0.01)
ggplot(data.frame(x = x, y = p$distr$pdf(x)), aes(x = x, y = y)) +
  geom_line() + theme_minimal()
```

The `pdf` and `cdf` predict types are simply wrappers around `distr$pdf` and `distr$cdf` respectively, which is best demonstrated by example:

```{r special-023}
learn = lrn("dens.hist")
p = learn$train(task, 1:10)$predict(task, 11:13)
p
cbind(p$distr$cdf(task$data()$x[11:13]), p$cdf[1:3])
```

The reason for returning `pdf` and `cdf` in this way is to enable measures that can be used to evaluate the quality of our estimations, which we will return to in the next section.

### MeasureDens

Currently the only measure implemented in `r mlr3proba` for density estimation is logloss, which is defined in the same way as in classification and probabilistic regression, $L(y) = -log(\hat{f}_Y(y))$, where $\hat{f}_Y$ is our estimated probability density function.
Putting this together with the above we are now ready to train a density learner, estimate a distribution, and evaluate our estimation:

```{r special-024}
meas = msr("dens.logloss")
meas

p$score(meas)
```

### Unconditional density estimation vs. probabilistic regression

Some readers may spot parallels between density estimation and `r index("probabilistic regression")` (@sec-probregr).
In fact, density estimation is just a special case of probabilistic regression, occurring when we make an unconditional prediction.
For example, given average rainfall across the USA, estimating the distribution of rainfall would be unsupervised density estimation.
If we now wanted to estimate the distribution of rainfall next year given rainfall this year, then we would be back to supervised probabilistic regression.
This is illustrated in the code below.

We load the `r ref("precip")` dataset and train, predict, and score a Normal kernel density estimation density learner (`r ref("mlr_learners_dens.kde")`).
We then create a new dataset based on `r ref("precip")` but with an added variable for rainfall next year.
Now we can specify a target for prediction based on another covariate, thus making this a supervised learning task.
We then use the `probregr` pipeline (@sec-probregr) and train, predict, and score a random forest learner (`r ref("mlr_learners_regr.ranger")).
Note the key difference in these outputs is that whilst both make distribution predictions, the former (density) *estimates* a single probability distribution for the variable of interest, whereas the latter (regression) *predicts* a distribution for each observation.

```{r special-025}
task = tsk("precip")
split = partition(task)
learn = lrn("dens.kde", kernel = "Norm")
p = learn$train(task, split$train)$predict(task, split$test)
p
p$score(msr("dens.logloss"))

df = task$data()
df$next_year = (df$precip * 1.5) + rnorm(length(df$precip))
task = as_task_regr(df, target = "next_year")
pipe = as_learner(ppl("probregr", lrn("regr.ranger"), dist = "Normal"))
p = pipe$train(task, split$train)$predict(task, split$test)
p
p$score(msr("regr.logloss"))
```

### Putting it all together {#sec-density-all}

Finally, we conduct a small benchmark study on the `r ref("mlr_tasks_faithful")` task using some of the integrated density learners:

```{r special-026, message=FALSE, warning=FALSE, results='hide'}
library(mlr3extralearners)
task = tsk("faithful")
learners = lrns(c("dens.hist", "dens.pen", "dens.kde"))
measure = msr("dens.logloss")
bmr = benchmark(benchmark_grid(task, learners, rsmp("cv", folds = 3)))
bmr$aggregate(measure)
autoplot(bmr, measure = measure)
```

The results of this experiment show that the sophisticated Penalized Density Estimator does not outperform the baseline histogram, but that the Kernel Density Estimator has at least consistently better (i.e. lower logloss) results.

## Cluster Analysis {#sec-cluster}

`r define("Cluster analysis")` is another unsupervised task implemented in `r mlr3`.
The objective of cluster analysis is to group data into clusters, where each cluster contains similar observations.
The similarity is based on specified metrics that are task and application-dependent.
Unlike classification where we try to predict a class for each observation, in cluster analysis there is no 'true' label or class to predict.

The package `r mlr3cluster` extends `r mlr3` with the following objects for cluster analysis:

* `r ref("mlr3cluster::TaskClust", text = "TaskClust")` to define clustering tasks
* `r ref("mlr3cluster::LearnerClust", text = "LearnerClust")` as base class for clustering learners
* `r ref("mlr3cluster::PredictionClust", text = "PredictionClust")` as specialized class for `r ref("Prediction")` objects
* `r ref("mlr3cluster::MeasureClust", text = "MeasureClust")` as specialized class for performance measures

We will consider each in turn.

### TaskClust

Similarly to density estimation (@sec-density), there is no target for prediction and so no `truth` field in `r ref("TaskClust")`.
Let's look at the `r ref("cluster::ruspini")` dataset often used for cluster analysis examples.

```{r special-027, warning=FALSE, message=FALSE}
library(cluster)
head(ruspini)
```

The dataset has 75 rows and two columns and was first introduced in @Ruspini1970 to illustrate different clustering techniques.
As we will see from the plots below, the observations form four natural clusters.

In the code below we construct a cluster task using `r ref("as_task_clust")` which only takes one argument, a `data.frame` type object.

```{r special-028, warning=FALSE, message=FALSE}
library(mlr3verse)
library(cluster)
task = as_task_clust(ruspini)
task

autoplot(task)
```

Technically, we did not need to create a new task for ruspini dataset since it is already included in the package.
Currently we have two clustering tasks shipped with `r mlr3cluster`:

```{r special-029}
as.data.table(mlr_tasks)[task_type == "clust", c(1:2, 4:5)]
```

### LearnerClust and PredictionClust

As with density estimation, we refer to `training` and `predicting` for clustering to be consistent with the `r mlr3` interface, but strictly speaking this should be `clustering` and `assigning` (the latter we will return to shortly).
Two `predict_types` are available for clustering learners:

1. `partition` -- estimate of which cluster an observation falls into
1. `prob` -- probability of an observation belonging to each cluster

Hence, similarly to classification, prediction types of clustering learners are either deterministic (`partition`) or probabilistic (`prob`).

Below we construct a C-Means clustering learner with `prob` prediction type and 3 clusters, train it on the `r ref("cluster::ruspini")` dataset and then return the cluster assignments (`$assignments`) for each observation.

```{r special-030}
learner = lrn("clust.cmeans", predict_type = "prob", centers = 3)
learner

learner$train(task)
learner$assignments[1:6]
```

As clustering is unsupervised, it often does not make sense to use `predict` for new data however this is still possible using the `r mlr3` interface:

```{r special-031, warning = FALSE, message = FALSE}
# using same data for estimation (rare use case)
learner$train(task, 1:30)$predict(task, 31:32)

# using same data for estimation (common use case)
prediction = learner$train(task)$predict(task)
autoplot(prediction, task)
```

Whilst two prediction types are possible, there are some learners where 'prediction' can never make sense, for example in `r define("hierarchical clustering")`.
In hierarchical clustering, the goal is to build a hierarchy of nested clusters by either splitting large clusters into smaller ones or merging smaller clusters into bigger ones.
The final result is a tree or dendrogram which can change if a new data point is added.
For consistency, `r mlr3cluster` offers `predict` method for hierarchical clusters but with a warning:

```{r special-032}
learner = lrn("clust.hclust")
learner$train(task)
learner$predict(task)
autoplot(learner) + theme(axis.text = element_text(size = 3.5))
```

In this case, the `predict` method simply cuts the dendrogram into the number of clusters specified by `k` parameter of the learner.


### MeasureClust

As previously discussed, unsupervised tasks do not have ground truth data to compare to in model evaluation.
However, we can still measure the quality of cluster assignments by quantifying how closely objects within the same cluster are related (`r index("cluster cohesion")`) as well as how distinct different clusters are from each other (`r index("cluster separation")`).
There are a few built-in evaluation metrics available to assess the quality of clustering, see @sec-appendix-overview-tables.

Two common measures are the within sum of squares (WSS) measure, `r ref("mlr_measures_clust.wss")`, and the silhouette coefficient, `r ref("mlr_measures_clust.silhouette")`.
WSS calculates the sum of squared differences between observations and centroids, which is a quantification of cluster cohesion (smaller values indicate clusters more compact).
The silhouette coefficient quantifies how well each point belongs to its assigned cluster versus neighboring clusters, where scores closer to `1` indicate well clustered and scores closer to `-1` indicate poorly clustered.
Note that the silhouette measure in `r mlr3cluster` returns the mean silhouette score across all observations and when there is only a single cluster, the measure simply outputs 0.

Putting this together with the above we can now score our cluster estimation (note we must pass the `task` to `r ref("msr")`):

```{r special-033}
meas = msrs(c("clust.wss", "clust.silhouette"))

prediction$score(meas, task = task)
```

The very high WSS and middling mean silhouette coefficient indicate that our clusters could do with a bit more work.
Often reducing an unsupervised task to a quantitative measure may not be useful (given no ground truth) and instead visualization may be a more effective tool for assessing the quality of the clusters.

#### Measure Limitations
It is easy to rely on clustering measures to assess the quality of clustering.
However, this should be done with some care, by example consider cluster analysis on the following dataset.

```{r special-034}
spirals = mlbench::mlbench.spirals(n = 300, sd = 0.01)
task = as_task_clust(as.data.frame(spirals$x))
autoplot(task)
```

Now fitting our clustering learner.

```{r special-035}
learners = list(
  lrn("clust.kmeans"),
  lrn("clust.dbscan", eps = 0.1)
)
measures = list(msr("clust.silhouette"))
bmr = benchmark(benchmark_grid(task, learners, rsmp("insample")))
bmr$aggregate(measures)[, c(4, 7)]
```

We can see that K-means clustering gives us a higher average silhouette score and might assume that K-means learner with 2 centroids is a a better choice than DBSCAN method.
However, now take a look at the cluster assignment plots.

```{r special-036, message=FALSE, warning=FALSE}
prediction_kmeans = bmr$resample_results$resample_result[[1]]$prediction()
prediction_dbscan = bmr$resample_results$resample_result[[2]]$prediction()
autoplot(prediction_kmeans, task)
autoplot(prediction_dbscan, task)
```

The two learners arrived at different results -- the K-means algorithm assigned points that are part of the same line into two different clusters whereas DBSCAN assigned each line to its own cluster.
Which one of these approaches is correct?
The answer is it depends on your specific task and the goal of cluster analysis.
If we had only relied on the silhouette score, then the details of how exactly the clustering was done would have been masked and we would not be able to decide which method was appropriate for the task.

### Visualization

As with other tasks, we use `r mlr3viz` to visualize performance of cluster learners. The two most important plots are `r index("principal components analysis")` (PCA) and silhouette plots.

PCA is a commonly used dimension reduction method in ML to reduce the number of variables in a dataset or to visualize the most important 'components', which are linear transformations of the dataset features.
Components are considered more important if they have higher variance (and therefore more predictive power).
In the context of clustering, by plotting observations against the first two components, and then coloring them by cluster, we could visualize our high dimensional dataset and we would expect to see observations in distinct groups.

Since our running example only has two features, PCA does not make sense to visualize the data.
So we will use a task based on the `USArrests` dataset instead.
By plotting the result of PCA, we see that our model has separated observations into two clusters along the first two principal components.

```{r special-037, message=FALSE, warning=FALSE}
task = mlr_tasks$get("usarrests")
learner = lrn("clust.kmeans")
prediction = learner$train(task)$predict(task)
autoplot(prediction, task, type = "pca")
```

Silhouette plots visually assess the quality of the estimated clusters by visualizing if observations in a cluster are well-placed both individually and as a group.
The plots include a dotted line which visualizes the average silhouette coefficient across all data points and each data point’s silhouette value is represented by a bar colored by cluster.
In our particular case, the average silhouette index is `r round(msr("clust.silhouette")$score(prediction, task), 2)`.
If the average silhouette value for a given cluster is below the average silhouette coefficient line then this implies that the cluster is not well defined.

Continuing with our new example, we find that a lot of observations are actually below the average line and close to zero, and therefore the quality of our cluster assignments is not very good, meaning that many observations are likely assigned to the wrong cluster.

```{r special-038, message=FALSE, warning=FALSE}
autoplot(prediction, task, type = "sil")
```

### Putting it all together {#sec-cluster-all}

Finally, we conduct a small benchmark study using the `ruspini` data and with a few integrated cluster learners:

```{r special-039, message=FALSE, warning=FALSE}
task = tsk("ruspini")
learners = list(
  lrn("clust.featureless"),
  lrn("clust.kmeans", centers = 4L),
  lrn("clust.cmeans", centers = 3L)
)
measures = list(msr("clust.wss"), msr("clust.silhouette"))
bmr = benchmark(benchmark_grid(task, learners, rsmp("insample")))
bmr$aggregate(measures)[, c(4, 7, 8)]
```

The experiment shows that using the K-means algorithm with four centers has the best cluster cohesion (lowest within sum of squares) and the best average silhouette score.

## Spatial Analysis {#sec-spatiotemporal}

The final task we will discuss in this book is `r define("spatial analysis")`.
Spatial analysis can be a subset of any other machine learning task (e.g., regression or classification) and is defined by the presence of spatial information in a dataset, usually stored as coordinates that are often named "x" and "y" or "lat" and "lon" (for 'latitude' and 'longitude' respectively.)

Spatial analysis is its own task as spatial data must be handled carefully due to the complexity of 'autocorrelation'.
Where `r index("correlation")` is defined as a statistical association *between two* variables, `r define("autocorrelation")` is a statistical association *within one* variable.
In machine learning terms, in a dataset with features and observations, correlation occurs when two or more features are statistically associated in some way, whereas autocorrelation occurs when two or more observations are statistically associated across one feature.
Autocorrelation therefore violates one of the fundamental assumptions of ML that all observations in a dataset are independent, which results in lower confidence about the quality of a trained ML model and we therefore cannot trust any performance estimates [@hastie2001].

Autocorrelation is present in spatial data as there is implicit information encoded in coordinates, such as whether two observations (e.g., cities, countries, continents) are close together or far apart.
By example, say we are predicting the number of cases of a disease two months after outbreak in Germany.
Outbreaks radiate outwards from an epicenter and therefore countries closer to Germany will have higher numbers of cases and countries further away will have lower numbers (Fig @fig-autocorrelation, bottom), thus
there is autocorrelation in the 'country'.

```{r special-040, warning=FALSE, echo=FALSE, message=FALSE}
#| label: fig-autocorrelation
#| fig-cap: Heatmaps where darker countries indicate higher number of cases and lighter countries indicate lower number of cases of imaginary Disease X with epicenter in Germany. The top map imagines a world in which there is no spatial autocorrelation and the number of cases of a disease is randomly distributed. The bottom map shows a more accurate world in which the number of cases radiate outwards from the epicenter (Germany).
#| fig-alt: Image shows two separate maps of Europe. Top mat has a random distribution of colors from yellow to red. Bottom mat shows darkest color (dark orange) at Germany with increasing lightness as the countries are increasingly further away.

library(dplyr)
library(patchwork)

m = map_data("world")
m = m[m$region == "Germany", ]
x1 = mean(m$lon)
x2 = mean(m$lat)
m = map_data("world")
m = m %>% dplyr::filter(long > -15, long < 40, lat > 36, lat <  60)
m$dist = -sqrt((m$lon - x1)^2 + (m$lat - x2)^2)
m$rand = rnorm(nrow(m), mean(m$dist), sd(m$dist))
cou = m %>% group_by(region) %>% summarize(long = mean(long), lat = mean(lat))

p = ggplot(data = m) +
  scale_fill_gradient2(low = "white", mid = "orange", high = "red", midpoint = mean(m$dist)) +
  theme_minimal() +
  theme(legend.position = "n") +
  xlim(-10, 25) + ylim(37, 58)

t = geom_text(aes(label = region, x = long, y = lat), data = cou, size = 2)

p1 = p + geom_map(map = m, aes(long, lat, map_id = region, fill = rand)) + t

p2 = p + geom_map(map = m, aes(long, lat, map_id = region, fill = dist)) + t

p1 / p2
```

Unlike other tasks we have looked at in this chapter, there is no underlying difference to the implemented learners or measures, instead we provide new resampling methods in `r mlr3spatiotempcv` to account for any overconfidence in predictions that might occur from autocorrelation.
To make use of these resamplings we have also implemented special tasks in `r mlr3spatial` to hold spatial data.

Throughout this section we will use the `r ref("mlr3spatiotempcv::ecuador")` dataset and task as a working example.

### `TaskClassifST` and `TaskRegrST`

To make use of spatial resampling methods, we have implemented two extensions of `r ref("TaskClassif")` and `r ref("TaskRegr")` to accommodate spatial data, `r ref("TaskClassifST")` and `r ref("TaskRegrST")` respectively.
Below we only show classification examples but regression follows trivially.

```{r special-041, message=FALSE, warning=FALSE}
library(mlr3spatial)
library(mlr3spatiotempcv)

# create task from `data.frame`
task = as_task_classif_st(ecuador, id = "ecuador_task",
  target = "slides", positive = "TRUE",
  coordinate_names = c("x", "y"), crs = "32717")

# or create task from 'sf' object
data_sf = sf::st_as_sf(ecuador, coords = c("x", "y"), crs = "32717")
task = as_task_classif_st(data_sf, target = "slides", positive = "TRUE")
task
```

Once a task is created, you can train and predict as normal.

```{r special-042}
lrn("classif.rpart")$train(task)$predict(task)
```

However as discussed above, it is best to use the specialized resampling methods in order to have trustworthy estimates of model performance.

### Spatiotemporal Cross-Validation {#spatiotemp-cv}

Before we look at the spatial resampling methods implemented in `r mlr3spatiotempcv` we will first show what can go wrong if standard resampling methods are used.
Below we benchmark a decision tree on the `r ref("mlr_tasks_ecuador")` task using two different repeated cross-validation resampling methods, the first ("NSpCV") is a standard resampling method from `r mlr3`, the second ("SpCV") is from `r mlr3spatiotempcv` and is optimized for spatial data.
The example highlights how "NSpCV" makes it appear as if the decision tree is performing better than it is with significantly higher estimated performance, however this is an overconfident prediction due to the autocorrelation in the data.

```{r special-043, warning=FALSE,message=FALSE}
learner = lrn("classif.rpart", predict_type = "prob")
rsmp_nsp = rsmp("repeated_cv", folds = 3, repeats = 2, id = "NSpCV")
rsmp_sp = rsmp("repeated_spcv_coords", folds = 3, repeats = 2, id = "SpCV")

design = benchmark_grid(task, learner, c(rsmp_nsp, rsmp_sp))
bmr = benchmark(design)
bmr$aggregate(msr("classif.acc"))[, c(5, 7)]
```

In the above example, the non-spatial resampling method means that the train and test data are very similar due to spatial autocorrelation, and so this is almost as bad as evaluating a model on the training data (see @sec-basics).
In contrast, the spatial method has accommodated for autocorrelation and the test data is therefore less correlated (though still some association will remain) with the training data.
Visually this can be seen using built-in `r ref("autoplot")` methods.
In @fig-sprsmp we visualize how the task is partitioned according to the spatial resampling method (@fig-sprsmp top) and non-spatial resampling method (@fig-sprsmp bottom).
There is a clear separation between coordinates using the 'correct' spatial resampling method whereas the train and test splits overlap significantly (and are therefore highly correlated) using the non-spatial method.

```{r special-044}
#| fig-cap: Scatterplots show separation of train (blue) and test (orange) data for the first three (left to right) folds of the first repetition of the cross-validation. The top row is spatial resampling where train and test data are clearly separated. The bottom row is non-spatial resampling where there is overlap in train and test data.
#| fig-alt: Six scatter plots are shown with y-axes from 4 degrees South to 3.97 degrees South and x-axes from 79.08 degrees West to 79.06 degrees West. The top row of plots show a very clear separation with no overlap between blue and orange datapoints, whereas the bottom low shows significant overlap.
#| label: fig-sprsmp

library(patchwork)
autoplot(rsmp_sp, task, fold_id = c(1:3), size = 0.7) /
  autoplot(rsmp_nsp, task, fold_id = c(1:3), size = 0.7) &
  scale_y_continuous(breaks = seq(-3.97, -4, -0.01)) &
  scale_x_continuous(breaks = seq(-79.06, -79.08, -0.02))
```

Now we have seen why spatial resampling methods matter we can take a look at what is implemented in `r mlr3spatiotempcv`.
At the time of writing we have implemented 19 different resampling methods for spatial and spatiotemporal analysis.
These are categorized into:

* Blocking -- Create rectangular blocks in 2D/3D space (as opposed to partitioning in 1D space used in non-spatial methods)
* Buffering -- Create buffering zones to remove observations between train and test sets
* Spatiotemporal clustering -- Clusters based on coordinates (and/or time-points)
* Feature space clustering -- Clusters based on feature space and not necessarily spatiotemporal
* Partitioning -- Grouped by factor variables

The choice of method may depend on specific characteristics of the dataset and there is no easy rule to pick one method over another, full details of different methods can be found in @Schratz2021 -- the paper deliberately avoids recommending one method over another as the 'optimal' choice is highly dependent on the predictive task, autocorrelation in the data, and the spatial structure of the sampling design.
The documentation for each of the implemented methods includes details of each method as well as references to original publications.

:::{.callout-tip}
## Spatio*temporal* resampling

We have focused on spatial analysis but referred to "spatiotemporal" and "spatiotemp".
The resampling methods discussed in this section extend trivially to temporal analysis (or spatial and temporal analysis combined) by setting the `"time"` `col_role` in the task (@sec-performance).
See the `r mlr3spatiotempcv` visualization `r link("https://mlr3spatiotempcv.mlr-org.com/articles/spatiotemp-viz.html", "vignette")` for specific details about 3D spatiotemporal visualization.
:::

### Spatial Prediction {#sec-spatial-prediction}

Until now we have looked at resampling to accommodate spatiotemporal *features*, but what if you want to make spatiotemporal *predictions*?
In this case the goal is to make classification or regression predictions for spatial coordinates at a pixel level, usually by creating and labelling raster images.

To enable these predictions we have created a new function, `r ref("predict_spatial")`, to allow spatial predictions using any of the following spatial data classes:

* `stars` (from package `r ref_pkg("stars")`)
* `SpatRaster` (from package `r ref_pkg("terra")`)
* `RasterLayer` (from package `r ref_pkg("raster")`)
* `RasterStack` (from package `r ref_pkg("raster")`)

To use a raster image for prediction, it must be wrapped in `r ref("TaskUnsupervised")`.
In the example below we load the `leipzig_points` file for training and coerce this to a spatiotemporal task with `r ref("as_task_classif_st")`, and we load the `leipzig_raster` raster image and coerce this to an unsupervised task.
Both files are shipped with, and can be downloaded from, `r mlr3spatial`.

```{r special-045, warning=FALSE, message=FALSE}
library(sf)

# load sample points
leipzig_vector = sf::read_sf(system.file("extdata",
  "leipzig_points.gpkg", package = "mlr3spatial"),
  stringsAsFactors = TRUE)
# create training data
tsk_leipzig = as_task_classif_st(leipzig_vector, target = "land_cover")

# load raster image
leipzig_raster = terra::rast(system.file("extdata", "leipzig_raster.tif",
  package = "mlr3spatial"))
# create testing data
tsk_predict = as_task_unsupervised(leipzig_raster)
```

Now we can continue as normal to train and predict with a classification learner, in this case a random forest.

```{r special-046}
lrn = lrn("classif.ranger")$train(tsk_leipzig)
pred = predict_spatial(tsk_predict, lrn, format = "terra")
pred
```

In this example we specified creation of a `terra` object, which can be visualized with in-built plotting methods.

```{r special-047, message = FALSE, cache.lazy=FALSE, cache=FALSE}
library(terra, exclude = "resample")
plot(pred, col = c("#440154FF", "#443A83FF", "#31688EFF",
  "#21908CFF", "#35B779FF", "#8FD744FF", "#FDE725FF"))
```

## Fairness {#fairness}

```{r, include = FALSE, cache = FALSE}
library("mlr3fairness")
```

In this chapter, we will explore fairness in automated decision making and how we can build better systems when it comes to systems that make (automated) decisions about individuals.
Such systems range from domains such as banking (credit-scoring) and hiring (applicant scoring) to systems that help with medical decisions.
Methods to help with auditing for or building better models can be found in the `r mlr3fairness` package. 
This chapter heavily borrows from the paper accompanying the pacakge [@mlr3fairness].

Automated decision-making systems based on data-driven models are becoming increasingly common, and studies have found that they often outperform human experts in making decisions, especially in high-stakes scenarios, leading to more efficient and accurate predictions.
However, without proper auditing, these models can result in negative consequences for individuals, especially those from underprivileged groups.
The proliferation of such systems in everyday life has made it important to address the potential for biases in these models.
For instance, historical biases and sampling biases in the data used to train these models can lead to replication of such biases in the future, as well as inadequate representation of unprivileged populations, leading to models that perform well in some groups but worse on others.
Biases in the measurement of labels and data, as well as feedback loops, are other sources of biases that need to be addressed.
ML-driven systems are used for highly influential decisions such as loan accommodations, job applications, healthcare, and criminal sentencing.
Therefore, it is crucial to develop capabilities to analyze and assess these models not only with respect to their robustness and predictive performance but also with respect to potential biases.

### What is bias?

With bias, we usually refer to disparities in how a model treats individuals or groups.
In order to understand this better, we will first discuss, which disparities we might want to consider in this context.
Then we can discuss how to detect and quantify those disparities in machine learning models, and finally how they can be translated to so-called *fairness metrics*.

#### Notions of fairness

In this article, we will concentrate on a subset of bias definitions, so-called *group fairness*.
As a scenario, we might for example imagine that we develop a system that makes decisions about whether a patient should be considered for some new treatment.
Our goal might now be, that those decisions are *fair* across groups defined by a *sensitive attribute*, which could e.g., be gender, race or age.
In the following, we will often denote this sensitive group with *A* and for simplicity assume it is binary and can only take two values, e.g. 0 and 1.
We will now present two different perspectives on fairness presented in [@fairmlbook].

The first group of fairness notions, *bias preserving* fairness notions, also called **Separation**, requires that the prediction made by the model is independent of the sensitive attribute given the true label.
In other words, the model should make roughly the same amount of errors (or correct predictions) in each group.
Several metrics fall under this category, such as Equalized Odds, which requires the same true positive and false positive rates across all groups.

The second group, *bias transforming* fairness notions, also called **Independence**, only requires that the prediction made by the model is independent of the sensitive attribute.
This group includes the concept of demographic parity, which requires that the proportion of positive predictions is equal across all groups.


It is important to note that these metrics condense a large variety of societal issues into a single number, and they are therefore limited in their ability to identify biases that may exist in the data. Similar, those metrics do not easily translate to legal principles. For example, if societal biases lead to disparities in an observed quantity (such as SAT scores) for individuals with the same underlying ability, these metrics may not identify existing biases.
These metrics often naturally extend to more complex scenarios, such as multi-class classification, regression, or survival analysis.
Additional fairness notions beyond statistical group fairness include individual fairness, which assesses fairness at an individual level based on the principle of treating similar cases similarly and different cases differently, and causal fairness notions which incorporate causal relationships in the data and propose metrics based on a directed acyclic graph.

**Note** Fairness metrics cannot be used to prove or guarantee fairness, and their selection depends on the societal context and the implications of the decisions made. They serve as a diagnostic tool to detect disparities and as a basis for model selection and making fair decisions in practice. However, fairness metrics are reduction of complex societal processes into mathematical objectives and require abstraction steps, which can invalidate the metric. Additionally, practitioners should look beyond the model and consider the data used for training and the process of data and label acquisition. Fairness metrics should be used for exploratory purposes only, and practitioners should not solely rely on them to make decisions about employing an ML model or assessing whether a system is fair.

#### Choosing fairness notions

The selection of fairness metrics for machine learning models requires careful consideration of societal context and value judgments.
Bias-preserving metrics, such as equalized odds and equality of opportunity, require that errors made by a model are equal across groups, but might not account for label bias.
Bias-transforming methods do not depend on labels and can help detect biases arising from different base rates across populations, but enforcing them might induce a shift in the data distribution, possibly leading to feedback loops.

#### Translating notions of fairness into code.

In order to translate the independence requirements stated above into a fairness metric, we investigate differences between groups.
As an example, for a metric $M$, e.g., the true positive rate (TPR), we calculate the difference in the metric across the two groups:

\[
\Delta_{\mathrm{M}} = \mathrm{M}_{A=0} - \mathrm{M}_{A=1}.
\]

To provide an example, with $\mathbb{P}\left(\hat{Y} = 1 \mid A = \star, Y = 1\right)$ denoted with $\mathrm{TPR}_{A=\star}$, we calculate the difference in TPR between the two groups:
\[
\Delta_{\mathrm{TPR}} = \mathrm{TPR}_{A=0} - \mathrm{TPR}_{A=1}.
\]
When $\Delta_{\mathrm{TPR}}$ now significantly deviates from $0$, the prediction $\hat{Y}$ violates the requirement for *equality of opportunity* formulated above.

It is important to note that in practice, we might not be able to perfectly satisfy a given metric, e.g., due to stochasticity in data and labels.
Instead, to provide a binary conclusion regarding fairness, a model could be considered fair if $|\Delta_{\mathrm{TPR}}| < \epsilon$ for a given threshold $\epsilon > 0$, e.g., $\epsilon = 0.05$.
This allows for small deviations from perfect fairness due to variance in the estimation of $\mathrm{TPR}_{A=\star}$ or additional sources of bias.

This approach allows us to construct a fairness `r ref("Measure")` from arbitrary metrics, by supplying a `base_measure`:

```{r special-048}
msr("fairness", base_measure = msr("classif.acc"))
```

For convenience, we have implemented a variety of `r ref("Measure")`s that is made available when the  `r mlr3fairness` package is loaded.
Fairness measures can then be constructed via `msr()` like any other measure in `r mlr3`.

:::{.callout-tip}
Fairness metrics have a  *fairness* prefix, and simply calling `msr()` without any arguments will return a list of all available measures including fairness metrics.
:::

#### Selecting the sensitive attribute

For a given task, we can select one or multiple sensitive attributes.
In `r mlr3`, the sensitive attribute is identified by the column role `pta` and can be set as follows:

```{r special-049, eval = FALSE}
task$set_col_roles("marital_status", add_to = "pta")
```

This example sets the `"marital_status"` column of our task as a sensitive attribute.
This information is then automatically passed on when the task is used, e.g., when computing fairness metrics.
If more than one sensitive attribute is specified, metrics will be computed based on intersecting groups formed by the columns.

#### Example: Auditing a model for bias

In the following chunk, we retrieve the binary classification task with id `"adult_train"` from the package.
It contains a part of the `Adult` data set [@uci].
The task is to predict whether an individual earns more than $50.000 per year.
The column `"sex"` is set as a binary protected attribute with levels `"Female"` and `"Male"`.

```{r special-050}
library("mlr3fairness")
task = tsk("adult_train")
print(task)
```

We can now fit any `r ref("Learner")` on this task and score the resulting `r ref("Prediction")`.

```{r special-051}
learner = lrn("classif.rpart", predict_type = "prob")
idx = partition(task)
learner$train(task, idx$train)
prediction = learner$predict(task, idx$test)
```

We then employ a fairness measure, here the discrepancy in accuracy between groups:

```{r special-052}
measure = msr("fairness.acc")
prediction$score(measure, task = task)
```

This now reports the difference in accuracy between the two groups available in the data.
We can similarly use the metric to score a `ResamplingResult` or `BenchmarkResult`.

### Fair Machine Learning

If we now detect that our model is unfair, a natural next step might be to try and mitigate such biases.
The `r mlr3fairness` package comes with several options to adress biases in models, which broadly fall into three categories:
data pre-processing, employing fair models, or adapting model predictions.
Those methods often slightly decrease predictive performance and we might therefore want to try out which of the existing approaches balances predictive performance and fairness.

Pre- and postprocessing schemes can be connected to learners with the help of `r mlr3pipelines`.
If you are not familiar with pipelines, you can familiarize yourself with them in the mlr3pipelines (@sec-pipelines) chapter.
We provide two examples below, first preprocessing to balance observation weights with `po("reweighing_wts")` and second post-processing predictions to enforce equalized odds by flipping predictions.

```{r special-053, eval = FALSE}
po("reweighing_wts") %>>% lrn("classif.glmnet")
po("learner_cv", learner = lrn("classif.glmnet")) %>>% po("EOd")
```

Similarly, we can also fit learners that incorporate fairness considerations directly, e.g. a linear model with fairness constraints which also comes with `r mlr3fairness`.

```{r special-054, eval = FALSE}
learner = lrn("classif.fairzlrm")
```

Note, that algorithmic interventions might often enforce fairness in suboptimal ways.
It is therefore important to address biases at their root cause instead of relying solely on algorithmic interventions.

Combining `r mlr3fairness` with `r mlr3pipelines` and `r mlr3tuning` allows for tuning over complex pipelines and e.g. simultaneously optimizing for performance and fairness. We describe this in more detail in the mlr3fairness paper [@mlr3fairness].


### Further considerations

In additon to implementing fairness metrics and debiasing methods, the `r mlr3fairness` package comes with a variety of additional functionality that might be useful when aiming to achieve fair outcomes:

**Documentation**

Because fairness aspects can not always be investigated based on fairness metrics, it is important to document data collection and the resulting data as well as the models resulting from this data.
Informing auditors about those aspects of a deployed model can lead to better assessments of a model's fairness.
Questionnaires for ML models and data sets have been proposed in literature.
We further add automated report templates using R markdown for data sets and ML models.
In addition, we provide a template for a *fairness report* which includes many fairness metrics and visualizations to provide a good starting point for generating a fairness report inspired by the *Aequitas Toolkit*.
A preview for the different reports can be obtained from the [Reports vignette](https://mlr3fairness.mlr-org.com/articles/reports-vignette.html).

**Visualization**

Similarly, visualizations can help better understand discrepancies between groups or differences between models.
For an in-depth dive into visualizations, please consider the [Visualization vignette](https://mlr3fairness.mlr-org.com/articles/visualization-vignette.html).

To showcase available visualizations, we will again use the `adult` dataset [@uci] and train a decision tree as well as a random forst on it.

```{r special-055}
task = tsk("adult_train")$filter(1:5000)
learner = lrn("classif.ranger", predict_type = "prob")
learner$train(task)
prediction = learner$predict(tsk("adult_test")$filter(1:5000))
```

```{r special-056}
#| fig-cap: Fairness prediction density plot (left) showing the density of predictions for the positive class splitted into "Male" and "Female" individuals. The metrics comparison plot (right) depicts the model's scores across the specified metrics using bars.
#| fig-alt: Two panel plot including two overlapping densities with a concentration on the right for the model's prediction of the positive class labeled "Male" and "Female". Both densities are relatively equal. The second panel shows three bar charts for the three metrics ("fairness.fpr", "fairness.tpr", "fairness.eod") with bars at roughly 0.035, 0.002, 0.018 for the three metrics respectively.
#| label: fig-fairness
library(patchwork)
p1 = fairness_prediction_density(prediction, task = task) + theme(legend.position="bottom")
p2 = compare_metrics(prediction, msrs(c("fairness.fpr", "fairness.tpr", "fairness.eod")), task = task)
(p1 + xlab("") + p2) * theme_bw() + theme(axis.text.x = element_text(angle = 30, hjust = .7))
```

In this example, we can for example see that the prediction density between `Male` and `Female` individuals predicting the positive outcome is relatively similar indicating relatively small biases.
This can also be observed from the different metrics, where relatively small discrepancies in the fairness metric are observed.

### Fairness: Concluding remarks

The functionality introduced above has the goal to help users investigating their models for potential biases and potentially mitigate them. Deciding whether a model is fair however requires additional investigation, such as deciding what the measured quantities actually mean for an individual in the real world and what other biases might exist in the data that might lead to discrepancies in how e.g. covariates or the label are measured.
We hope, that pairing the functionality available in `r mlr3fairness` with additional exploratory data analysis, a solid understanding of the societal context in which the decision is made and integrating additional tools, e.g. from interpretability might help to prevent unfairness in systems deployed in the future.

## Conclusion

In this chapter, we explored going beyond deterministic regression and classification to see how functions in the `r mlr3` can be used to implement other machine learning tasks.
Cost-sensitive classification extends the 'normal' classification setting by assuming errors associated with false negatives and false positives are unequal.
Running cost-sensitive classification experiments is possible just using features in `r mlr3`.
Probabilistic regression extend deterministic regression by making predictions over a full probability distribution and not just a single point.
You can train and predict probabilistic regression models with `r mlr3` or more effectively in pipelines with `r mlr3proba`.
Survival analysis, also available in `r mlr3proba`, is a special form of probabilistic regression when the outcome is censored, which means it may never be observed within a given time frame.
The final task in `r mlr3proba` is density estimation, the unsupervised task concerned with estimating univariate probability distributions.
Using `r mlr3cluster`, you can perform cluster analysis on observations, which involves grouping observations together according to similarities in their variables.
Finally, with `r mlr3spatial` and `mlr3spatiotempcv`, it is possible to perform spatial analysis to make predictions using co-ordinates as features and to make spatial predictions.
The `r mlr3` interface is highly extensible, which means future machine learning tasks can (and will) be added to our universe and we will add these to this chapter of the book in future editions.

## Exercises

We will run `set.seed(11)` before each of our solutions so you can reproduce our results.

1. Run a benchmark experiment on the `german_credit` task with algorithms: `featureless`, `log_reg`, `ranger`. Tune the `featureless` model using `tunetreshold` and `learner_cv`. Use 2-fold CV and evaluate with `msr("classif.costs", costs = costs)` where you should make the parameter `costs` so that the cost of a true positive is -10, the cost of a true negative is -1, the cost of a false positive is 2, and the cost of a false negative is 3. Are your results surprising?
1. Use the `probregr` pipeline to create a probabilistic regression model using: xgboost for the `response` prediction, featureless learner for the `se` prediction, and assuming an Cauchy distribution. Train and predict on `task = tsk("mtcars"); split = partition(task)`. Evaluate your model with the logloss measure.
1. Train and predict a survival forest using `rfsrc` (from `mlr3extralearners`). Run this experiment using `task = tsk("rats"); split = partition(task)`. Evaluate your model with the RCLL measure.
1. Estimate the density of the `tsk("precip")` data using `logspline` (from `mlr3extralearners`). Run this experiment using `task = tsk("precip"); split = partition(task)`. Evaluate your model with the logloss measure.
1. Run a benchmark clustering experiment on the `wine` dataset without a label column. Compare the performance of `k-means` learner with `k` equal to 2, 3 and 4 using the silhouette measure. Use insample resampling technique. What value of `k` would you choose based on the silhouette scores?


1. Run a (spatially) unbiased classification benchmark experiment on the `ecuador` task with a featureless learner and xgboost, evaluate with the binary Brier score.
