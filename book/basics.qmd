---
author:
  - name: Natalie Foss
    orcid:
    email: nfoss2@uwyo.edu
    affiliations:
      - name: University of Wyoming
  - name: Lars Kotthoff
    orcid: 0000-0003-4635-6873
    email: larsko@uwyo.edu
    affiliations:
      - name: University of Wyoming
abstract:
    We describe and explain the basic building blocks of mlr3 and how to train and evaluate simple machine learning models.
    The chapter introduces the different types of tasks that mlr3 supports and how to work with them, learners and how to train models, how to make predictions using those trained models, and how to evaluate the quality of the predictions in a principled fashion.
    Only the basic concepts are introduced, but we give pointers on where to learn more in the rest of the book, and overviews of other concepts.
    After reading this chapter, you will be able to use mlr3 for most machine learning workflows.
---

# Fundamentals {#sec-basics}

{{< include _setup.qmd >}}

In this chapter, we will introduce the `r mlr3` objects and corresponding `r ref_pkg("R6")` classes that implement the essential building blocks of machine learning.
These building blocks include the data (and the methods of creating training and test sets), the machine learning algorithm (and its training and prediction process), and evaluation measures to assess the quality of predictions.

In essence, machine learning means learning relationships from data.
In supervised learning, datasets consist of observations (rows in tabular data) that are labeled, which means that each data point includes features (columns in tabular data) and a quantity that we are trying to predict, also called 'target'.
For example, we might want to predict the miles per gallon a car gets based on features such as its horsepower and the number of gears.
Data and information on what they represent, along with what quantities to predict are called "tasks" in `r mlr3` (@sec-tasks) -- they can be thought of as machine learning tasks we are trying to solve.
There can be more than one task per dataset, for example ones that include different sets of features, observations, or predict different target quantities.

Supervised learning can be further divided into regression (predicting numeric target values) and classification (predicting categorical target values/labels).
In either case, the goal is to build a model that captures the relationship between features and target.
We can build such models using machine learning algorithms, for example decision trees, support vector machines, neural networks, and many more.
A machine learning algorithm, given training data, induces such a model.
Machine learning algorithms are called "learners" in `r mlr3` (@sec-learners) -- given data, they learn models.
Each learner has a parameterized space that potential models are drawn from and during the training process, these parameters are fitted to best match the data.
For example, the parameters could be the weights given to individual features when predicting a quantity in linear regression.
For other learners, the parameters are not as explicit, for example for decision tree learners where a fitted model corresponds to a particular decision tree.
All learners optimize a so-called loss function during training, i.e. training a learner means finding the model that optimizes the loss.
In general, a loss function quantifies the mismatch between ground truth target values in the training data and the predictions of the model.

Given a model, we can make predictions (@sec-predicting) on new data.
A model is only useful though if it generalizes beyond the training data.
Otherwise, we could build a perfect model by simply memorizing the training data.
Therefore, separate test data is used to evaluate models in an unbiased way and to assess to what extent they have learned the true relationships that underlie the data (@sec-performance).
We can evaluate models in `r mlr3` in many ways (@sec-eval).
In general, we use the same kind of loss function that the learner used to build the model, but now with data that was not used during training.
The performance of a model, quantified by the value of the loss function when evaluated on new data, is called the estimate of the generalization error -- how well do we expect this model to do in general?
`r mlr3` calls loss functions "measures".
We can use different measures for training and testing, although it makes most sense for the measures to be the same.

Much more information on (supervised) machine learning can be found in @hastie2001, @james_introduction_2014, or @bishop_2006.

The basic idea is illustrated in the following figure:

```{r basics-fig-1, echo=FALSE}
#| label: fig-ml-abstraction
#| fig-cap: "General overview of the machine learning process."
#| fig-align: "center"
#| fig-alt: "A flowchart starting with the task (data), which splits into training- and test sets. The training set is used with the learner to fit a model, which is then used with the test set to make predictions. A performance measure is applied to the predictions and results in a performance estimate. Resampling refers to the repeated application of this process."
knitr::include_graphics("Figures/ml_abstraction.svg")
```


## Tasks {#sec-tasks}

Tasks are objects that contain the (usually tabular) data and additional meta-data that define a machine learning problem.
The meta-data contain, for example, the name of the target feature for supervised machine learning problems.
This information is used automatically by operations that can be performed on a task so that for example the user does not have to specify the prediction target every time a model is trained.

### Built-in Tasks {#sec-tasks-built-in}

`r mlr3` includes a few predefined machine learning tasks in an R6 `Dictionary` named `r ref("mlr_tasks")`.

```{r basics-001}
mlr_tasks
```

To get a task from the dictionary, use the `r ref("tsk()")` function and assign the return value to a new variable.
Here, we retrieve the `r ref("mlr_tasks_mtcars", text = "mtcars regression task")`, which is provided by the package `r ref_pkg("datasets")`:

```{r basics-002}
task_mtcars = tsk("mtcars")
task_mtcars
```

To get more information about a particular task, it is easiest to use the `help()` method that all `r mlr3`-objects come with:

```{r basics-003, eval = FALSE}
task_mtcars$help()
```

:::{.callout-tip}
If you are familiar with R's help system (i.e. the `help()` and `?` functions), this may seem confusing.
`task_mtcars` is the variable that holds the mtcars task, not a function, and hence we cannot use `help()` or `?`.
:::

Alternatively, the corresponding man page can be found under `mlr_tasks_<id>`, e.g.

```{r basics-004, eval = FALSE}
help("mlr_tasks_mtcars")
```

We can also load the data separately and convert it to a task, without using the `tsk()` function that `r mlr3` provides.
If the data we want to use does not come with `r mlr3`, it has to be done this way.

For example, the data for `r ref("datasets::mtcars", text = "mtcars")` is also available separately, as a `data.frame()` and not a task.
`r ref("datasets::mtcars", text = "mtcars")` contains characteristics for different types of cars, along with their fuel consumption.
We want to predict the numeric target feature stored in column `"mpg"` (miles per gallon).

```{r basics-006}
data("mtcars", package = "datasets")
str(mtcars)
```

We create the regression task, i.e. we construct a new instance of the R6 class `r ref("TaskRegr")`.
An easy way to do this is to use the function `r ref("as_task_regr()")` to convert our `data.frame()` to a regression task, specifying the target feature in an additional argument.
Before we give the data to `r ref("as_task_regr()")`, we can process it using the usual R functions, for example to select a subset of data.


```{r basics-007}
library("mlr3")
mtcars_subset = subset(mtcars, select = c("mpg", "cyl", "disp"))

task_mtcars = as_task_regr(mtcars_subset, target = "mpg", id = "cars")
task_mtcars
```

:::{.callout-tip}
The task constructors `r ref("as_task_regr()")` and `r ref("as_task_classif()")` will check for non-ASCII characters in the column names of your data.
As many ML models do not work properly with arbitrary [UTF8 names](https://en.wikipedia.org/wiki/UTF-8), `r mlr3` defaults to throw an error if any of the column names contains either a non-ASCII character or does not comply with R's variable naming scheme.
We generally recommend converting names with `r ref("make.names()")` first, but you can also set the option `mlr3.allow_utf8_names` to true to relax the check (but do not be surprised if a model fails).
:::

The data can be any rectangular data format, e.g. a `data.frame()`, `data.table()`, or `tibble()`.
Internally, the data is converted and stored in a `r ref("DataBackend")`.
The `target` argument specifies the prediction target column.
The `id` argument is optional and specifies an identifier for the task that is used in plots and summaries.
If no `id` is provided, the deparsed name of the data will be used (an R way of turning data into strings).

Printing a task gives a short summary: it has `r task_mtcars$nrow` observations and `r task_mtcars$ncol` columns, of which `mpg` is the target and `r length(task_mtcars$feature_names)` are features stored in double-precision floating point format.

We can plot the task using the `r mlr3viz` package, which gives a graphical summary of the distribution of the target and feature values:

```{r basics-008, message=FALSE}
#| fig-cap: "Overview of the mtcars dataset."
#| fig-alt: Diagram showing the distribution of target and feature values in the mtcars data.
library("mlr3viz")
autoplot(task_mtcars, type = "pairs")
```

:::{.callout-tip}
Instead of loading multiple extension packages individually, it is often more convenient to load the `r mlr3verse` package instead.
It makes the functions from most `r mlr3` packages that are used for common machine learning and data science tasks available.
:::

### Retrieving Data {#sec-retrieve-data}

The `r ref("Task")` object primarily represents a tabular dataset, combined with meta-data about which columns of that data should be used to predict which other columns in what way, and some more information about column data types.

Various fields can be used to retrieve meta-data about a task. The dimensions, for example, can be retrieved using `$nrow` and `$ncol`:

```{r basics-009}
task_mtcars$nrow
task_mtcars$ncol
```

The names of the feature and target columns are stored in the `$feature_names` and `$target_names` slots, respectively. Here, "target" refers to the feature we want to predict and "feature" to the predictors for the task.

```{r basics-010}
task_mtcars$feature_names
task_mtcars$target_names
```

While the columns of a task have unique `character`-valued names, their rows are identified by unique natural numbers, called row IDs.
They can be accessed through the `$row_ids` slot:

```{r basics-011}
head(task_mtcars$row_ids)
```

Row IDs are not used as features when predicting; they are meta-data that allows to access individual observations.

:::{.callout-warning}
Although the row IDs are typically just the sequence from `1` to `nrow(data)`, they are only guaranteed to be unique natural numbers. It is possible that they do not start at `1`, that they are not increasing by 1 each, or that they are not even in increasing order.
This allows to transparently operate on real database management systems, where uniqueness is the only requirement for primary keys.
:::

The data contained in a task can be accessed through `$data()`, which returns a `data.table` object.
It has optional `rows` and `cols` arguments to specify subsets of the data to retrieve.
When a database backend is used, this avoids loading unnecessary data into memory, making it more efficient than retrieving the entire data first and then subsetting it using `[<rows>, <cols>]`.

```{r basics-012}
task_mtcars$data()
# retrieve data for rows with IDs 1, 5, and 10 and column "mpg"
task_mtcars$data(rows = c(1, 5, 10), cols = "mpg")
```

A shortcut to extract all data from a task is to simply convert it to a `data.table`:

```{r basics-013}
# show summary of all data
summary(as.data.table(task_mtcars))
```

### Task Mutators {#sec-tasks-mutators}

It is often necessary to create tasks that encompass subsets of other tasks' data, for example to manually create [train-test-splits](#train-test-splits), or to fit models on a subset of given features.
Restricting tasks to a given set of features can be done by calling `$select()` with the desired feature names.
Restriction to rows (observations) is done with `$filter()` with the row IDs.

```{r basics-014}
task_mtcars_small = tsk("mtcars") # initialize with the full task
task_mtcars_small$select(c("am", "carb")) # keep only these features
task_mtcars_small$filter(2:4) # keep only these rows
task_mtcars_small$data()
```

These methods are so-called *mutators*; they modify the given `Task` in place.
If you want to have an unmodified version of the task, you need to use the `$clone()` method to create a copy first.

```{r basics-015}
task_mtcars_smaller = task_mtcars_small$clone()
task_mtcars_smaller$filter(2)
task_mtcars_smaller$data()
task_mtcars_small$data()  # the original task is unmodified
```

Note also how the last call to `$filter(2)` did not select the second row of `task_mtcars_small`, but the row with ID 2, which is the *first* row of `task_mtcars_small`.

:::{.callout-tip}
If you need to work with row numbers instead of row IDs, you can work on the vector of row IDs:

```{r basics-016, eval = FALSE}
# keep the 2nd row:
keep = task_mtcars_small$row_ids[2] # extracts ID of 2nd row
task_mtcars_smaller$filter(keep)
```
:::

The methods above allow to subset the data; the methods `$rbind()` and `$cbind()` allow to add extra rows and columns to a task.

```{r basics-017}
task_mtcars_smaller$rbind( # add another row
  data.frame(mpg = 23, am = 0, carb = 3)
)
task_mtcars_smaller$data()
```

## Learners {#sec-learners}

Objects of class `r ref("Learner")` provide a unified interface to many popular machine learning algorithms in R.
They are available through the `mlr_learners` dictionary.
The list of learners supported in the base package `r mlr3` is deliberately small to avoid dependencies; support for additional learners is provided by the `r mlr3learners` and `r mlr3extralearners` packages.

Learners encapsulate methods to train a model and make predictions using it given a `r ref("Task")` and provide meta-data about the learners.
The base class of each learner is `r ref("Learner")`.

To retrieve a `r ref("Learner")` from the `mlr_learners` dictionary, use the function `r ref("lrn()")`:

```{r basics-023}
learner_rpart = lrn("regr.rpart")
```

Each learner provides the following meta-data:

* `$feature_types`: the type of features the learner can deal with.
* `$packages`: the packages required to train a model with this learner and make predictions.
* `$properties`: additional properties and capabilities.
  For example, a learner has the property "missings" if it is able to handle missing feature values, and "importance" if it computes and allows to extract data on the relative importance of the features.
* `$predict_types`: possible prediction types.
  For example, a regression learner can predict numerical values ("response") and may be able to predict the standard error of a prediction ("se").

This information can be queried through these slots, or seen at a glance when printing the learner:
```{r basics-024}
learner_rpart
```

All learners work in two stages:

* **Training**: A training task (features and target data) is passed to the learner's `$train()` function which trains and stores a model, i.e. the learned relationship of the features to the target.
* **Prediction**: New data, usually a different partition of the original dataset, is passed to the `$predict()` method of the trained learner.
  The model trained in the first step is used to predict the target values, e.g. the numerical value for regression problems.

:::{.callout-warning}
A learner that has not been trained cannot make predictions and will throw an error if `$predict()` is called on it.
:::

```{r basics-022, echo=FALSE, fig.align="center"}
#| label: fig-basics-learner
#| fig-cap: Overview of the different stages of a learner.
#| fig-alt: Diagram showing the different stages of a learner, their interactions, and consumed data.
knitr::include_graphics("Figures/learner.svg")
```

### Training the learner {#sec-training}

We train the model by giving a task to the learner.
It is a good idea to hold back some data from the training process used to assess the quality of the predictions made by the trained model.
The `r ref("partition()")` function randomly splits the task into two disjoint sets: a training set (67% of the total data, the default) and a test set (33% of the total data, the data not part of the training set).

```{r basics-025}
splits = partition(task_mtcars)
splits
```

We learn a regression tree by calling the `$train()` method of the learner, specifying the task and the part of it to use for training (`splits$train`).
This operation adds the learned model to the existing `r ref("Learner")` object.
We can now access the stored model via the field `$model`.

```{r basics-025-1}
learner_rpart$train(task_mtcars, splits$train)
learner_rpart$model
```

We see that the learner has identified features in the task that are predictive of the class (`mpg`) and uses them to partition observations in the tree.
The textual representation of the model depends on the type of learner.
For more information on this particular type of model and how it is printed, see `r ref ("rpart::print.rpart()")`.

The model seems rather simplistic, using only a single feature and a single set of branches.
Each learner has hyperparameters that control its behavior and allow to influence the way a model is learned.
Setting hyperparameters to values appropriate for a given machine learning task is crucial for good predictive performance.
The field `param_set` stores a description of the hyperparameters the learner has, their ranges, defaults, and current values:

```{r basics-026}
learner_rpart$param_set
```

The set of current hyperparameter values is stored in the `values` field of the `param_set` field.
You can access and change the current hyperparameter values by accessing this field, which stores a named list:

```{r basics-027}
learner_rpart$param_set$values
learner_rpart$param_set$values$minsplit = 10
learner_rpart$param_set$values
```

:::{.callout-tip}
It is possible to assign all hyperparameters in one go by assigning a named list to `$values`: `learner$param_set$values = list(minsplit = 10, ...)`.
This operation removes all previously-set hyperparameters.
:::

The `r ref("lrn()")` function also accepts additional arguments to update hyperparameters or set fields of the learner when constructing it:

```{r basics-028}
learner_rpart = lrn("regr.rpart", minsplit = 10)
learner_rpart$param_set$values
```

```{r basics-029}
learner_rpart$train(task_mtcars, splits$train)
learner_rpart$model
```

With the changed hyperparameters, we have a more complex (and more reasonable) model.

:::{.callout-note}
Details on the hyperparameters of our `rpart` learner can be found at `r ref ("rpart::rpart.control()")`.
Hyperparameters in general are discussed in more detail in the section on [Hyperparameter Tuning](#tuning).
:::

### Predicting {#sec-predicting}

After the model has been created, we can now use it to make predictions.
We can give the test partition to the `$predict()` function with the second arguement being the testing set (`splits$test`) defined in `splits` by `partition()` earlier in this chapter.
This `$predict()` function takes the `row_ids` given by `splits$test` and returns predictions for those `row_ids` in the given task (first arguement) and the model stored in the learner (`learner_rpart`).

```{r basics-030}
predictions = learner_rpart$predict(task_mtcars, splits$test)
predictions
```

The `$predict()` method returns a `r ref("Prediction")` object, in this case a `r ref("PredictionRegr")` for predicting a numeric quantity.
The "truth" column contains the ground truth data, which was not given to the model to get a prediction.
The "response" column contains the value predicted by the model, allowing for easy comparison with the ground truth data.

We can also use separate data to make predictions, which can be part of a separate task or simply a separate `data.frame`:

```{r basics-031}
mtcars_new = data.frame(cyl = c(5, 6),
                        disp = c(100, 120),
                        hp = c(100, 150),
                        drat = c(4, 3.9),
                        wt = c(3.8, 4.1),
                        qsec = c(18, 19.5),
                        vs = c(1, 0),
                        am = c(1, 1),
                        gear = c(6, 4),
                        carb = c(3, 5))
mtcars_new
```

The learner does not need to know more meta-data about this data to make predictions, as this was given when training the model.
We can use the `$predict_newdata()` method to make predictions for our separate dataset:

```{r basics-032}
predictions = learner_rpart$predict_newdata(mtcars_new)
predictions
```

Note that the "truth" column is now `NA`, as we did not give the ground truth data.

We can also access the predictions directly:

```{r basics-access-pred}
predictions$response
```

Similar to plotting tasks, `r mlr3viz` provides an `r ref("ggplot2::autoplot()", text = "autoplot()")` method for `r ref("Prediction")` objects.

```{r basics-035, message = FALSE, warning = FALSE}
#| fig-cap: "Comparing predicted and ground truth values for the mtcars dataset."
#| fig-alt: "A scatter plot of predicted values on one axis and ground truth values on the other. A trend line is fit to show that in general there is good agreement between predicted and ground truth values."
library("mlr3viz")
predictions = learner_rpart$predict(task_mtcars, splits$test)
autoplot(predictions)
```

### Changing the Prediction Type {#sec-predict-type}

Regression learners default to predicting a numeric quantity.
However, many regression models can also give you bounds on the prediction by providing the standard error.
To predict these standard errors, the `predict_type` field of a `r ref("LearnerRegr")` must be changed from "response" (the default) to "se" before training.
The `rpart` learner we used above does not support predicting standard errors, so we use the `lm` linear model instead, from the `r ref("mlr3learners")` package:

```{r basics-033}
library(mlr3learners)

learner_lm = lrn("regr.lm")
learner_lm$predict_type = "se"
learner_lm$train(task_mtcars, splits$train)
predictions = learner_lm$predict(task_mtcars, splits$test)
predictions
```

:::{.callout-tip}
@sec-lrns-add-list shows how to list learners that support the standard error prediction type.
:::

The prediction object now contains the standard error for the predictions.

```{r basics-034}
predictions
```

### Hyperparameters {#sec-param-set}

Each learner has a `r ref("ParamSet")` that contains the hyperparameters for the learner.
The user can access this object using the `$param_set` field.

```{r}
rpart = lrn("regr.rpart")
rpart$param_set
```
These hyperparameters effect the way that learners create their model. 
There are five classes of `r ref("Param")` objects:

1. `r ref("ParamDbl")` - A Param to describe real-valued (Numerical) parameters.
1. `r ref("ParamFct")` - A Param to describe categorical (factor) parameters.
1. `r ref("ParamInt")` - A Param to describe integer parameters.
1. `r ref("ParamLgl")` - A Param to describe logical parameters.
1. `r ref("ParamUty")` - A Param to describe untyped parameters.

Individual hyperparameters can be combined into `r ref("ParamSet")` objects that are used to perform hyperparameter optimization. This process is covered in @sec-optimization.


## Evaluation {#sec-eval}

An important step of modeling is evaluating the performance of the trained model.
We have seen how to inspect the model and plot its predictions above, but a more rigorous way that allows to compare different types of models more easily is to compute a performance measure.
`r mlr3` offers many performance measures, which can be created with the `r ref("msr()")` function.
Measures are stored in the dictionary `r ref("mlr_measures")`, and a measure has to be supported by `r mlr3` to be used, just like learners.
For example, we can list all measures that are available for regression tasks:

```{r basics-036}
mlr_measures$keys("regr")
```

Measure objects can be created with a single performance measure (`r ref("msr()")`) or multiple (`r ref("msrs()")`):

```{r basics-037}
measure = msr("regr.rmse")
measures = msrs(c("regr.rmse", "regr.sse"))
```

At the core of all performance measures is a quantification of the difference between the predicted value and the ground truth value (except for unsupervised tasks, which we will discuss later).
This means that in order to assess performance, we usually need the ground truth data -- observations for which we do not know the true value cannot be used to assess the quality of the predictions of a model.
This is why we make predictions on the data the model did not use during training (the test set).

As we have seen above, `r mlr3`'s `r ref("Prediction")` objects contain both predictions and ground truth.
The `r ref("Measure")` objects define how prediction and ground truth are compared, and how differences between them are quantified.
We choose root mean squared error (`r ref("mlr_measures_regr.rmse", text = "regr.rmse")`) as our performance measure for this example.
Once the measure is created, we can pass it to the `$score()` method of the `r ref("Prediction")` object to quantify the predictive performance of our model.

```{r basics-038}
measure = msr("regr.rmse")
measure
predictions$score(measure)
```

:::{.callout-note}
`$score()` can be called without a measure; in this case the default measure for the type of task is used.
Regression defaults to mean squared error (`r ref("mlr_measures_regr.mse", text = "regr.mse")`).
:::

It is possible to calculate multiple measures at the same time by passing multiple measures to `$score()`.
For example, to compute both root mean squared error `r ref("mlr_measures_regr.rmse", text = "regr.rmse")` and mean squared error `r ref("mlr_measures_regr.mse", text = "regr.mse")`:

```{r basics-039}
measures = msrs(c("regr.rmse", "regr.mse"))
predictions$score(measures)
```

`r mlr3` also provides measures that do not quantify the quality of the predictions of a model, but other information we may be interested in, for example the time it took to train the model and make predictions:

```{r basics-measures-time}
measures = msrs(c("time_train", "time_predict"))
predictions$score(measures, learner = learner_lm)
```

Note that these measures require a trained learner in addition to the predictions.

Some measures have hyperparameters themselves, for example `r ref("mlr_measures_selected_features", text = "selected_features")`.
This measure gives information on the features the model used and is only supported by learners that have the "selected_features" property.
It requires a task and a learner in addition to the predictions.
The `lm` model does not support showing selected features; we use the `rpart` learner again and the full `mtcars` task.

```{r basics-measures-hp}
task_mtcars = tsk("mtcars")
splits = partition(task_mtcars)
learner_rpart = lrn("regr.rpart", minsplit = 10)

learner_rpart$train(task_mtcars, splits$train)
predictions = learner_rpart$predict(task_mtcars, splits$test)
measure = msr("selected_features")
predictions$score(measure, task = task_mtcars, learner = learner_rpart)
```

The hyperparameter of the measure specifies whether the number of selected features should be normalized by the total number of features.
The default is `FALSE`, giving the absolute number of features that, in this case, the trained decision tree uses.
We can change the hyperparameter in the same way as for learners, for example:

```{r basics-measures-hp-set}
measure = msr("selected_features", normalize = TRUE)
predictions$score(measure, task = task_mtcars, learner = learner_rpart)
```

We have now seen the basic building blocks of `r mlr3` -- creating and partitioning a task, instantiating a learner and setting its hyperparameters, training a model and inspecting it, making predictions, and assessing the quality of the model with a performance measure.
So far, we have focused on regression, where we want to predict a numeric quantity.
The rest of this chapter looks at other task types.
The general procedure it the same, but some details are different.


## Classification {#sec-classif}

Classification predicts a discrete, categorical target instead of the continuous numeric quantity for regression.
The models that learn to classify data are different from regression models, and regression learners are not applicable for classification problems (although for some learners, there are both regression and classification versions).
`r mlr3` distinguishes between the different tasks and learner types through different R6 classes and different prefixes -- regression learners and measures start with `regr.`, whereas classification learners and measures start with `classif.`.

### Classification Tasks {#sec-classif-tsks}

The `r ref("mlr_tasks")` dictionary that comes with `r mlr3` contains several classification tasks (`r ref("TaskClassif")`).
We can show only the classification tasks by converting the dictionary to a `data.table` and filtering on the `task_type`:

```{r basics-040}
as.data.table(mlr_tasks)[task_type == "classif"]
```

We will use the `r ref("datasets::penguins", text = "penguins")` dataset as a running example:

```{r basics-041}
task_penguins = tsk("penguins")
task_penguins
```

Just like for regression tasks, printing it gives an overview of the task, including the number of observations and features, and their types.

The target variable, `r task_penguins$target_names`, is of type factor and has the following three classes or levels:

```{r basics-042}
unique(task_penguins$data(cols = "species"))
```

Classification tasks (`r ref("TaskClassif")`) can also be plotted using `r ref("ggplot2::autoplot()", text = "autoplot()")`.
Apart from the "pairs" plot type that we show here, "target" and "duo" are available.
We refer the interested reader to the documentation of `r ref("mlr3viz::autoplot.TaskClassif")` for an explanation of the other options.
To keep the plot readable, we select only the first two features of the dataset.

```{r basics-043, warning = FALSE, message = FALSE}
#| fig-cap: "Overview of the penguins dataset."
#| fig-alt: Diagram showing the distribution of target and feature values in the penguins data.
library("mlr3viz")

task_penguins_small = task_penguins$clone()
task_penguins_small$select(head(task_penguins_small$feature_names, 2))
autoplot(task_penguins_small, type = "pairs")
```

### Classification Learners {#sec-classif-lrns}

Classification learners (`r ref("LearnerClassif")`) are a different R6 class than regression learners (`r ref("LearnerRegr")`), but also inherit from the base class `r ref("Learner")`.
We can instantiate a classification learner in the same way as a regression learner, by retrieving it from the `mlr_learners` dictionary using `r ref("lrn()")`.
Note the `classif.` prefix to denote that we want a learner that classifies observations:

```{r basics-044}
learner_rpart = lrn("classif.rpart")
learner_rpart
```

Just like regression learners, classification learners have hyperparameters we can set to change their behavior, and printing the learner object gives some basic information about it.
Training a model and making predictions works in the same way as for regression:

```{r basics-classification-train-predict}
splits = partition(task_penguins)
learner_rpart$train(task_penguins, splits$train)
learner_rpart$model
predictions = learner_rpart$predict(task_penguins, splits$test)
predictions
```

Just like predictions of regression models, we can plot classification predictions with `r ref("ggplot2::autoplot()", text = "autoplot()")`:

```{r basics-plot-pred-classif, message = FALSE, warning = FALSE}
#| fig-cap: "Comparing predicted and ground truth values for the penguins dataset."
#| fig-alt: "A stacked bar plot of predicted values in one bar and ground truth values in the other. The number of observations for a particular class is approximately, but not quite, the same for predicted and ground truth values."
library("mlr3viz")
autoplot(predictions)
```

#### Changing the Prediction Type {#sec-classif-pred_type}

Classification problems support two types of predictions: the default "response", i.e. the class label, and "prob", which gives the probability for each class label.
Not all learners support predicting probabilities.

The prediction type for a learner can be changed by setting `$predict_type`.
After retraining the learner, all predictions have class probabilities (one for each class) in addition to the response, which is the class with the highest probability:

```{r basics-046}
learner_rpart$predict_type = "prob"
learner_rpart$train(task_penguins, splits$train)
predictions = learner_rpart$predict(task_penguins, splits$test)
predictions
```

:::{.callout-tip}
@sec-lrns-add-list shows how to list learners that support the probability prediction type.
:::

### Classification Evaluation {#sec-classif-eval}

Evaluation measures for classification problems that are supported by `r mlr3` can be found in the `mlr_measures` dictionary:

```{r basics-047}
mlr_measures$keys("classif")
```

Some of these measures require the [predictition type](#sec-classif-pred_type) to be "prob" (e.g. `classif.auc`).
As the default is "response", using those measures requires to change the prediction type, as shown above.
You can check what prediction type a measure requires by looking at `$predict_type`.

```{r basics-048}
measure = msr("classif.acc")
measure$predict_type
```

Once we have created a classification measure, we can give it to the `$score()` method to compute its value for a given `r ref("PredictionClassif")` object:

```{r basics-classif-score}
predictions$score(measure)
```

#### Confusion Matrix

A popular way to show the quality of prediction of a classification model is a confusion matrix.
It gives a quick overview of what observations are misclassified, and how they are misclassified.
The rows in a confusion matrix are the predicted class and the columns are the true class.
All off-diagonal entries are incorrectly classified observations, and all diagonal entries are correctly classified.
More information on `r link("https://en.wikipedia.org/wiki/Confusion_matrix", "Wikipedia")`.

`r mlr3` supports confusion matrices through the `$confusion` property of the `r ref("PredictionClassif")` object:

```{r basics-049}
predictions$confusion
```

In this case, our classifier does fairly well classifying the penguins.

### Binary Classification and Positive Classes {#sec-binary-classif}

Classification problems with a two-class target are called binary classification tasks.
Binary Classification is special in the sense that one of these classes is denoted *positive* and the other one *negative*.
You can specify the *positive class* for a `r ref("TaskClassif", text = "classification task")` object during task creation.
If not explicitly set during construction, the positive class defaults to the first level of the target feature.

```{r basics-050}
# during construction
data("Sonar", package = "mlbench")
task_sonar = as_task_classif(Sonar, target = "Class", positive = "R")

# switch positive class to level 'M'
task_sonar$positive = "M"
```

### Thresholding {#sec-thresholding}

Models trained on binary classification tasks that predict the probability for the positive class usually use a simple rule to determine the predicted class label -- if the probability is more than 50%, predict the positive label; otherwise, predict the negative label.
In some cases, you may want to adjust this threshold, for example, if the classes are very unbalanced (i.e., one is much more prevalent than the other).
For example, in the "german_credit" dataset, the credit risk is good for far more observations.

Training a classifier on this data overpredicts the majority class, i.e. the more prevalent class is more likely to be predicted for any given observation.

```{r basics-thresholding-1}
#| fig-cap: "Comparing predicted and ground truth values for the german_credit dataset."
#| fig-alt: "A stacked bar plot of predicted values in one bar and ground truth values in the other. The more prevalent class is predicted much more often than it is present in the ground truth data."
task_credit = tsk("german_credit")
splits = partition(task_credit)
learner = lrn("classif.rpart", predict_type = "prob")
learner$train(task_credit)
predictions = learner$predict(task_credit)
autoplot(predictions)
```

Changing the prediction threshold allows to address this without having to adjust the hyperparameters of the learner or retrain the model.

```{r basics-thresholding-2}
#| fig-cap: "Comparing predicted and ground truth values for the german_credit dataset with adjusted threshold."
#| fig-alt: "A stacked bar plot of predicted values in one bar and ground truth values in the other. The more prevalent class is now predicted less often and the agreement with the ground truth data is better."
predictions$set_threshold(0.7)
autoplot(predictions)
```

:::{.callout-tip}
Thresholds can be tuned automatically with respect to prediction performance with the `r mlr3pipelines` package using `r ref("mlr_pipeops_tunethreshold", text = "PipeOpTuneThreshold")`.
This is covered in @sec-pipelines.
:::



#### Thresholding For Multiple Classes {.unnumbered .unlisted}

For classification tasks with more than two classes you can also adjust the prediction threshold, which is 0.5 for each class by default.
Thresholds work slightly differently with multiple classes:

* The probability for a data point is divided by each class threshold resulting in `n` ratios for `n` classes.
* The highest ratio is selected (ties are random by default).

Lowering the threshold for a class means that it is more likely to be predicted and raising it has the opposite effect.
The `r ref("datasets::zoo", text = "zoo")` dataset illustrates this concept nicely.  
When trained normally some classes are not predicted at all:


```{r basics-thresholding-3}
#| fig-cap: "Comparing predicted and ground truth values for the zoo dataset."
#| fig-alt: "A stacked bar plot of predicted values in one bar and ground truth values in the other. Some classes are predicted more often than in the ground truth data, some less often."
task = tsk("zoo")
learner = lrn("classif.rpart", predict_type = "prob")
learner$train(task)
preds = learner$predict(task)

autoplot(preds)
```

The classes `amphibian` and `insect` are never predicted. 
On the other hand, the classes `mollusc` and `reptile` are predicted more often than they appear in the truth data.
We can address this by lowering the threshold for `amphibian` and `insect`.
`$set_threshold()` can be given a named list to set the threshold for all classes at once:

```{r basics-thresholding-4}
#| fig-cap: "Comparing predicted and ground truth values for the zoo dataset with adjusted thresholds."
#| fig-alt: "A stacked bar plot of predicted values in one bar and ground truth values in the other. The agreement between predicted and ground truth data is better with the adjusted prediction thresholds."
# c("mammal", "bird", "reptile", "fish", "amphibian", "insect", "mollusc.et.al")
new_thresh = c(0.5, 0.5, 0.5, 0.5, 0.4, 0.4, 0.5)
names(new_thresh) = task$class_names

autoplot(preds$set_threshold(new_thresh))
```

We can again see that adjusting the thresholds results in better predictive performance, without having to retrain a model.


## Row and Column Roles {#sec-row-col-roles}

{{< include _optional.qmd >}}

We have seen that certain columns are designated as "targets" and "features" during task creation; `r mlr3` calls this "roles".
Target refers to the column(s) we want to predict and features are the predictors (also called co-variates or descriptors) for the target.
Besides these two, there are other possible roles for columns.
There are also roles for rows (i.e. "use" - rows with this role are used in training/predicting/etc.).
The roles affect the behavior of the task for different operations.

The `task_mtcars_small` task, for example, has the following column roles:

```{r basics-018}
task_mtcars_small$col_roles[c("feature", "target")]
```

### Column Roles {#sec-col-roles}

There are seven column roles.
We can list all supported column roles by printing the names of the field `$col_roles`:

```{r basics-019}
# supported column roles, see ?Task
names(task_mtcars_small$col_roles)
```

* `"feature"`: Regular feature used in the model fitting process.
* `"target"`: Target variable. Most tasks only accept a single target column.
* `"name"`: Row names / observation labels. To be used in plots. Can be queried with `$row_names`. Not more than a single column can be associated with this role.
* `"order"`: Data returned by `$data()` is ordered by this column (or these columns). Columns must be sortable with `order()`.
* `"group"`: During resampling, observations with the same value of the variable with role `"group"` are marked as "belonging together". For each resampling iteration, observations of the same group will be exclusively assigned to be either in the training set or in the test set. Not more than a single column can be associated with this role.
* `"stratum"`: Stratification variables. Multiple discrete columns may have this role.
* `"weight"`: Observation weights. Not more than one numeric column may have this role.

Columns can have multiple roles.
It is also possible for a column to have no role at all, in which case they are ignored.
This is, in fact, how `$select()` and `$filter()` operate: They unassign the `"feature"` (for columns) or `"use"` (for rows) role without modifying the data which is stored in an immutable backend:

```{r basics-020}
task_mtcars_small$backend
```

There are two main ways to manipulate the col roles of a `Task`:

1. Use the `r ref("Task")` method `$set_col_roles()` (recommended).
1. Directly modify the field `$col_roles`, which is a named list of vectors of column names.
   Each vector in this list corresponds to a column role, and the column names contained in that vector have the corresponding role.

Just as `$select()`/`$filter()`, these are in-place operations, i.e. the task object itself is modified.
To retain an unmodified version of a task, use `$clone()`.

```{r basics-100}
new_task = task_mtcars_small$clone()
```


#### Feature Role Example {#sec-feat-role-ex}

Changing the column or row roles, whether through `$select()`/`$filter()` or directly, does not change the underlying data, it just updates the view on it.
In a previous example we filtered the `"cyl"` column out of the task.
Because the underlying data are still there (and accessible through `$backend`), we can add the `"cyl"` column back into the task by setting its column role to `"feature"`.

```{r basics-021}
task_mtcars_small$set_col_roles("cyl", roles = "feature")
task_mtcars_small$feature_names  # cyl is now a feature again
task_mtcars_small$data()
```

#### Weights Role Example {#sec-weight-role-ex}

In some cases you may wish to weigh data points (rows) differently. For example, if your classification task has severe class imbalance (where the minority class is the class you are more interested in predicting accurately), weighting the minority class rows more heavily may improve the model's performance on that class.

For this example we will work with the built-in `breast_cancer` dataset. There are many more instances of the benign tumor class than the malignant tumor class. We are interested in predicting the malignant tumor class accurately so we will weight these instances.

```{r}
task_cancer = tsk("breast_cancer")
summary(task_cancer$data()$class)
```

```{r}
cancer_data = task_cancer$data()
# adding a column where the weight is 2 when the class == "malignant", and 1 otherwise
cancer_data$weights = ifelse(cancer_data$class == "malignant", 2, 1)
task_cancer = as_task_classif(cancer_data, target = "class")
task_cancer$set_col_roles("weights", roles = "weight")
task_cancer$col_roles[c("feature", "target", "weight")]
```


### Row Roles

Just like columns, it is also possible to assign different roles to rows.
Rows can have two different roles:

1. Role `use`:
  Rows that are generally available for training (although they may also be used for the test set).
  This role is the default role.
  The `$filter()` call changes this role, in the same way that `$select()` changes the `"feature"` column role.
2. Role `validation`:
  Rows that are not used for training.
  Rows that have missing values in the target column during task creation are automatically set to the validation role.

There are several reasons to hold some observations back or treat them differently:

1. It is often good practice to validate the final model on an external validation set to identify overfitting.
2. Some observations may be unlabeled in the original data, e.g. in competitions like `r link("https://www.kaggle.com/", "Kaggle")`.

These observations cannot be used for training a model, but can be used for getting predictions from a trained model.


## Additional Task Types {#sec-task-types-add}

In addition to regression and classification, `r mlr3` supports more types of tasks:

* Clustering (`r ref("mlr3cluster::TaskClust")` in package `r mlr3cluster`): An unsupervised task to identify similar groups within the feature space.

* Survival (`r ref("mlr3proba::TaskSurv")` in package `r mlr3proba`): The target is the (right-censored) time to an event.

* Density (`r ref("mlr3proba::TaskDens")` in package `r mlr3proba`): An unsupervised task to estimate the undetectable underlying probability distribution, based on observed data (as a numeric vector or a one-column matrix-like object).

Other task types that are less common are described in @sec-special.

## Additional Learners {#sec-lrns-add}

As mentioned above, `r mlr3` supports many learners.
They can be accessed through three packages: the `r mlr3` package, the `r mlr3learners` package, and the `r mlr3extralearners` package.

The list of learners included in the `r mlr3` package is dliberately small to avoid large sets of dependencies for this core package:

* Featureless classifier `r ref("mlr_learners_classif.featureless", text = "classif.featureless")`: Simple baseline classification learner.
  Predicts the label that is most frequent in the training set. It can be used as a "fallback learner" to make predictions if another, more sophisticated, learner fails for some reason.
* Featureless regressor `r ref("mlr_learners_regr.featureless", text = "regr.featureless")`: Simple baseline regression learner.
  Predicts the mean of the target values in the training set.
* Rpart decision tree learner `r ref("mlr_learners_classif.rpart", text = "classif.rpart")`: Tree learner from `r ref_pkg("rpart")`.
* Rpart regression tree learner `r ref("mlr_learners_regr.rpart", text = "regr.rpart")`: Tree learner from `r ref_pkg("rpart")`.

The `r mlr3learners` package contains cherry-picked implementations of the most popular machine learning methods:

* Linear (`r ref("mlr_learners_regr.lm", text = "regr.lm")`) and logistic (`r ref("mlr_learners_classif.log_reg", text = "classif.log_reg")`) regression.
* Penalized Generalized Linear Models (`r ref("mlr_learners_regr.glmnet", text = "regr.glmnet")`, `r ref("mlr_learners_classif.glmnet", text = "classif.glmnet")`), possibly with built-in optimization of the penalization parameter (`r ref("mlr_learners_regr.cv_glmnet", text = "regr.cv_glmnet")`, `r ref("mlr_learners_classif.cv_glmnet", text = "classif.cv_glmnet")`).
* (Kernelized) $k$-Nearest Neighbors regression (`r ref("mlr_learners_regr.kknn", text = "regr.kknn")`) and classification (`r ref("mlr_learners_classif.kknn", text = "classif.kknn")`).
* Kriging / Gaussian Process Regression (`r ref("mlr_learners_regr.km", text = "regr.km")`).
* Linear (`r ref("mlr_learners_classif.lda", text = "classif.lda")`) and Quadratic (`r ref("mlr_learners_classif.qda", text = "classif.qda")`) Discriminant Analysis.
* Naïve Bayes Classification (`r ref("mlr_learners_classif.naive_bayes", text = "classif.naive_bayes")`).
* Support-Vector machines (`r ref("mlr_learners_regr.svm", text = "regr.svm")`, `r ref("mlr_learners_classif.svm", text = "classif.svm")`).
* Gradient Boosting (`r ref("mlr_learners_regr.xgboost", text = "regr.xgboost")`, `r ref("mlr_learners_classif.xgboost", text = "classif.xgboost")`).
* Random Forests for regression and classification (`r ref("mlr_learners_regr.ranger", text = "regr.ranger")`, `r ref("mlr_learners_classif.ranger", text = "classif.ranger")`).

A complete list of supported learners across all `r mlr3` packages is hosted on `r link("https://mlr-org.com/learners.html", "our website")`.

The dictionary `r ref("mlr_learners")` contains the supported learners and changes as packages are loaded.
At the time of writing, `r mlr3` supports six learners, `r ref("mlr3learners")` 21 learners, `r ref("mlr3extralearners")` 88 learners, `r ref("mlr3proba")` five learners, and `r ref("mlr3cluster")` 19 learners.

### Listing Learners {#sec-lrns-add-list}

You can list all learners by converting the `r ref("mlr_learners")` dictionary into a `data.table`:

```{r basics-learners-list}
as.data.table(mlr_learners)
```

The resulting `data.table` contains a lot of meta-data that is useful for identifying learners that have particular properties.
For example, we can list all learners that support regression problems:

```{r basics-learners-list-regr}
as.data.table(mlr_learners)[task_type == "regr"]
```

We can check multiple conditions, to for example find all learners that support regression problems and can predict standard errors:

```{r basics-learners-regr-se}
as.data.table(mlr_learners)[task_type == "regr" &
    sapply(predict_types, function(x) "se" %in% x)]
```

Or we can list all learners that support classification problems and missing feature values:

```{r basics-learners-classif-missings}
as.data.table(mlr_learners)[task_type == "classif" &
    sapply(properties, function(x) "missings" %in% x)]
```

## Exercises

1. Using the `r ref("mlr_tasks_sonar", text = "Sonar dataset")`, measure the classification error (`classif.ce`) of a classification tree model (`classif.rpart`) trained with default hyperparameters on 80% of the data and tested on the remaining 20%.
1. Give the true positive, false positive, true negative, and false negative rates of the predictions made by the model in problem 1.
1. Change the threshold of the model from problem 1 such that the false positive rate is lower than the false negative rate.
Give a reason why you might do this.

