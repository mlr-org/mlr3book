# Basics {#sec-basics}

{{< include _setup.qmd >}}

This chapter will teach you the essential building blocks of `r mlr3`, as well as its `r ref_pkg("R6")` classes and operations used for machine learning.

How these building blocks interoperate is summarized in the following figure.

```{r basics-001, echo=FALSE, fig.align="center"}
knitr::include_graphics("images/ml_abstraction.svg")
```

The data, which `r mlr3` encapsulates in [tasks](#tasks), is split into non-overlapping training and test sets.
As we are interested in models that extrapolate to new data rather than just memorizing the training data, the separate test data allows us to objectively evaluate models with respect to their generalization.
The training data is given to a machine learning algorithm, which is implemented within an object called a [learner](#learners) in `r mlr3`.
Examples of these implemented algorithms include a classification tree learner (`r ref("mlr_learners_classif.rpart", text = "classif.rpart")`), a regression support vector machine learner (`r ref("mlr_learners_regr.svm", text = "regr.svm")`), and many others, see [this list](https://mlr-org.com/learners.html).
By using the [learner](#learners) with the training data, the user can model the relationship between the input features and the output target values.
This model can be saved in the [learner](#learners) object and is then used to produce [predictions](#predicting) on the test data, which are compared to the ground truth values to assess the quality of the model.
`r mlr3` offers a number of different [measures](#measure) to quantify how well a model performs based on the difference between predicted and actual values.
Usually, this [measure](#measure) is a numeric score.

Splitting data into training and test sets, building a model, and evaluating it can be repeated several times, [resampling](#resampling) different training and test sets from the original data each time.
Multiple [resampling iterations](#resampling) allow us to get a better and less biased generalizable performance estimate for a particular type of model.
As data are usually partitioned randomly into training and test sets, a single split can, for example, produce training and test sets that are very different, hence creating the misleading impression that the particular type of model does not perform well.

This chapter covers the following topics:

1. [Tasks](#tasks) encapsulate the data with meta-information, such as the name of the prediction target column.
    We cover how to:

    * access [predefined tasks](#tasks-predefined),
    * specify a [task type](#tasks-types),
    * create a [task](#tasks-creation),
    * work with a task's [API](#tasks-api),
    * assign roles to [rows and columns](#tasks-roles) of a task,
    * implement [task mutators](#tasks-mutators), and
    * [retrieve the data](#tasks-api) that is stored in a task.

2. [Learners](#learners) encapsulate machine learning algorithms to train models and make predictions for a [task](#tasks).
    Other packages provide these.
    We cover how to:

    * access the set of [classification and regression learners](#predefined-learners) that come with `r mlr3` and retrieve a specific learner (more types of learners are covered later in the book),
    * access the set of [hyperparameter values](#learner-api) of a learner and modify them.

3. How to [train and predict](#train-predict). In particular, we cover how to:

    * properly set up [tasks](#train-predict-objects) and [learners](#train-predict-objects) for training and prediction,
    * set up [train and test splits](#split-data) for a task,
    * [train](#training) the learner on the training set to produce a model,
    * run the model on the test set to produce [predictions](#predicting), and
    * assess the [performance](#measure) of the model by comparing predicted and actual values.


## Tasks {#sec-tasks}

Tasks are objects that contain the (usually tabular) data and additional meta-data to define a machine learning problem.
The meta-data is, for example, the name of the target variable for supervised machine learning problems, or the type of the dataset (e.g. a _spatial_ or _survival_ task).
This information is used by specific operations that can be performed on a task.

### Task Types {#sec-task-types}

To create a task object, you first need to choose the right task type:

* **Classification Task**: The target feature is discrete and categorical (of type `character` or `factor`). → `r ref("TaskClassif")`.

* **Regression Task**: The target feature is continuous and numeric (of type `integer` or `numeric`). → `r ref("TaskRegr")`.

* **Survival Task**: The target is the (right-censored) time to an event. More censoring types are currently in development. → `r ref("mlr3proba::TaskSurv")` in add-on package `r mlr3proba`.

* **Density Task**: An unsupervised task to  estimate the undetectable underlying probability distribution, based on observed data (of form numeric vector or a one column matrix-like object). → `r ref("mlr3proba::TaskDens")` in add-on package `r mlr3proba`.

* **Cluster Task**: An unsupervised task to identify similar groups within the feature space. → `r ref("mlr3cluster::TaskClust")` in add-on package `r mlr3cluster`.

* **Other Tasks**: Other task types that are less common can be found in @sec-special.

In the following sections we cover important information specialized to the type of task you are interested in.

### Built-in Tasks {#sec-tasks-built-in}

`r mlr3` includes a few predefined machine learning tasks.
All tasks are stored in an R6 `r ref("Dictionary")` (a key-value store) named `r ref("mlr_tasks")`.
Printing it gives information about each key (the names of the datasets).

The columns `"lgl"` (`r ref("logical")`), `"int"` (`r ref("integer")`), `"dbl"` (`r ref("double")`), `"chr"` (`r ref("character")`), `"fct"` (`r ref("factor")`), `"ord"` (`r ref("ordered", text = "ordered factor")`) and `"pxc"` (`r ref("POSIXct")` time) show the number of features in the task of the respective type.

```{r basics-002}
as.data.table(mlr_tasks)
```

To get a task from the dictionary, use the `$get()` method from the `mlr_tasks` class and assign the return value to a new variable
As getting a task from a dictionary is a very common problem, `r mlr3` provides the shortcut function `r ref("tsk()")`.
Here, we retrieve the `r ref("mlr_tasks_penguins", text = "palmer penguins classification task")`, which is provided by the imported package `r ref_pkg("palmerpenguins")`:

```{r basics-003}
task_penguins = tsk("penguins")
print(task_penguins)
```

To get more information about a particular task, it is easiest to use the `help()` method that all `r mlr3`-objects come with:

```{r basics-004, eval = FALSE}
task_penguins$help()
```

Alternatively, the corresponding man page can be found under `mlr_tasks_[id]`, e.g. `r ref("mlr_tasks_penguins")`:

```{r basics-005, eval = FALSE}
help("mlr_tasks_penguins")
```

:::{.callout-tip}
Thousands more data sets are readily available via [Openml.org](https://openml.org) ([@openml2013]) and `r ref_pkg("mlr3oml")`.
E.g., to download the data set ["credit-g"](https://www.openml.org/search?type=data&id=31) with data id `31` and automatically convert it to a classification task:

```{r basics-006, eval = FALSE}
library("mlr3oml")
tsk("oml", task_id = 31)
```
:::

### Task API {#sec-tasks-api}

All properties and characteristics of tasks can be queried using the task's public fields and methods (see `r ref("Task")`).
Methods can also be used to change the stored data and the behavior of the task.

## Learners {#sec-learners}

### Built-in Learners {#sec-lrns-built-in}

`r mlr3` offers many learners which can be access through three packages: The `r mlr3` package, the `r mlr3learners` package, and the `r mlr3extralearners` package.

**`r mlr3` Built-in Learners** - This package ships with the following set of classification and regression learners.
We deliberately keep this small to avoid unnecessary dependencies.

* `r ref("mlr_learners_classif.featureless", text = "classif.featureless")`: Simple baseline classification learner.
  The default is to always predict the label that is most frequent in the training set. While this is not very useful by itself, it can be used as a "[fallback learner](fallback-learners)" to make predictions in case another, more sophisticated, learner failed for some reason.
* `r ref("mlr_learners_regr.featureless", text = "regr.featureless")`: Simple baseline regression learner.
  The default is to always predict the mean of the target in training set. Similar to `r ref("mlr_learners_classif.featureless")`, it makes for a good "[fallback learner](fallback-learners)"
* `r ref("mlr_learners_classif.rpart", text = "classif.rpart")`: Single classification tree from package `r ref_pkg("rpart")`.
* `r ref("mlr_learners_regr.rpart", text = "regr.rpart")`: Single regression tree from package `r ref_pkg("rpart")`.

**`r mlr3learners` Built-in Learners** - This package ships cherry-picked implementations of the most popular machine learning methods.

* Linear (`r ref("mlr_learners_regr.lm", text = "regr.lm")`) and logistic (`r ref("mlr_learners_classif.log_reg", text = "classif.log_reg")`) regression
* Penalized Generalized Linear Models (`r ref("mlr_learners_regr.glmnet", text = "regr.glmnet")`, `r ref("mlr_learners_classif.glmnet", text = "classif.glmnet")`), possibly with built-in optimization of the penalization parameter (`r ref("mlr_learners_regr.cv_glmnet", text = "regr.cv_glmnet")`, `r ref("mlr_learners_classif.cv_glmnet", text = "classif.cv_glmnet")`)
* (Kernelized) $k$-Nearest Neighbors regression (`r ref("mlr_learners_regr.kknn", text = "regr.kknn")`) and classification (`r ref("mlr_learners_classif.kknn", text = "classif.kknn")`).
* Kriging / Gaussian Process Regression (`r ref("mlr_learners_regr.km", text = "regr.km")`)
* Linear (`r ref("mlr_learners_classif.lda", text = "classif.lda")`) and Quadratic (`r ref("mlr_learners_classif.qda", text = "classif.qda")`) Discriminant Analysis
* Naive Bayes Classification (`r ref("mlr_learners_classif.naive_bayes", text = "classif.naive_bayes")`)
* Support-Vector machines (`r ref("mlr_learners_regr.svm", text = "regr.svm")`, `r ref("mlr_learners_classif.svm", text = "classif.svm")`)
* Gradient Boosting (`r ref("mlr_learners_regr.xgboost", text = "regr.xgboost")`, `r ref("mlr_learners_classif.xgboost", text = "classif.xgboost")`)
* Random Forests for regression and classification (`r ref("mlr_learners_regr.ranger", text = "regr.ranger")`, `r ref("mlr_learners_classif.ranger", text = "classif.ranger")`)

**`r mlr3extralearners` Built-in Learners** - This package ships more machine learning methods and alternative implementations.

* A full list of `r mlr3extralearners` collected in the [mlr3extralearners repository](https://github.com/mlr-org/mlr3extralearners/).

:::{.callout-tip}
A full list of available learners across all `r mlr3` packages is hosted on our website: [list of learners](https://mlr-org.com/learners.html).
:::

Analogously to `r ref("mlr_tasks")` storing the shipped tasks, the dictionary `r ref("mlr_learners")` stores implemented learners.

```{r basics-007}
library("mlr3learners")       # load recommended learners provided by mlr3learners package
library("mlr3extralearners")  # this loads further less-well-supported learners
library("mlr3proba")          # this loads some survival and density estimation learners
library("mlr3cluster")        # this loads some learners for clustering

data.frame(learners=head(mlr_learners$keys(),3))
```


## Regression {#sec-regr}

As covered above, regression tasks involve a numeric, continuous target variable.
The following regression tasks ship with the `r mlr3` package.
For the examples in this section we will use the `r ref("datasets::mtcars", text = "mtcars")` dataset.

```{r basics-008}
as.data.table(mlr_tasks)[task_type == "regr"]
```

### Regression Tasks {#sec-regr-tsks}

While `r ref("datasets::mtcars", text = "mtcars")` ships with `r mlr3` and can be retrieved using the sugar function `tsk()`, it is useful to see how to create a task from scratch.

`r ref("datasets::mtcars", text = "mtcars")` contains characteristics for different types of cars, along with their fuel consumption.
We predict the numeric target variable stored in column `"mpg"` (miles per gallon).
Here, we only consider the first two features in the dataset for brevity:

```{r basics-009}
data("mtcars", package = "datasets")
data = mtcars[, 1:3]
str(data)
```

Next, we create a regression task, i.e. we construct a new instance of the R6 class `r ref("TaskRegr")`.
Here instead, we are calling the converter `r ref("as_task_regr()")` to convert our `data.frame()` stored in the object `data` to a regression task and provide the following additional information:

1. `x`: Object to convert.
  Works for rectangular data formats such as `data.frame()`, `data.table()`, or `tibble()`.
  Internally, the data is converted and stored in an abstract `r ref("DataBackend")`.
1. `target`: The name of the prediction target column for the regression problem, here miles per gallon (`"mpg"`).
1. `id` (optional): An arbitrary identifier for the task, used in plots and summaries.
   If not provided, the deparsed name of `x` will be used.

```{r basics-010}
library("mlr3")

task_mtcars = as_task_regr(data, target = "mpg", id = "cars")
print(task_mtcars)
```

The `print()` method gives a short summary of the task:
It has `r task_mtcars$nrow` observations and `r task_mtcars$ncol` columns, of which `r length(task_mtcars$feature_names)` are features stored in double-precision floating point format.

#### Plotting {#sec-regr-plotting}

We can also plot the task using the `r mlr3viz` package, which gives a graphical summary of its properties:

```{r basics-011, message=FALSE}
library("mlr3viz")
autoplot(task_mtcars, type = "pairs")
```

:::{.callout-tip}
Instead of loading multiple extension packages individually, it is often more convenient to load the `r mlr3verse` package instead.
`mlr3verse` imports the Namespace of most `r mlr3` packages and re-exports functions which are used for common machine learning and data science tasks.
:::

#### Retrieving Data {#sec-retrieve-data}

The `r ref("Task")` object primarily represents a tabular dataset, combined with meta-data about which columns of that data should be used to predict which other columns in what way, as well as some more information about column data types.

Various fields can be used to retrieve meta-data about a task. The dimensions can, for example, be retrieved using `$nrow` and `$ncol`:

```{r basics-012}
task_mtcars$nrow
task_mtcars$ncol
```

The names of the feature and target columns are stored in the `$feature_names` and `$target_names` slots, respectively. Here, "target" refers to the variable we want to predict and "feature" to the predictors for the task.

```{r basics-013}
task_mtcars$feature_names
task_mtcars$target_names
```

While the columns of a task have unique `character`-valued names, their rows are identified by unique natural numbers, called row-IDs. They can be accessed through the `$row_ids` slot:

```{r basics-014}
head(task_mtcars$row_ids)
```

:::{.callout-warning}
Although the row IDs are typically just the sequence from `1` to `nrow(data)`, they are only guaranteed to be unique natural numbers. It is possible that they do not start at `1`, that they are not increasing by 1 each, or that they are not even in increasing order.
The reasoning behind this is simple: we allow to transparently operate on real database management systems, and the uniqueness is the only requirement for primary keys in data bases. For more info on connecting to data bases, see [backends](#backends).
:::

The data contained in a task can be accessed through `$data()`, which returns a `data.table` object.
It has optional `rows` and `cols` arguments to specify subsets of the data to retrieve.
When a database backend is used, then this avoids loading unnecessary data into memory, making it more efficient than retrieving the entire data first and then subsetting it using `[<rows>, <cols>]`.

```{r basics-015}
task_mtcars$data()
# retrieve data for rows with ids 1, 5, and 10 and select column "mpg"
task_mtcars$data(rows = c(1, 5, 10), cols = "mpg")
```

To extract the complete data from the task, one can also convert it to a `data.table`:

```{r basics-016}
# show summary of entire data
summary(as.data.table(task_mtcars))
```

#### Task Mutators {#sec-tasks-mutators}

It is often necessary to create tasks that encompass subsets of other tasks' data, for example to manually create [train-test-splits](#train-test-splits), or to fit models on a subset of given features. Restricting tasks to a given set of features can be done by calling `$select()` with the desired feature names. Restriction to rows is done with `$filter()` with the row-IDs.

```{r basics-017}
task_mtcars_small = tsk("mtcars")
task_mtcars_small$select(c("am", "carb")) # keep only these features
task_mtcars_small$filter(2:4) # keep only these rows
task_mtcars_small$data()
```

These methods are so-called *mutators*, they modify the given `Task` in-place. If you want to have an unmodified version of the task, you need to use the `$clone()` method to create a copy first.

```{r basics-018}
task_mtcars_smaller = task_mtcars_small$clone()
task_mtcars_smaller$filter(2)
task_mtcars_smaller$data()
task_mtcars_small$data()  # this task is unmodified
```

Note also how the last call to `$filter(2)` did not select the second row of the `task_mtcars_small`, but selected the row with ID 2, which is the *first* row of `task_mtcars_small`.

:::{.callout-tip}
If you ever really need to work with row numbers instead of row-IDs, you can work-around by operating on the row ids and pass the result back to the task:

```{r basics-019, eval = FALSE}
# keep the 2nd row:
keep = task$row_ids[2] # extracts id of 2nd row
task_mtcars_smaller$filter(keep)
```
:::

While the methods above allow us to subset the data, the methods `$rbind()` and `$cbind()` allow adding extra rows and columns to a task.

```{r basics-020}
task_mtcars_smaller$rbind( # add another row
  data.frame(mpg = 23, am = 0, carb = 3)
)
task_mtcars_smaller$cbind(data.frame(letters = letters[2:4])) # add column with letters
task_mtcars_smaller$data()
```

#### Roles (Rows and Columns) {#sec-tasks-roles}

We have seen that certain columns are designated as "targets" and "features" during task creation, their "roles":
Target refers to the variable(s) we want to predict and features are the predictors (also called co-variates) for the target.
Besides these two, there are other possible roles for columns, see the documentation of `r ref("Task")`. These roles affect the behavior of the task for different operations.

The previously-constructed `task_mtcars_small` task, for example, has the following column roles:

```{r basics-021}
task_mtcars_small$col_roles
```

Columns can have multiple roles. It is also possible for a column to have no role at all, in which case they are ignored. This is, in fact, how `$select()` and `$filter()` operate: They unassign the `"feature"` (for columns) or `"use"` (for rows) role without modifying the data which is stored in an immutable backend:

```{r basics-022}
task_mtcars_small$backend
```

There are two main ways to manipulate the col roles of a `Task`:

1. Use the `r ref("Task")` method `$set_col_roles()` (recommended).
1. Simply modify the field `$col_roles`, which is a named list of vectors of column names.
   Each vector in this list corresponds to a column role, and the column names contained in that vector have that role.

Just as `$select()`/`$filter()`, these are in-place operations, so the task object itself is modified. To retain another unmodified version of a task, use `$clone()`.

Changing the column or row roles, whether by `$select()`/`$filter()` or directly, does not change the underlying data, it just updates the view on it.
Because the underlying data is still there (and accessible through `$backend`), we can add the `"cyl"` column back into the task by setting its col role to `"feature"`.
```{r basics-023}
task_mtcars_small$set_col_roles("cyl", roles = "feature")
task_mtcars_small$feature_names  # cyl is now a feature again
task_mtcars_small$data()
```

Supported column roles can be found in the manual of `r ref("Task")`, or just by printing the names of the field `$col_roles`:

```{r basics-024}
# supported column roles, see ?Task
names(task_mtcars_small$col_roles)
```

Just like columns, it is also possible to assign different roles to rows. Rows can have two different roles:

1. Role `use`:
  Rows that are generally available for model fitting (although they may also be used as test set in resampling).
  This role is the default role. The `$filter()` call changes this role, in the same way that `$select()` changes the `"feature"` role.
2. Role `validation`:
  Rows that are not used for training.
  Rows that have missing values in the target column during task creation are automatically set to the validation role.

There are several reasons to hold some observations back or treat them differently:

1. It is often good practice to validate the final model on an external validation set to identify possible overfitting.
2. Some observations may be unlabeled, e.g. in competitions like [Kaggle](https://www.kaggle.com/).

These observations cannot be used for training a model, but can be used to get predictions.

#### Plotting Tasks {#sec-autoplot-task}

The `r mlr3viz` package provides plotting facilities for many classes implemented in `r mlr3`.
The available plot types depend on the class, but all plots are returned as `r ref_pkg("ggplot2")` objects which can be easily customized.

For regression tasks (inheriting from `r ref("TaskRegr")`), see the documentation `r ref("mlr3viz::autoplot.TaskRegr")` for the implemented plot types.
Here are some examples to get an impression:

```{r basics-025, warning = FALSE, message = FALSE}
library("mlr3viz")

# get the complete mtcars task
task = tsk("mtcars")

# subset task to only use the 3 first features
task$select(head(task$feature_names, 3))

# default plot: boxplot of target variable
autoplot(task)

# pairs plot (requires package GGally)
autoplot(task, type = "pairs")
```

### Regression Learners {#sec-regr-lrns}

Objects of class `r ref("Learner")` provide a unified interface to many popular machine learning algorithms in R.
They consist of methods to train and predict a model for a `r ref("Task")` and provide meta-information about the learners, such as the hyperparameters (which control the behavior of the learner) you can set.

The base class of each learner is `r ref("Learner")`, specialized for regression as `r ref("LearnerRegr")`.

All Learners work in a two-stage procedure:

* **Training stage**: The training task (features and target data) is passed to the Learner's `$train()` function which trains and stores a model, i.e. the relationship of the target and features.
* **Predict stage**: The new data, usually a different slice of the original data than used for training, is passed to the `$predict()` method of the Learner.
  The model trained in the first step is used to predict the missing target, e.g. labels for classification problems or the numerical value for regression problems.

```{r basics-026, echo=FALSE, fig.align="center"}
knitr::include_graphics("images/learner.svg")
```

To retrieve a `r ref("Learner")` from the `r mlr_learner` dictionary, use the syntactic sugar function `r ref("lrn()")`:

```{r basics-027}
lm_learner = lrn("regr.lm")
```

Each learner provides the following meta-information:

* `$feature_types`: the type of features the learner can deal with.
* `$packages`: the packages required to train a model with this learner and make predictions.
* `$properties`: additional properties and capabilities.
  For example, a learner has the property "missings" if it is able to handle missing feature values, and "importance" if it computes and allows to extract data on the relative importance of the features.
* `$predict_types`: possible prediction types. For example, a classification learner can predict labels ("response") or probabilities ("prob").

This information can be queried through these slots, or seen at a glance from the printer:
```{r basics-028}
print(lm_learner)
```

Furthermore, each learner has hyperparameters that control its behavior, for example whether to provide verbose output during training.
Setting hyperparameters to values appropriate for a given machine learning task is crucial.
The field `param_set` stores a description of the hyperparameters the learner has, their ranges, defaults, and current values:

```{r basics-029}
lm_learner$param_set
```

The set of current hyperparameter values is stored in the `values` field of the `param_set` field.
You can access and change the current hyperparameter values by accessing this field, it is a named list:

```{r basics-030}
lm_learner$param_set$values
lm_learner$param_set$values$level = 0.75
lm_learner$param_set$values
```

:::{.callout-tip}
It is possible to assign all hyperparameters in one go by assigning a named list to `$values`: `learner$param_set$values = list(df = 3, ...)`. However, be aware that this operation also removes all previously set hyperparameters.
:::

The `r ref("lrn()")` function also accepts additional arguments to update hyperparameters or set fields of the learner in one go:

```{r basics-031}
lm_learner = lrn("regr.lm", df = 3, level = 0.75)
lm_learner$param_set$values
```

More on this is discussed in the section on [Hyperparameter Tuning](#tuning).

### Regression Evaluation {#sec-regr-eval}

An important step of modeling is evaluating the performance of the trained model.
`r mlr3` offers many available performance measures.

Available measures can be retrieved using the `r ref("msr()")` function, which accesses objects in `r ref("mlr_measures")`:

```{r basics-032}
data.frame(learners=head(mlr_measures$keys(),3))
as.data.table(mlr_measures)[task_type == "regr"]
```

Measure objects can contain a single performance measurement or multiple by using `r ref("msr()")` or the plural `r ref("msrs()")` functions respectively:

```{r basics-033}
measure = msr("regr.rmse")
measures = msrs(c("regr.rmse", "regr.sse"))
```

:::{.callout-note}
`$score()` can called without a given measure. Regression defaults to the mean squared error (`r ref("mlr_measures_regr.mse", text = "regr.mse")`).
:::

## Classification {#sec-classif}

Classification tasks involve a discrete, categorical target variable.
The following classification tasks ship with the `r mlr3` package.
For the examples in this section we will use the `r ref("datasets::penguins", text = "penguins")` dataset.

```{r basics-034}
as.data.table(mlr_tasks)[task_type == "classif"]
```

### Classification Tasks {#sec-classif-tsks}

`r ref("datasets::penguins", text = "penguins")` ships with `r mlr3` and can be retrieved using the sugar function `tsk()`.

```{r basics-035}
penguins_task = tsk("penguins")
penguins_task
```

This task has `r penguins_task$nrow` observations and `r penguins_task$ncol` columns, of which `r length(penguins_task$feature_names)` are features stored in double-precision floating point format.

#### Plotting Tasks {#sec-classif-plotting}

For classification tasks (inheriting from `r ref("TaskClassif")`), see the documentation of `r ref("mlr3viz::autoplot.TaskClassif")` for the implemented plot types.
Here are some examples to get an impression:

```{r basics-036, warning = FALSE, message = FALSE}
library("mlr3viz")

# get the penguins task
task = tsk("penguins")

# subset task to only use the 3 first features
task$select(head(task$feature_names, 3))

# default plot: class frequencies
autoplot(task)

# pairs plot (requires package GGally)
autoplot(task, type = "pairs")

# duo plot (requires package GGally)
autoplot(task, type = "duo")
```

### Classification Learners {#sec-classif-lrns}

The base class of each learner is `r ref("Learner")`, specialized for classification as `r ref("LearnerClassif")`.

To retrieve a `r ref("Learner")` from the `r mlr_learner` dictionary, use the syntactic sugar function `r ref("lrn()")`:

```{r basics-037}
rpart_learner = lrn("classif.rpart")
rpart_learner
```

### Classification Evaluation {#sec-classif-eval}

An important step of modeling is evaluating the performance of the trained model.
`r mlr3` offers many available performance measures.

Available measures can be retrieved using the `r ref("msr()")` function, which accesses objects in `r ref("mlr_measures")`:

```{r basics-038}
head(as.data.table(mlr_measures)[task_type == "classif"], 3)
```

:::{.callout-note}
`$score()` can called without a given measure. Classification defaults to classification error (`r ref("mlr_measures_classif.ce", text = "classif.ce")`.
:::

### Binary Classification {#sec-binary-classif}

Classification problems with a target variable with only two classes are called binary classification tasks.
They are special in the sense that one of these classes is denoted *positive* and the other one *negative*.
You can specify the *positive class* within the `r ref("TaskClassif", text = "classification task")` object during task creation.
If not explicitly set during construction, the positive class defaults to the first level of the target variable.

```{r basics-039}
# during construction
data("Sonar", package = "mlbench")
task = as_task_classif(Sonar, target = "Class", positive = "R")

# switch positive class to level 'M'
task$positive = "M"
```

## Train, Predict, Assess Performance {#sec-train-predict}

In this section, we explain how [tasks](#tasks) and [learners](#learners) can be used to train a model and predict on a new dataset. This process consists of three steps:
1. **Train** a [learner](#learners) by optimizing the model parameters (i.e. m and b in y = mx + b) based on the given data (training set) to minimize error.
2. **[Predict](#predicting)** the label for observations that the model has not seen during training (testing set).
3. **[Assess Performance](#sec-measure)** by comparing the predictions to ground truth values using a performance measure(s).

The concept is demonstrated on a supervised classification task using the `r ref("mlr_tasks_pima", text = "pima")` dataset, in which patient data is used to diagnostically predict diabetes, and the `r ref("mlr_learners_classif.rpart", text = "rpart")` learner, which builds a classification tree.
As shown in the previous chapters, we load these objects and specify hyperparameters using the short access functions `r ref("tsk()")` and  `r ref("lrn()")`.

```{r basics-040}
task = tsk("pima")
learner = lrn("classif.rpart", maxdepth = 4)
```

### Training the learner {#sec-training}

Use the `r ref("partition()")` helper function to randomly split the rows of the Pima task into two disjunct sets: a training set (80%) and a test set (20%).
Fit the classification tree using the training set of the task by calling the `$train()` method and specifying the `row_ids` to use for training with `splits$train`.
This operation modifies the `r ref("Learner")` in-place by adding the fitted model to the existing object.
We can now access the stored model via the field `$model`.

```{r basics-041}
splits = partition(task, ratio = 0.8)
learner$train(task, splits$train)
learner$model
```

Inspecting the output, we see that the learner has identified features in the task that are predictive of the class (diabetes status) and uses them to partition observations in the tree.
There are additional details on how the data is partitioned across branches of the tree; the textual representation of the model depends on the type of learner.
For more information on this particular type of model and its output, see `r ref ("rpart::print.rpart()")`.

### Performance assessment {#sec-measure}

Predictions are made on the data the model did not use during training (testing set), these predictions are stored in a `r ref("Prediction")` object.
The predictions are then compared with the known ground-truth values, also stored in the `r ref("Prediction")` object.
The exact nature of this comparison is defined by a measure, which is given by a `"Measure"` object.
If the prediction was made on a dataset without the target column, i.e., without known true labels, then performance can not be calculated.

Test set predictions are made using the `$predict()` function and specifying the test set `row_ids` with `splits$test` that we defined in the [Training the Learner section](#sec-training).

```{r basics-042}
prediction = learner$predict(task, splits$test)
```

We choose accuracy (`r ref("mlr_measures_classif.acc", text = "classif.acc")`) as our specific performance measure here and call the method `$score()` of the `predictions` object to quantify the predictive performance of our model.

```{r basics-043}
measure = msr("classif.acc")
measure
prediction$score(measure)
```

It is possible to calculate multiple measures at the same time by passing a list to `$score()`. Such a list can easily be constructed using the "plural" `msrs()` function. If one wanted to have both the "true positive rate" (`"classif.tpr"`) and the "true negative rate" (`"classif.tnr"`), one would use:

```{r basics-044}
measures = msrs(c("classif.tpr", "classif.tnr"))
prediction$score(measures)
```

#### Confusion Matrix

A special case of performance evaluation is the confusion matrix, which shows, for each class, how many observations were predicted to be in that class and how many were actually in it (more information on [Wikipedia](https://en.wikipedia.org/wiki/Confusion_matrix)).
The entries along the diagonal denote the correctly classified observations.

```{r basics-045}
prediction$confusion
```

In this case, we can see that our classifier seems to misclassify a relatively large number of negative samples as positive. Depending on the application being considered, it is possible that it is more important to keep false negatives (upper right element of the confusion matrix) low. Raising the threshold, so that ambiguous samples are more readily classified as negative rather than positive, can help in this case, although it will also lead to positive cases being classified as `"neg"` more often. Read more about this in the [thresholding](#sec-thresholding) section.

### Predicting {#sec-predicting}

After the model has been created, we can now use it for prediction. It is possible that a model was fitted on all labeled data that was available, and should now be used to make predictions for new data for which the actual labels are unknown. Here we simulate this by creating example data.

```{r basics-046}
pima_new = data.frame(age  = c(24, 47),
                      glucose = c(145, 133),
                      insulin  = c(306, NA),
                      mass = c(41.7, 23.3),
                      pedigree  = c(0.5, 0.2),
                      pregnant = c(3, 7),
                      pressure = c(52, 83),
                      triceps = c(36, 28)
                      )
pima_new
```

The learner does not need to know more meta-information about this data to make a prediction, such as which columns are features and targets, since this was already included in the training task.
Instead, this data can directly be used to make a prediction using `$predict_newdata()`:

```{r basics-047}
prediction = learner$predict_newdata(pima_new)
prediction
```

This method returns a `r ref("Prediction")` object.
More precisely, because the `learner` is a `r ref("LearnerClassif")`, it returns a `r ref("PredictionClassif")` object.

Here the `"truth"` column is `NA`, since the target column was not provided in the `pima_new` data frame.
If we add the column, we will have the true and predicted labels side by side in the prediction object.

```{r basics-048}
pima_new_known = cbind(pima_new, diabetes = factor("neg", levels = c("pos", "neg")))
prediction = learner$predict_newdata(pima_new_known)
prediction
```

Note that it is sometimes helpful first to convert the data to predict on a task.
Predicting on the task's data works analogously, you only need to call the `$predict()` method instead of `$predict_newdata()`:

```{r basics-049}
task_pima_new = as_task_classif(pima_new_known, target = "diabetes")
prediction = learner$predict(task_pima_new)
prediction
```

### Changing the Predict Type {#sec-predict-type}

Classification learners default to predicting the class label.
However, many classifiers also tell you how sure they are about the predicted label by providing posterior probabilities for the classes.
To predict these probabilities, the `predict_type` field of a `r ref("LearnerClassif")` must be changed from `"response"` (the default) to `"prob"` before training:

```{r basics-050}
learner$predict_type = "prob"

# re-fit the model
learner$train(task)

# rebuild prediction object
prediction = learner$predict(task_pima_new)
prediction
```

The prediction object now contains probabilities for all class labels in addition to the predicted label (the one with the highest probability):

```{r basics-051}
# directly access the predicted labels:
prediction$response

# directly access the matrix of probabilities:
prediction$prob
```

Similarly to predicting probabilities for classification, many `r ref("LearnerRegr", text = "regression learners")` support the extraction of standard error estimates for predictions by setting the predict type to `"se"`.

### Thresholding {#sec-thresholding}

Models trained on binary classification tasks that predict the probability for the positive class usually use a simple rule to determine the predicted class label: if the probability is more than 50%, predict the positive label, otherwise, predict the negative label.
In some cases, you may want to adjust this threshold, for example, if the classes are very unbalanced (i.e., one is much more prevalent than the other).

In the example below, we change the threshold to 0.2, making the model predict `"pos"` for both example rows:

```{r basics-052}
prediction$set_threshold(0.2)
prediction
```

:::{.callout-tip}
Thresholds can be tuned automatically with the `r mlr3pipelines` package, i.e. using `r ref("mlr_pipeops_tunethreshold", text = "PipeOpTuneThreshold")`.
:::

### Predicting on known data and train/test splits

We will usually not want to wait with performance evaluation until new data becomes available.
Instead, we will work with all the training data available at a given point.
However, when evaluating the performance of a `r ref("Learner")`, it is also important to score predictions made on data that have not been seen during training, since making predictions on training data is too easy in general -- a `r ref("Learner")` could just memorize the training data responses and get a perfect score.

`r mlr3` makes it easy to only train on subsets of given tasks. We first create a vector indicating on what row IDs of the task the `r ref("Learner")` should be trained, and another that indicates the remaining rows that should be used for prediction. These vectors indicate the train-test-split we are using.
This is done manually here for demonstration purposes: In @sec-resampling, we show how `r mlr3` can automatically create training and test sets based on resampling strategies that can be more elaborate.

We will use 67% of all available observations to train and predict on the remaining 33%.

```{r basics-053}
set.seed(7)
train_set = sample(task$row_ids, 0.67 * task$nrow)
test_set = setdiff(task$row_ids, train_set)
```

:::{.callout-caution}
Do not use constructs like `sample(task$nrow, ...)` to subset tasks, since rows are always identified by their `$row_ids`.
These are not guaranteed to range from 1 to `task$nrow` and could be any positive integer.
:::

Both `$train()` and `$predict()` have an optional `row_ids`-argument that determines which rows are used. Note that it is not a problem to run `$train()` with a `r ref("Learner")` that has already been trained: the old model is automatically discarded, and the learner trains from scratch.

```{r basics-054}
# train on the training set
learner$train(task, row_ids = train_set)

# predict on the test set
prediction = learner$predict(task, row_ids = test_set)

# the prediction naturally knows about the "truth" from the task
prediction
```

### Plotting Predictions {#sec-autoplot-prediction}

Similarly to [plotting tasks](#autoplot-task), `r mlr3viz` provides an `r ref("ggplot2::autoplot()", text = "autoplot()")` method for `r ref("Prediction")` objects.
All available types are listed in the manual pages for `r ref("autoplot.PredictionClassif()")`, `r ref("autoplot.PredictionRegr()")` and the other prediction types (defined by extension packages).

```{r basics-055, message = FALSE, warning = FALSE}
task = tsk("penguins")
learner = lrn("classif.rpart", predict_type = "prob")
learner$train(task)
prediction = learner$predict(task)

library("mlr3viz")
autoplot(prediction)
```
