# Model Optimization {#optimization .unnumbered}

{{< include _setup.qmd >}}

In machine learning, when you are dissatisfied with the performance of a model, you might ask yourself how to best improve the model:

* Can it be improved by tweaking the hyperparameters of the learner, i.e. the configuration options that affect its behavior?
* Or, should you just use a completely different learner for this particular task?

This chapter might help answer this question.

**Model Tuning {#sec-optimization-model-tuning}**

Machine learning algorithms have default values set for their hyperparameters.
In many cases, these hyperparameters need to be changed by the user to achieve optimal performance on the given dataset.
While you can certainly search for hyperparameter settings that improve performance manually, we do not recommend this approach as it is tedious and rarely leads to the best performance.
Fortunately, the `r mlr_pkg("mlr3")` ecosystem provides packages and tools for automated tuning.
To tune a machine learning algorithm, you have to specify

1. the [search space](#tuning-optimization),
1. the [optimization algorithm](#tuning-algorithms) (i.e. tuning method),
1. an evaluation method (i.e., a resampling strategy), and
1. a performance measure.

In the [tuning](#tuning) part, we will have a look at:

* empirically sound [hyperparameter tuning](#tuning),
* selecting the [optimizing algorithm](#tuning-optimization),
* defining [search spaces concisely](#searchspace),
* [triggering](#tuning-triggering) the tuning, and
* [automating](#autotuner) tuning.

We will use the `r mlr_pkg("mlr3tuning")` package, which supports common tuning operations.

**Feature Selection {#sec-optimization-feature-selection}**

Tuning the hyperparameters is only one way of improving the performance of your model.
The second part of this chapter explains [feature selection](#fs), also known as variable or descriptor selection.
[Feature selection](#fs) is the process of finding the feature subset that is most relevant with respect to the prediction or for which the learner fits a model with the highest performance.
Apart from improving model performance, there are additional reasons to perform feature selection:

* enhance the interpretability of the model,
* speed up model fitting, or
* eliminate the need to collect lots of expensive features.

Here, we mostly focus on feature selection as a means of improving model performance.

There are different approaches to identifying the relevant features.
In the [feature selection](#fs) part, we describe three methods:

* [Filter](#fs-filter) algorithms select features independently of the learner by scoring the different features.
* [Variable importance filters](#fs-var-imp-filters) select features that are important according to the model induced by a learner.
* [Wrapper methods](#fs-wrapper) iteratively select features to optimize a performance measure, each time fitting and evaluating a model with a different subset of features.

Note that filters operate independently of learners.
Variable importance filters rely on the learner to extract information on feature importance from a trained model, for example, by inspecting a learned decision tree and returning the features that are used in the first few levels.
The obtained importance values can be used to subset the data, which can then be used to train a learner.
Wrapper methods can be used with any learner but need to train the learner potentially many times, making this the most expensive method.

**Nested Resampling {#sec-optimization-nested-resampling}**

For hyperparameter tuning, a normal resampling (e.g. a cross-validation) is no longer sufficient to ensure an unbiased evaluation.
Consider the following thought experiment to gain intuition for why this is the case.
Suppose a learner has a hyperparameter that has no real effect on the fitted model, but only introduces random noise into the predictions.
Evaluating different values for this hyperparameter, one will show the best performance (purely randomly).
This is the hyperparameter value that will be chosen as the best, although the hyperparameter has no real effect.
To discover this, another separate validation set is required -- it will reveal that the "optimized" setting really does not perform better than anything else.

We need a nested resampling to ensure unbiased estimates of the generalization error during hyperparameter optimization.
We discuss the following aspects in this part:

* [Inner and outer resampling strategies](#nested-resampling) in nested resampling.
* The [execution](#nested-resamp-exec) of nested resampling.
* The [evaluation](#nested-resamp-eval) of resampling iterations.


## Hyperparameter Tuning {#tuning}

```{r 04-optimization-001, include = F}
library(mlr3)
library(mlr3book)
```

Hyperparameters are the parameters of the learners that control how a model is fit to the data.
They are sometimes called second-level or second-order parameters of machine learning -- the parameters of the *models* are the first-order parameters and "fit" to the data during model training.
The hyperparameters of a learner can have a major impact on the performance of a learned model, but are often only optimized in an ad-hoc manner or not at all.
This process is often called model 'tuning'.

Hyperparameter tuning is supported via the `r mlr3book::mlr_pkg("mlr3tuning")` extension package.
Below you can find an illustration of the general process:

```{r 04-optimization-002, echo = FALSE}
knitr::include_graphics("images/tuning_process.svg")
```

At the heart of `r mlr3book::mlr_pkg("mlr3tuning")` are the R6 classes

* `r ref("TuningInstanceSingleCrit")`, `r ref("TuningInstanceMultiCrit")` to describe the tuning problem and store the results, and
* `r ref("Tuner")` as the base class for implementations of tuning algorithms.

## The `TuningInstance*` Classes {#tuning-optimization}

We will examine the optimization of a simple classification tree on the `r ref("mlr_tasks_pima", text = "Pima Indian Diabetes")` data set as an introductory example here.

```{r 04-optimization-003}
library("mlr3verse")
task = tsk("pima")
print(task)
```

We use the `r mlr3book::cran_pkg("rpart")` classification tree and choose a subset of the hyperparameters we want to tune.
This is often referred to as the "tuning space".
First, let's look at all the hyperparameters that are available.
Information on what they do can be found in `r ref("rpart::rpart.control", text = "the documentation of the learner")`.

```{r 04-optimization-004}
learner = lrn("classif.rpart")
learner$param_set
```

Here, we opt to tune two hyperparameters:

* The complexity hyperparameter `cp` that controls when the learner considers introducing another branch.
* The `minsplit` hyperparameter that controls how many observations must be present in a leaf for another split to be attempted.

The tuning space needs to be bounded with lower and upper bounds for the values of the hyperparameters:

```{r 04-optimization-005}
search_space = ps(
  cp = p_dbl(lower = 0.001, upper = 0.1),
  minsplit = p_int(lower = 1, upper = 10)
)
search_space
```

The bounds are usually set based on experience.

Next, we need to specify how to evaluate the performance of a trained model.
For this, we need to choose a `r ref("Resampling", text = "resampling strategy")` and a `r ref("Measure", text = "performance measure")`.

```{r 04-optimization-006}
hout = rsmp("holdout")
measure = msr("classif.ce")
```

Finally, we have to specify the budget available for tuning.
This is a crucial step, as exhaustively evaluating all possible hyperparameter configurations is usually not feasible.
`r mlr3book::mlr_pkg("mlr3")` allows to specify complex termination criteria by selecting one of the available `r ref("Terminator", text = "Terminators")`:

* Terminate after a given time (`r ref("TerminatorClockTime")`).
* Terminate after a given number of iterations (`r ref("TerminatorEvals")`).
* Terminate after a specific performance has been reached (`r ref("TerminatorPerfReached")`).
* Terminate when tuning does find a better configuration for a given number of iterations (`r ref("TerminatorStagnation")`).
* A combination of the above in an *ALL* or *ANY* fashion (`r ref("TerminatorCombo")`).

For this short introduction, we specify a budget of 20 iterations and then put everything together into a `r ref("TuningInstanceSingleCrit")`:

```{r 04-optimization-007}
library("mlr3tuning")

evals20 = trm("evals", n_evals = 20)

instance = TuningInstanceSingleCrit$new(
  task = task,
  learner = learner,
  resampling = hout,
  measure = measure,
  search_space = search_space,
  terminator = evals20
)
instance
```

To start the tuning, we still need to select how the optimization should take place.
In other words, we need to choose the **optimization algorithm** via the `r ref("Tuner")` class.

## The `Tuner` Class {#tuning-algorithms}

The following algorithms are currently implemented in `r mlr3book::mlr_pkg("mlr3tuning")`:

* Grid Search (`r ref("TunerGridSearch")`)
* Random Search (`r ref("TunerRandomSearch")`) [@bergstra2012]
* Generalized Simulated Annealing (`r ref("TunerGenSA")`)
* Non-Linear Optimization (`r ref("TunerNLoptr")`)

If you're interested in learning more about these approaches, the [Wikipedia page on hyperparameter optimization](https://en.wikipedia.org/wiki/Hyperparameter_optimization) is a good place to start.

In this example, we will use a simple grid search with a grid resolution of 5.

```{r 04-optimization-008}
tuner = tnr("grid_search", resolution = 5)
```

As we have only numeric parameters, `r ref("TunerGridSearch")` will create an equidistant grid between the respective upper and lower bounds.
Our two-dimensional grid of resolution 5 consists of $5^2 = 25$ configurations.
Each configuration is a distinct setting of hyperparameter values for the previously defined `r ref("Learner")` which is then fitted to the task and evaluated using the provided `r ref("Resampling")`.
All configurations will be examined by the tuner (in a random order), until either all configurations are evaluated or the `r ref("Terminator")` signals that the budget is exhausted, i.e. here the tuner will stop after evaluating 20 of the 25 total configurations.

## Triggering the Tuning {#tuning-triggering}

To start the tuning, we simply pass the `r ref("TuningInstanceSingleCrit")` to the `$optimize()` method of the initialized `r ref("Tuner")`.
The tuner proceeds as follows:

1. The `r ref("Tuner")` proposes at least one hyperparameter configuration to evaluate (the `r ref("Tuner")` may propose multiple points to be able to evaluate them in parallel, which can be controlled via the setting `batch_size`).
1. For each configuration, the given `r ref("Learner")` is fitted on the `r ref("Task")` and evaluated using the provided `r ref("Resampling")`.
1  All evaluations are stored in the archive of the `r ref("TuningInstanceSingleCrit")`.
1. The `r ref("Terminator")` is queried if the budget is exhausted.
1  If the budget is not exhausted, go back to 1), else terminate.
1. Determine the configurations with the best observed performance from the archive.
1. Store the best configurations as result in the tuning instance object.
   The best hyperparameter settings (`$result_learner_param_vals`) and the corresponding measured performance (`$result_y`) can be retrieved from the tuning instance.

```{r 04-optimization-009}
tuner$optimize(instance)
instance$result_learner_param_vals
instance$result_y
```

You can investigate all of the evaluations that were performed; they are stored in the archive of the `r ref("TuningInstanceSingleCrit")` and can be accessed by using `r ref("as.data.table()")`:

```{r 04-optimization-010}
as.data.table(instance$archive)
```

Altogether, the grid search evaluated 20/25 different hyperparameter configurations in a random order before the `r ref("Terminator")` stopped the tuning.
In this example there were multiple configurations with the same best classification error, and without other criteria, the first one was returned.
You may want to choose the configuration with the lowest classification error as well as time to train the model or some other combination of criteria for hyper parameter selection.
You can do this with r ref(`"TuningInstanceMultiCrit")`, see [Tuning with Multiple Performance Measures](#mult-measures-tuning).

The associated resampling iterations can be accessed in the `"BenchmarkResult")` of the tuning instance:

```{r 04-optimization-011}
instance$archive$benchmark_result
```

The `uhash` column links the resampling iterations to the evaluated configurations stored in `instance$archive$data`.
This allows e.g. to score the included `r ref("ResampleResult")`s on a different performance measure.

```{r 04-optimization-012}
instance$archive$benchmark_result$score(msr("classif.acc"))
```

Now we can take the optimized hyperparameters, set them for the previously-created `r ref("Learner")`, and train it on the full dataset.

```{r 04-optimization-013}
learner$param_set$values = instance$result_learner_param_vals
learner$train(task)
```

The trained model can now be used to make a prediction on new, external data.
Note that predicting on observations present in the `r ref("Task")` should be avoided because the model has seen these observations already during tuning and training and therefore performance values would be statistically biased -- the resulting performance measure would be over-optimistic.
To get statistically unbiased performance estimates for a given task, [nested resampling](#nested-resampling) is required.

## Tuning with Multiple Performance Measures {#mult-measures-tuning}

When tuning, you might want to use multiple criteria to find the best configuration of hyperparameters.
For example, you might want the configuration with the lowest classification error and lowest time to train the model.
The full list of performance measures can be found [here](https://mlr3.mlr-org.com/reference/mlr_measures.html).

Continuing the above example and tuning the same hyperparameters:

* The complexity hyperparameter `cp` that controls when the learner considers introducing another branch.
* The `minsplit` hyperparameter that controls how many observations must be present in a leaf for another split to be attempted.

The tuning process is identical to the previous example, however, this time we will specify two `r ref("Measure", text = "performance measures")`, classification error and time to train the model (`time_train`).

```{r 04-optimization-014}
measures = msrs(c("classif.ce", "time_train"))
```

Instead of creating a new `r ref("TuningInstanceSingleCrit")` with a single measure, we create a new `r ref("TuningInstanceMultiCrit")` with the two measures we are interested in here.
Otherwise, it is the same as above.

```{r 04-optimization-015}
library("mlr3tuning")

evals20 = trm("evals", n_evals = 20)

instance = TuningInstanceMultiCrit$new(
  task = task,
  learner = learner,
  resampling = hout,
  measures = measures,
  search_space = search_space,
  terminator = evals20
)
instance
```

After triggering the tuning, we will have the configuration with the best classification error and time to train the model.

```{r 04-optimization-016}
tuner$optimize(instance)
instance$result_learner_param_vals
instance$result_y
```

## Automating the Tuning {#autotuner}

We can automate this entire process in `r mlr3book::mlr_pkg("mlr3")` so that learners are tuned transparently, without the need to extract information on the best hyperparameter settings at the end.
The `r ref("AutoTuner")` wraps a learner and augments it with an automatic tuning process for a given set of hyperparameters.
Because the `r ref("AutoTuner")` itself inherits from the `r ref("Learner")` base class, it can be used like any other learner.
In keeping with our example above, we create a classification learner that tunes itself automatically.
This classification tree learner tunes the parameters `cp` and `minsplit` using an inner resampling (holdout).
We create a terminator which allows 10 evaluations, and use a simple random search as tuning algorithm:

```{r 04-optimization-017}
learner = lrn("classif.rpart")
search_space = ps(
  cp = p_dbl(lower = 0.001, upper = 0.1),
  minsplit = p_int(lower = 1, upper = 10)
)
terminator = trm("evals", n_evals = 10)
tuner = tnr("random_search")

at = AutoTuner$new(
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
  search_space = search_space,
  terminator = terminator,
  tuner = tuner
)
at
```

We can now use the learner like any other learner, calling the `$train()` and `$predict()` method. The differnce to a normal learner is that `$train()` runs the tuning, which will take longer than a normal training process.

```{r 04-optimization-018}
at$train(task)
```

We can also pass it to `r ref("resample()")` and `r ref("benchmark()")`, just like any other learner.
This would result in a [nested resampling](#nested-resampling).
