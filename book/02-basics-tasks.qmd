# Tasks {#tasks}

```{r 02-basics-tasks-001, include = F}
library(mlr3)
library(mlr3book)
```

Tasks are objects that contain the (usually tabular) data and additional meta-data to define a machine learning problem.
The meta-data is, for example, the name of the target variable for supervised machine learning problems, or the type of the dataset (e.g. a _spatial_ or _survival_ task).
This information is used by specific operations that can be performed on a task.

## Task Types {#tasks-types}

To create a task from a `r ref("data.frame()")`, `r ref("data.table()")` or `r ref("Matrix::Matrix()", text = "Matrix()")`, you first need to select the right task type:

* **Classification Task**: The target is a label (stored as `character` or `factor`) with only relatively few distinct values → `r ref("TaskClassif")`.

* **Regression Task**: The target is a numeric quantity (stored as `integer` or `numeric`) → `r ref("TaskRegr")`.

* **Survival Task**: The target is the (right-censored) time to an event. More censoring types are currently in development → `r ref("mlr3proba::TaskSurv")` in add-on package `r mlr_pkg("mlr3proba")`.

* **Density Task**: An unsupervised task to estimate the density → `r ref("mlr3proba::TaskDens")` in add-on package `r mlr_pkg("mlr3proba")`.

* **Cluster Task**: An unsupervised task type; there is no target and the aim is to identify similar groups within the feature space → `r ref("mlr3cluster::TaskClust")` in add-on package `r mlr_pkg("mlr3cluster")`.

* **Spatial Task**: Observations in the task have spatio-temporal information (e.g. coordinates) → `r ref("mlr3spatiotempcv::TaskRegrST")` or `r ref("mlr3spatiotempcv::TaskClassifST")` in add-on package `r mlr_pkg("mlr3spatiotempcv")`.

* **Ordinal Regression Task**: The target is ordinal → `TaskOrdinal` in add-on package `r gh_pkg("mlr-org/mlr3ordinal")` (still in development).

## Task Creation {#tasks-creation}

As an example, we will create a regression task using the `r ref("datasets::mtcars", text = "mtcars")` data set from package `datasets`.
It contains characteristics for different types of cars, along with their fuel consumption.
We predict the numeric target variable `"mpg"` (miles per gallon).
We only consider the first two features in the dataset for brevity.

First, we load and prepare the data and then print its structure to get a better idea of what it looks like.

```{r 02-basics-tasks-002}
data("mtcars", package = "datasets")
data = mtcars[, 1:3]
str(data)
```

Next, we create a regression task, i.e. we construct a new instance of the R6 class `r ref("TaskRegr")`.
Formally, the intended way to initialize an R6 object is to call the constructor `TaskRegr$new()`.
Here instead, we are calling the converter `r ref("as_task_regr()")` to convert our `data.frame()` stored in the object `data` to a task and provide the following information:

1. `x`: Object to convert.
  Works for rectangular data formats such as `data.frame()`, `data.table()`, or `tibble()`.
  Internally, the data is converted and stored in an abstract `r ref("DataBackend")`.
  This allows connecting to out-of-memory storage systems like SQL servers via the extension package `r mlr_pkg("mlr3db")`.
1. `target`: The name of the prediction target column for the regression problem, here miles per gallon (`"mpg"`).
1. `id` (optional): An arbitrary identifier for the task, used in plots and summaries.
   If not provided, the deparsed name of `x` will be used.

```{r 02-basics-tasks-003}
library("mlr3")

task_mtcars = as_task_regr(data, target = "mpg", id = "cars")
print(task_mtcars)
```

The `print()` method gives a short summary of the task:
It has `r task_mtcars$nrow` observations and `r task_mtcars$ncol` columns, of which `r length(task_mtcars$feature_names)` are features stored in double-precision floating point format.

We can also plot the task using the `r mlr_pkg("mlr3viz")` package, which gives a graphical summary of its properties:

```{r 02-basics-tasks-004, message=FALSE}
library("mlr3viz")
autoplot(task_mtcars, type = "pairs")
```

:::{.callout-tip}
Instead of loading all the extension packages individually, it is often more convenient to load the `r mlr_pkg("mlr3verse")` package instead.
`mlr3verse` imports the Namespace of most `r mlr3book::mlr_pkg("mlr3")` packages and re-exports functions which are used for common machine learning and data science tasks.
:::

## Predefined tasks {#tasks-predefined}

`r mlr_pkg("mlr3")` includes a few predefined machine learning tasks.
All tasks are stored in an R6 `r ref("Dictionary")` (a key-value store) named `r ref("mlr_tasks")`.
Printing it gives the keys (the names of the datasets):

```{r 02-basics-tasks-005}
mlr_tasks
```

We can get a more informative summary of the example tasks by converting the dictionary to a `r ref("data.table()")` object:

```{r 02-basics-tasks-006}
as.data.table(mlr_tasks)
```

Above, the columns `"lgl"` (`r ref("logical")`), `"int"` (`r ref("integer")`), `"dbl"` (`r ref("double")`), `"chr"` (`r ref("character")`), `"fct"` (`r ref("factor")`), `"ord"` (`r ref("ordered", text = "ordered factor")`) and `"pxc"` (`r ref("POSIXct")` time) show the number of features in the task of the respective type.

To get a task from the dictionary, use the `$get()` method from the `mlr_tasks` class and assign the return value to a new variable
As getting a task from a dictionary is a very common problem, `r mlr3book::mlr_pkg("mlr3")` provides the shortcut function `r ref("tsk()")`.
Here, we retrieve the `r ref("mlr_tasks_penguins", text = "palmer penguins classification task")`, which is provided by the package `r cran_pkg("palmerpenguins")`:

```{r 02-basics-tasks-007}
task_penguins = tsk("penguins")
print(task_penguins)
```

:::{.callout-note}
The loading extension of packages can add to dictionaries such as `r ref("mlr_tasks")`.
For example, `r mlr_pkg("mlr3data")` adds some more example and toy tasks for regression and classification, and `r mlr_pkg("mlr3proba")` adds survival and density estimation tasks.
:::

To get more information about a particular task, it is easiest to use the `help()` method that all `r mlr3book::mlr_pkg("mlr3")`-objects come with:
```{r 02-basics-tasks-010, eval = FALSE}
task_penguins$help()
```
Alternatively, the corresponding man page can be found under `mlr_tasks_[id]`, e.g. `r ref("mlr_tasks_penguins")`:
```{r 02-basics-tasks-009, eval = FALSE}
help("mlr_tasks_penguins")
```

## Task API {#tasks-api}

All properties and characteristics of tasks can be queried using the task's public fields and methods (see `r ref("Task")`).
Methods can also be used to change the stored data and the behavior of the task.

### Retrieving Data {#tasks-retrieving}

The `r ref("Task")` object primarily represents a tabular dataset, combined with meta-data about which columns of that data should be used to predict which other columns in what way, as well as some more information about column data types.

Various fields can be used to retrieve meta-data about a task. The dimensions can, for example, be retrieved using `$nrow` and `$ncol`:
```{r 02-basics-tasks-011}
task_mtcars$nrow
task_mtcars$ncol
```

The names of the feature and target columns are stored in the `$feature_names` and `$target_names` slots, respectively. Here, "target" refers to the variable we want to predict and "feature" to the predictors for the task.
```{r 02-basics-tasks-014}
task_mtcars$feature_names
task_mtcars$target_names
```

For the most common tasks, regression and classification, the target will only be a single name. Tasks with other task types, such as for survival estimation, may have more than one target column:
```{r 02-basics-tasks-014-1}
library("mlr3proba")
tsk("unemployment")$target_names
```

While the columns of a task have unique `character`-valued names, their rows are identified by unique natural numbers, their row-IDs. They can be accessed through the `$row_ids` slot:
```{r 02-basics-tasks-013}
head(task_mtcars$row_ids)
```
:::{.callout-warning}
Although the row IDs are typically just the sequence from `1` to `nrow(data)`, they are only guaranteed to be unique natural numbers. It is possible that they do not start at `1`, that they are not increasing by 1 each, or that they are not even in increasing order.
Keep that in mind, especially if you work with data stored in a real database management system (see [backends](#backends)).
:::

The data contained in a task can be accessed through `$data()`, which returns a `data.table` object. It has optional `rows` and `cols` arguments to specify subsets of the data to retrieve. When a database backend is used, then this avoids loading unnecessary data into memory, making it more efficient than retrieving the entire data first and then subsetting it using `[<rows>, <cols>]`.
```{r 02-basics-tasks-012}
task_mtcars$data()
# retrieve data for rows 1, 5, and 10 and select column "mpg"
task_mtcars$data(rows = c(1, 5, 10), cols = "mpg")
```

To extract the complete data from the task, one can also convert it to a `data.table`:
```{r 02-basics-tasks-016}
# show summary of entire data
summary(as.data.table(task_mtcars))
```

### Task Mutators {#tasks-mutators}

It is often necessary to create tasks that encompass subsets of other tasks' data, for example to manually create [train-test-splits](#train-test-splits), or to fit models on a subset of given features. Restricting tasks to a given set of features can be done by calling `$select()` with the desired feature names. Restriction to rows is done with `$filter()` with the row-IDs.

```{r 02-basics-tasks-021}
task_penguins_small = tsk("penguins")
task_penguins_small$select(c("body_mass", "flipper_length")) # keep only these features
task_penguins_small$filter(2:4) # keep only these rows
task_penguins_small$data()
```

These methods are so-called *mutators*, they modify the given `Task` in-place. If you want to have an unmodified version of the task, you need to use the `$clone()` method to create a copy first.

```{r 02-basics-tasks-021-2}
task_penguins_smaller = task_penguins_small$clone()
task_penguins_smaller$filter(2)
task_penguins_smaller$data()
task_penguins_small$data()  # this task is unmodified
```

Note also how the last call to `$filter(2)` did not select the second row of the `task_penguins_small`, but selected the row with ID 2, which is the *first* row of `task_penguins_small`.

While the methods above allow us to subset the data, the methods `$rbind()` and `$cbind()` allow adding extra rows and columns to a task.

```{r 02-basics-tasks-022}
task_penguins_smaller$rbind(  # add another row
  data.frame(body_mass = 1e9, flipper_length = 1e9, species = "GigaPeng")
)
task_penguins_smaller$cbind(data.frame(letters = letters[2:3])) # add column letters
task_penguins_smaller$data()
```

### Roles (Rows and Columns) {#tasks-roles}

We have seen that certain columns are designated as "targets" and "features" during task creation, their "roles":
Target refers to the variable(s) we want to predict and features are the predictors (also called co-variates) for the target.
Besides these two, there are other possible roles for columns, see the documentation of `r ref("Task")`. These roles affect the behavior of the task for different operations.

The previously-constructed `task_penguins_small` task, for example, has the following column roles:

```{r 02-basics-tasks-018}
task_penguins_small$col_roles
```

Columns can have have multiple roles. It is also possible for a column to have no role at all, in which case they are ignored. This is, in fact, how `$select()` and `$filter()` operate: They unassign the `"feature"` (for columns) or `"use"` (for rows) role, the underlying data is still present in the data:

```{r 02-basics-tasks-018-2}
task_penguins_small$backend
```

There are two main ways to manipulate the col roles of a `Task`:

1. Use the `r ref("Task")` method `$set_col_roles()` (recommended).
1. Simply modify the field `$col_roles`, which is a named list of vectors of column names.
   Each vector in this list corresponds to a column role, and the column names contained in that vector have that role.

Just as `$select()`/`$filter()`, these are in-place operations, so the task object itself is modified. To retain another unmodified version of a task, use `$clone()`.

Changing the column or row roles, whether by `$select()`/`$filter()` or directly, does not change the underlying data, it just updates the view on it.
Because the underlying data is still there (and accessible through `$backend`), we can add the `"bill_length"` column back into the task by setting its col role to `"feature"`.
```{r 02-basics-tasks-018-3}
task_penguins_small$set_col_roles("bill_length", roles = "feature")
task_penguins_small$feature_names  # bill_length is now a feature again
task_penguins_small$data()
```

Supported column roles can be found in the manual of `r ref("Task")`, or just by printing the names of the field `$col_roles`:

```{r 02-basics-tasks-020}
# supported column roles, see ?Task
names(task_penguins_small$col_roles)
```

Just like columns, it is also possible to assign different roles to rows. Rows can have two different roles:

1. Role `use`:
  Rows that are generally available for model fitting (although they may also be used as test set in resampling).
  This role is the default role. The `$filter()` call changes this role, in the same way that `$select()` changes the `"feature"` role.
1. Role `validation`:
  Rows that are not used for training.
  Rows that have missing values in the target column during task creation are automatically set to the validation role.

There are several reasons to hold some observations back or treat them differently:

1. It is often good practice to validate the final model on an external validation set to identify possible overfitting.
1. Some observations may be unlabeled, e.g. in competitions like [Kaggle](https://www.kaggle.com/).

These observations cannot be used for training a model, but can be used to get predictions.

### Binary classification {#binary-classification}

Classification problems with a target variable with only two classes are called binary classification tasks.
They are special in the sense that one of these classes is denoted *positive* and the other one *negative*.
You can specify the *positive class* within the `r ref("TaskClassif", text = "classification task")` object during task creation.
If not explicitly set during construction, the positive class defaults to the first level of the target variable.

```{r 02-basics-tasks-017}
# during construction
data("Sonar", package = "mlbench")
task = as_task_classif(Sonar, target = "Class", positive = "R")

# switch positive class to level 'M'
task$positive = "M"
```

## Plotting Tasks {#autoplot-task}

The `r mlr_pkg("mlr3viz")` package provides plotting facilities for many classes implemented in `r mlr_pkg("mlr3")`.
The available plot types depend on the class, but all plots are returned as `r cran_pkg("ggplot2")` objects which can be easily customized.

For classification tasks (inheriting from `r ref("TaskClassif")`), see the documentation of `r ref("mlr3viz::autoplot.TaskClassif")` for the implemented plot types.
Here are some examples to get an impression:

```{r 02-basics-tasks-023, warning = FALSE, message = FALSE}
library("mlr3viz")

# get the pima indians task
task = tsk("pima")

# subset task to only use the 3 first features
task$select(head(task$feature_names, 3))

# default plot: class frequencies
autoplot(task)

# pairs plot (requires package GGally)
autoplot(task, type = "pairs")

# duo plot (requires package GGally)
autoplot(task, type = "duo")
```

Of course, you can do the same for regression tasks (inheriting from `r ref("TaskRegr")`) as documented in `r ref("mlr3viz::autoplot.TaskRegr")`:

```{r 02-basics-tasks-024, warning = FALSE, message = FALSE}
library("mlr3viz")

# get the complete mtcars task
task = tsk("mtcars")

# subset task to only use the 3 first features
task$select(head(task$feature_names, 3))

# default plot: boxplot of target variable
autoplot(task)

# pairs plot (requires package GGally)
autoplot(task, type = "pairs")
```
