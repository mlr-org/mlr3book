<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.272">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Applied Machine Learning Using mlr3 in R - 6&nbsp; Feature Selection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter7/sequential_pipelines.html" rel="next">
<link href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" rel="prev">
<link href="../../Figures/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script><style>html{ scroll-behavior: smooth; }</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body class="nav-sidebar floating slimcontent">


<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html">Tuning and Feature Selection</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter6/feature_selection.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Applied Machine Learning Using mlr3 in R</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mlr-org/mlr3book/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../Applied-Machine-Learning-Using-mlr3-in-R.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/introduction_and_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction and Overview</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false">
 <span class="menu-text">Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/data_and_basic_modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data and Basic Modeling</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Tuning and Feature Selection</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter4/hyperparameter_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter6/feature_selection.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Pipelines and Preprocessing</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter7/sequential_pipelines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter9/preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Preprocessing</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Advanced Topics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter10/advanced_technical_aspects_of_mlr3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Advanced Technical Aspects of mlr3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter11/large-scale_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Large-Scale Benchmarking</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter12/model_interpretation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Model Interpretation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter13/beyond_regression_and_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Beyond Regression and Classification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter14/algorithmic_fairness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Algorithmic Fairness</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/citation_information.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Citation Information</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/session_info.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Session Info</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/solutions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Solutions to exercises</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/tasks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Tasks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/overview-tables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Overview Tables</span></span></a>
  </div>
</li>
          <li class="px-0"><hr class="sidebar-divider hi "></li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Table of contents</h2>
   
  <ul>
<li>
<a href="#sec-fs-filter" id="toc-sec-fs-filter" class="nav-link active" data-scroll-target="#sec-fs-filter"><span class="header-section-number">6.1</span> Filters</a>
  <ul class="collapse">
<li><a href="#sec-fs-calc" id="toc-sec-fs-calc" class="nav-link" data-scroll-target="#sec-fs-calc"><span class="header-section-number">6.1.1</span> Calculating Filter Values</a></li>
  <li><a href="#sec-fs-var-imp-filters" id="toc-sec-fs-var-imp-filters" class="nav-link" data-scroll-target="#sec-fs-var-imp-filters"><span class="header-section-number">6.1.2</span> Feature Importance Filters</a></li>
  <li><a href="#sec-fs-embedded-methods" id="toc-sec-fs-embedded-methods" class="nav-link" data-scroll-target="#sec-fs-embedded-methods"><span class="header-section-number">6.1.3</span> Embedded Methods</a></li>
  <li><a href="#sec-fs-filter-based" id="toc-sec-fs-filter-based" class="nav-link" data-scroll-target="#sec-fs-filter-based"><span class="header-section-number">6.1.4</span> Filter-based Feature Selection</a></li>
  </ul>
</li>
  <li>
<a href="#sec-fs-wrapper" id="toc-sec-fs-wrapper" class="nav-link" data-scroll-target="#sec-fs-wrapper"><span class="header-section-number">6.2</span> Wrapper Methods</a>
  <ul class="collapse">
<li><a href="#sec-fs-wrapper-example" id="toc-sec-fs-wrapper-example" class="nav-link" data-scroll-target="#sec-fs-wrapper-example"><span class="header-section-number">6.2.1</span> Simple Forward Selection Example</a></li>
  <li><a href="#the-fselectinstance-classes" id="toc-the-fselectinstance-classes" class="nav-link" data-scroll-target="#the-fselectinstance-classes"><span class="header-section-number">6.2.2</span> The <code>FSelectInstance</code> Classes</a></li>
  <li><a href="#the-fselector-class" id="toc-the-fselector-class" class="nav-link" data-scroll-target="#the-fselector-class"><span class="header-section-number">6.2.3</span> The <code>FSelector</code> Class</a></li>
  <li><a href="#starting-the-feature-selection" id="toc-starting-the-feature-selection" class="nav-link" data-scroll-target="#starting-the-feature-selection"><span class="header-section-number">6.2.4</span> Starting the Feature Selection</a></li>
  <li><a href="#sec-multicrit-featsel" id="toc-sec-multicrit-featsel" class="nav-link" data-scroll-target="#sec-multicrit-featsel"><span class="header-section-number">6.2.5</span> Optimizing Multiple Performance Measures</a></li>
  <li><a href="#sec-autofselect" id="toc-sec-autofselect" class="nav-link" data-scroll-target="#sec-autofselect"><span class="header-section-number">6.2.6</span> Automating the Feature Selection and Nested Resampling</a></li>
  </ul>
</li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">6.3</span> Conclusion</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">6.4</span> Exercises</a></li>
  <li><a href="#citation" id="toc-citation" class="nav-link" data-scroll-target="#citation"><span class="header-section-number">6.5</span> Citation</a></li>
  </ul><div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter6/feature_selection.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action">Report an issue</a></p><p><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter6/feature_selection.qmd" class="toc-action">View source</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-feature-selection" class="quarto-section-identifier"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header><p><strong>Marvin N. Wright</strong> <br><em>Leibniz Institute for Prevention Research and Epidemiology – BIPS, and University of Bremen, and University of Copenhagen</em> <br><br></p>
<p>Feature selection, also known as variable or descriptor selection, is the process of finding a subset of features to use with a given task and learner. Using an <em>optimal set</em> of features can have several benefits:</p>
<ul>
<li>improved predictive performance, since we reduce overfitting on irrelevant features,</li>
<li>robust models that do not rely on noisy features,</li>
<li>simpler models that are easier to interpret,</li>
<li>faster model fitting, e.g.&nbsp;for model updates,</li>
<li>faster prediction, and</li>
<li>no need to collect potentially expensive features.</li>
</ul>
<p>However, these objectives will not necessarily be optimized by the same <em>optimal set</em> of features and thus feature selection can be seen as a multi-objective optimization problem. In this chapter, we mostly focus on feature selection as a means of improving predictive performance, but also briefly cover optimization of multiple criteria (<a href="#sec-multicrit-featsel"><span class="quarto-unresolved-ref">sec-multicrit-featsel</span></a>).</p>
<p>Reducing the amount of features can improve models across many scenarios, but it can be especially helpful in datasets that have a high number of features in comparison to the number of datapoints. Many learners perform implicit, also called embedded, feature selection, e.g.&nbsp;via the choice of variables used for splitting in a decision tree. Most other feature selection methods are model agnostic, i.e.&nbsp;they can be used together with any learner. Of the many different approaches to identifying relevant features, we will focus on two general concepts, which are described in detail below: Filter and Wrapper methods <span class="citation" data-cites="guyon2003 chandrashekar2014">(<a href="#ref-guyon2003" role="doc-biblioref">Guyon and Elisseeff 2003</a>; <a href="#ref-chandrashekar2014" role="doc-biblioref">Chandrashekar and Sahin 2014</a>)</span>.</p>
<p>For this chapter, the reader should know the basic concepts of <code>mlr3</code> (<a href="#sec-basics"><span class="quarto-unresolved-ref">sec-basics</span></a>), i.e.&nbsp;know about tasks (<a href="#sec-tasks"><span class="quarto-unresolved-ref">sec-tasks</span></a>) and learners (<a href="#sec-learners"><span class="quarto-unresolved-ref">sec-learners</span></a>). Basics about performance evaluation (<a href="#sec-performance"><span class="quarto-unresolved-ref">sec-performance</span></a>), i.e.&nbsp;resampling (<a href="#sec-resampling"><span class="quarto-unresolved-ref">sec-resampling</span></a>) and benchmarking (<a href="#sec-benchmarking"><span class="quarto-unresolved-ref">sec-benchmarking</span></a>) are helpful but not strictly necessary.</p>
<section id="sec-fs-filter" class="level2 page-columns page-full" data-number="6.1"><h2 data-number="6.1" class="anchored" data-anchor-id="sec-fs-filter">
<span class="header-section-number">6.1</span> Filters</h2>
<p>Filter methods are preprocessing steps that can be applied before training a model. A very simple filter approach could look like this:</p>
<ol type="1">
<li>calculate the correlation coefficient <span class="math inline">\(\rho\)</span> between each feature and a numeric target variable, and</li>
<li>select all features with <span class="math inline">\(\rho &gt; 0.2\)</span> for further modeling steps.</li>
</ol>
<p>This approach is a <em>univariate</em> filter because it only considers the univariate relationship between each feature and the target variable. Further, it can only be applied to regression tasks with continuous features and the threshold of <span class="math inline">\(\rho &gt; 0.2\)</span> is quite arbitrary. Thus, more advanced filter methods, e.g.&nbsp;<em>multivariate</em> filters based on feature importance, usually perform better <span class="citation" data-cites="bommert2020">(<a href="#ref-bommert2020" role="doc-biblioref">Bommert et al. 2020</a>)</span>. On the other hand, a benefit of univariate filters is that they are usually computationally cheaper than more complex filter or wrapper methods. In the following, it is described how to calculate univariate, multivariate and feature importance filters, how to access implicitly selected features, how to integrate filters in a machine learning pipeline and how to optimize filter thresholds.</p>
<p>Filter algorithms select features by assigning numeric scores to each feature, e.g.&nbsp;correlation between feature and target variables, use these to rank the features and select a feature subset based on the ranking. Features that are assigned lower scores can then be omitted in subsequent modeling steps. All filters are implemented via the package <a href="https://mlr3filters.mlr-org.com"><code>mlr3filters</code></a>. Below, we cover how to</p>
<ul>
<li>instantiate a <code>Filter</code> object,</li>
<li>calculate scores for a given task, and</li>
<li>use calculated scores to select or drop features.</li>
</ul>
<p>Special cases of filters are feature importance filters (<a href="#sec-fs-var-imp-filters"><span class="quarto-unresolved-ref">sec-fs-var-imp-filters</span></a>) and embedded methods (<a href="#sec-fs-embedded-methods"><span class="quarto-unresolved-ref">sec-fs-embedded-methods</span></a>). Feature importance filters select features that are important according to the model induced by a selected <code>Learner</code>. They rely on the learner to extract information on feature importance from a trained model, for example, by inspecting a learned decision tree and returning the features that are used as split variables, or by computing model-agnostic feature importance (<a href="#sec-interpretation"><span class="quarto-unresolved-ref">sec-interpretation</span></a>) values for each feature. Embedded methods use the feature selection that is implicitly done by some learners and directly retrieve the internally selected features from the learner.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The learner used in a feature importance or embedded filter is independent of learners used in subsequent modeling steps. For example, one might use feature importance of a random forest for feature selection and train a neural network on the reduced feature set.</p>
</div>
</div>
<p>Many filter methods are implemented in <a href="https://mlr3filters.mlr-org.com"><code>mlr3filters</code></a>, for example:</p>
<ul>
<li>Correlation, calculating Pearson or Spearman correlation between numeric features and numeric targets (<a href="https://mlr3filters.mlr-org.com/reference/mlr_filters_correlation.html" class="refcode"><code>FilterCorrelation</code></a>)</li>
<li>Information gain, i.e.&nbsp;mutual information of the feature and the target or the reduction of uncertainty of the target due to a feature (<a href="https://mlr3filters.mlr-org.com/reference/mlr_filters_information_gain.html" class="refcode"><code>FilterInformationGain</code></a>)</li>
<li>Minimal joint mutual information maximization, minimizing the joint information between selected features to avoid redundancy (<a href="https://mlr3filters.mlr-org.com/reference/mlr_filters_jmim.html" class="refcode"><code>FilterJMIM</code></a>)</li>
<li>Permutation score, which calculates permutation feature importance (see <a href="#sec-interpretation"><span class="quarto-unresolved-ref">sec-interpretation</span></a>) with a given learner for each feature (<a href="https://mlr3filters.mlr-org.com/reference/mlr_filters_permutation.html" class="refcode"><code>FilterPermutation</code></a>)</li>
<li>Area under the ROC curve calculated for each feature separately (<a href="https://mlr3filters.mlr-org.com/reference/mlr_filters_auc.html" class="refcode"><code>FilterAUC</code></a>)</li>
</ul>
<div class="page-columns page-full"><p>Most of the filter methods have some limitations, e.g.&nbsp;the correlation filter can only be calculated for regression tasks with numeric features. For a full list of all implemented filter methods we refer the reader to the <a href="https://mlr3filters.mlr-org.com">mlr3filters website</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, which also shows the supported task and features types. A benchmark of filter methods was performed by <span class="citation" data-cites="bommert2020">Bommert et al. (<a href="#ref-bommert2020" role="doc-biblioref">2020</a>)</span>, who recommend to not rely on a single filter method but try several ones if the available computational resources allow. If only a single filter method is to be used, the authors recommend to use a feature importance filter using random forest permutation importance (see <a href="#sec-fs-var-imp-filters"><span class="quarto-unresolved-ref">sec-fs-var-imp-filters</span></a>), similar to the permutation method described above, but also the JMIM and AUC filters performed well in their comparison.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;<a href="https://mlr3filters.mlr-org.com">https://mlr3filters.mlr-org.com</a></p></li></div></div>
<section id="sec-fs-calc" class="level3" data-number="6.1.1"><h3 data-number="6.1.1" class="anchored" data-anchor-id="sec-fs-calc">
<span class="header-section-number">6.1.1</span> Calculating Filter Values</h3>
<p>The first step is to create a new R object using the class of the desired filter method. Similar to other instances in <a href="https://mlr3.mlr-org.com"><code>mlr3</code></a>, these are registered in a dictionary (<a href="https://mlr3filters.mlr-org.com/reference/mlr_filters.html" class="refcode"><code>mlr_filters</code></a>) with an associated shortcut function <a href="https://mlr3filters.mlr-org.com/reference/flt.html" class="refcode"><code>flt()</code></a>. Each object of class <code>Filter</code> has a <code>$calculate()</code> method which computes the filter values and ranks them in a descending order. For example, we can use the information gain filter described above:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-001_e9e2ac33681e510005da7befb3b6ce11">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://mlr3verse.mlr-org.com">"mlr3verse"</a></span><span class="op">)</span></span>
<span><span class="va">filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Such a <code>Filter</code> object can now be used to calculate the filter on the penguins data and get the results:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-002_c3f7fca26e564a29783279cb79cd5ab9">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">filter</span><span class="op">$</span><span class="fu">calculate</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">filter</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          feature    score
1: flipper_length 0.581168
2:    bill_length 0.544897
3:     bill_depth 0.538719
4:         island 0.520157
5:      body_mass 0.442880
6:            sex 0.007244
7:           year 0.000000</code></pre>
</div>
</div>
<p>Some filters have hyperparameters, which can be changed similar to setting hyperparameters of a <a href="https://mlr3.mlr-org.com/reference/Learner.html" class="refcode"><code>Learner</code></a> using <code>$param_set$values</code>. For example, to calculate <code>"spearman"</code> instead of <code>"pearson"</code> correlation with the correlation filter:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-003_b341e7bb78eee6f25740456851d2c301">
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">filter_cor</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"correlation"</span><span class="op">)</span></span>
<span><span class="va">filter_cor</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"spearman"</span><span class="op">)</span></span>
<span><span class="va">filter_cor</span><span class="op">$</span><span class="va">param_set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
       id    class lower upper nlevels    default    value
1:    use ParamFct    NA    NA       5 everything         
2: method ParamFct    NA    NA       3    pearson spearman</code></pre>
</div>
</div>
<p>As noted above, the correlation filter can only be calculated for regression tasks with numeric features and can thus not be used with the penguins data.</p>
</section><section id="sec-fs-var-imp-filters" class="level3 page-columns page-full" data-number="6.1.2"><h3 data-number="6.1.2" class="anchored" data-anchor-id="sec-fs-var-imp-filters">
<span class="header-section-number">6.1.2</span> Feature Importance Filters</h3>
<p>To use feature importance filters, we can use a learner with integrated feature importance methods. All learners with the property “importance” have this functionality. A list of all learners with this property can be found with</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-004_c0bcd4ec48407ef1c8ef17652d29f653">
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">mlr_learners</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">properties</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="st">"importance"</span> <span class="op"><a href="https://rdrr.io/r/base/match.html">%in%</a></span> <span class="va">x</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                         key                              label
 1:      classif.featureless Featureless Classification Learner
 2:              classif.gbm                  Gradient Boosting
 3: classif.imbalanced_rfsrc           Imbalanced Random Forest
 4:         classif.lightgbm                  Gradient Boosting
 5:     classif.randomForest                      Random Forest
---                                                            
20:                 surv.gbm                  Gradient Boosting
21:              surv.mboost Boosted Generalized Additive Model
22:              surv.ranger                      Random Forest
23:               surv.rfsrc                      Random Forest
24:             surv.xgboost                  Gradient Boosting
5 variables not shown: [task_type, feature_types, packages, properties, predict_types]</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>or on the <a href="https://mlr-org.com/learners.html">mlr3 website</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;<a href="https://mlr-org.com/learners.html">https://mlr-org.com/learners.html</a></p></li></div></div>
<p>For some learners, the desired filter method needs to be set during learner creation. For example, learner <a href="https://mlr3learners.mlr-org.com/reference/mlr_learners_classif.ranger.html" class="refcode"><code>classif.ranger</code></a> comes with multiple integrated methods, c.f. the help page of <a href="https://www.rdocumentation.org/packages/ranger/topics/ranger" class="refcode"><code>ranger::ranger()</code></a>. To use the feature importance method “impurity”, select it during learner construction:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-005_56568e47d5d39c8667cef665466f92c5">
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.ranger"</span>, importance <span class="op">=</span> <span class="st">"impurity"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We first have to remove missing data because the learner cannot handle missing data, i.e.&nbsp;it does not have the property “missing”:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-006_676ca06b82466fb13331c60c63eecb17">
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="fu">filter</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/complete.cases.html">complete.cases</a></span><span class="op">(</span><span class="va">task</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can use the <a href="https://mlr3filters.mlr-org.com/reference/mlr_filters_importance.html" class="refcode"><code>FilterImportance</code></a> filter class:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-006-2_6c58a2ea84d2f4d00f3003a12a141507">
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"importance"</span>, learner <span class="op">=</span> <span class="va">lrn</span><span class="op">)</span></span>
<span><span class="va">filter</span><span class="op">$</span><span class="fu">calculate</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">filter</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          feature  score
1:    bill_length 76.375
2: flipper_length 45.349
3:     bill_depth 36.306
4:      body_mass 26.458
5:         island 24.078
6:            sex  1.597
7:           year  1.216</code></pre>
</div>
</div>
</section><section id="sec-fs-embedded-methods" class="level3 page-columns page-full" data-number="6.1.3"><h3 data-number="6.1.3" class="anchored" data-anchor-id="sec-fs-embedded-methods">
<span class="header-section-number">6.1.3</span> Embedded Methods</h3>
<p>Many learners internally select a subset of the features which they find helpful for prediction, but ignore other features. For example, a decision tree might never select some features for splitting. These subsets can be used for feature selection, which we call embedded methods because the feature selection is embedded in the learner. The selected features (and those not selected) can be queried if the learner has the <code>"selected_features"</code> property. As above, we can find those learners with</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-007_49d7edbdd087763f38743bb3a09a898f">
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">mlr_learners</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">properties</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="st">"selected_features"</span> <span class="op"><a href="https://rdrr.io/r/base/match.html">%in%</a></span> <span class="va">x</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                       key                                         label
 1:          classif.abess Fast Best Subset Selection for Classification
 2:      classif.cv_glmnet                                          &lt;NA&gt;
 3:    classif.featureless            Featureless Classification Learner
 4: classif.priority_lasso                                Priority Lasso
 5:          classif.rpart                           Classification Tree
---                                                                     
12:          surv.gamboost            Boosted Generalized Additive Model
13:            surv.glmnet          Regularized Generalized Linear Model
14:            surv.mboost            Boosted Generalized Additive Model
15:    surv.priority_lasso                                Priority Lasso
16:             surv.rpart                                 Survival Tree
5 variables not shown: [task_type, feature_types, packages, properties, predict_types]</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>or on the <a href="https://mlr-org.com/learners.html">mlr3 website</a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. For example, we can use the <a href="https://mlr3.mlr-org.com/reference/mlr_learners_classif.rpart.html" class="refcode"><code>classif.rpart</code></a> learner.</p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;<a href="https://mlr-org.com/learners.html">https://mlr-org.com/learners.html</a></p></li></div></div>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-007-2_f2c9836d07516893a2dea8614ecb58e6">
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="fu">selected_features</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "flipper_length" "bill_length"    "island"        </code></pre>
</div>
</div>
<p>The features selected by the model can be extracted by a <code>Filter</code> object, where <code>$calculate()</code> corresponds to training the learner on the given task:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-008_d9bb4a20bf3ea010858a4022cc37a1e2">
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"selected_features"</span>, learner <span class="op">=</span> <span class="va">learner</span><span class="op">)</span></span>
<span><span class="va">filter</span><span class="op">$</span><span class="fu">calculate</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">filter</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          feature score
1:         island     1
2: flipper_length     1
3:    bill_length     1
4:     bill_depth     0
5:            sex     0
6:           year     0
7:      body_mass     0</code></pre>
</div>
</div>
<p>Contrary to other filter methods, embedded methods just return value of 1 (selected features) and 0 (dropped feature).</p>
</section><section id="sec-fs-filter-based" class="level3" data-number="6.1.4"><h3 data-number="6.1.4" class="anchored" data-anchor-id="sec-fs-filter-based">
<span class="header-section-number">6.1.4</span> Filter-based Feature Selection</h3>
<p>After calculating a score for each feature, one has to select the features to be kept or those to be dropped from further modeling steps. For the <code>"selected_features"</code> filter described in embedded methods (<a href="#sec-fs-embedded-methods"><span class="quarto-unresolved-ref">sec-fs-embedded-methods</span></a>), this step is straight-forward since the methods assigns either a value of 1 for a feature to be kept or 0 for a feature to be dropped. Below, we find the names of features with a value of 1 and select those feature with <code>task$select()</code>:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-009_543c6aede95de20d39dd7dba02e019d3">
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span><span class="va">filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"selected_features"</span>, learner <span class="op">=</span> <span class="va">learner</span><span class="op">)</span></span>
<span><span class="va">filter</span><span class="op">$</span><span class="fu">calculate</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># select all features used by rpart</span></span>
<span><span class="va">keep</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">filter</span><span class="op">$</span><span class="va">scores</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="fu">select</span><span class="op">(</span><span class="va">keep</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="va">feature_names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "bill_length"    "flipper_length" "island"        </code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>To select features, we use the function <code>task$select()</code> and not <code>task$filter()</code>, which is used to filter rows (not columns) of the data matrix, see task mutators (<a href="#sec-tasks-mutators"><span class="quarto-unresolved-ref">sec-tasks-mutators</span></a>).</p>
</div>
</div>
<p>For filter methods which assign continuous scores, there are essentially two ways to select features:</p>
<ul>
<li>select the top <span class="math inline">\(k\)</span> features, or</li>
<li>select all features with a score above a threshold <span class="math inline">\(\tau\)</span>,</li>
</ul>
<p>where the first option is equivalent to dropping the bottom <span class="math inline">\(p-k\)</span> features. For both options, one has to decide on a threshold, which is often quite arbitrary. For example, to implement the first option with the information gain filter:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-010_1d8eee308bd13fd297ac4216513e12f1">
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span></span>
<span><span class="va">filter</span><span class="op">$</span><span class="fu">calculate</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># select top 3 features from information gain filter</span></span>
<span><span class="va">keep</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">filter</span><span class="op">$</span><span class="va">scores</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="fu">select</span><span class="op">(</span><span class="va">keep</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="va">feature_names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "bill_depth"     "bill_length"    "flipper_length"</code></pre>
</div>
</div>
<p>Or, the second option with <span class="math inline">\(\tau = 0.5\)</span>:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-011_72f79f69caed5273bed7781df5527505">
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">filter</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span></span>
<span><span class="va">filter</span><span class="op">$</span><span class="fu">calculate</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># select all features with score &gt;0.5 from information gain filter</span></span>
<span><span class="va">keep</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">filter</span><span class="op">$</span><span class="va">scores</span> <span class="op">&gt;</span> <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="fu">select</span><span class="op">(</span><span class="va">keep</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="va">feature_names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "bill_depth"     "bill_length"    "flipper_length" "island"        </code></pre>
</div>
</div>
<p>Filters can be integrated into pipelines. Pipelines define machine learning workflows in graphs and by that greatly simplify the combination of different steps such as preprocessing operations, resampling or ensemble learning. While pipelines are described in detail in <a href="#sec-pipelines"><span class="quarto-unresolved-ref">sec-pipelines</span></a>, here is a brief preview where filter-based feature selection is combined with a learner:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-012_2f283a7eb3561cf05ef1b8fc937048af">
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3pipelines.mlr-org.com">mlr3pipelines</a></span><span class="op">)</span></span>
<span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># combine filter (keep top 3 features) with learner</span></span>
<span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"filter"</span>, filter <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span>, filter.nfeat <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner"</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># now it can be used as any learner, but it includes the feature selection</span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/as_learner.html">as_learner</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pipelines can also be used to apply HPO (<a href="#sec-optimization"><span class="quarto-unresolved-ref">sec-optimization</span></a>) to the filter, i.e.&nbsp;tune the filter threshold to optimize the feature selection regarding prediction performance, and to embed this in resampling. We first combine a filter with a learner,</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-013_9719ad9483b58f08537b7eba5a7c85b0">
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">graph</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"filter"</span>, filter <span class="op">=</span> <span class="fu"><a href="https://mlr3filters.mlr-org.com/reference/flt.html">flt</a></span><span class="op">(</span><span class="st">"information_gain"</span><span class="op">)</span><span class="op">)</span> <span class="op"><a href="https://mlr3pipelines.mlr-org.com/reference/grapes-greater-than-greater-than-grapes.html">%&gt;&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://mlr3pipelines.mlr-org.com/reference/po.html">po</a></span><span class="op">(</span><span class="st">"learner"</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/as_learner.html">as_learner</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and tune how many feature to include</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-014_86d446bab45c50106a0a856e6162a382">
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://mlr3tuning.mlr-org.com">"mlr3tuning"</a></span><span class="op">)</span></span>
<span><span class="va">ps</span> <span class="op">=</span> <span class="fu"><a href="https://paradox.mlr-org.com/reference/ps.html">ps</a></span><span class="op">(</span>information_gain.filter.nfeat <span class="op">=</span> <span class="fu"><a href="https://paradox.mlr-org.com/reference/Domain.html">p_int</a></span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">1</span>, upper <span class="op">=</span> <span class="fl">7</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="va"><a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceSingleCrit.html">TuningInstanceSingleCrit</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">task</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">learner</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span>,</span>
<span>  search_space <span class="op">=</span> <span class="va">ps</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">tuner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/tnr.html">tnr</a></span><span class="op">(</span><span class="st">"grid_search"</span><span class="op">)</span></span>
<span><span class="va">tuner</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   information_gain.filter.nfeat learner_param_vals  x_domain
1:                             5          &lt;list[2]&gt; &lt;list[1]&gt;
1 variable not shown: [classif.acc]</code></pre>
</div>
</div>
<p>The output above shows only the best result. To show the results of all tuning steps, retrieve them from the archive of the tuning instance:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-015_cda5f47bdf9fe40f55f63d58d5163f13">
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   information_gain.filter.nfeat classif.acc
1:                             2      0.9304
2:                             5      0.9391
3:                             1      0.7478
4:                             7      0.9391
5:                             3      0.9391
6:                             6      0.9391
7:                             4      0.9391
7 variables not shown: [x_domain_information_gain.filter.nfeat, runtime_learners, timestamp, batch_nr, warnings, errors, resample_result]</code></pre>
</div>
</div>
<p>We can also plot the tuning results:</p>
<div class="cell" data-hash="feature_selection_cache/html/fig-tunefilter_466443bc5b416878688fc35f0b65cc44">
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot</a></span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-tunefilter" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="feature_selection_files/figure-html/fig-tunefilter-1.png" class="quarto-discovered-preview-image img-fluid figure-img" alt="Plot showing model performance in filter-based feature selection, showing that adding a second and third feature to the model improves performance, while adding more feature achieves no further performance gain." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;6.1: Model performance with different numbers of features, selected by an information gain filter.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>For more details, see Pipelines (<a href="#sec-pipelines"><span class="quarto-unresolved-ref">sec-pipelines</span></a>) and Hyperparameter Optimization (<a href="#sec-optimization"><span class="quarto-unresolved-ref">sec-optimization</span></a>).</p>
</section></section><section id="sec-fs-wrapper" class="level2 page-columns page-full" data-number="6.2"><h2 data-number="6.2" class="anchored" data-anchor-id="sec-fs-wrapper">
<span class="header-section-number">6.2</span> Wrapper Methods</h2>
<p>Wrapper methods work by fitting models on selected feature subsets and evaluating their performance <span class="citation" data-cites="Kohavi1997">(<a href="#ref-Kohavi1997" role="doc-biblioref">Kohavi and John 1997</a>)</span>. This can be done in a sequential fashion, e.g.&nbsp;by iteratively adding features to the model in sequential forward selection, or in a parallel fashion, e.g.&nbsp;by evaluating random feature subsets in a random search. Below, the use of these simple approaches is described in a common framework along with more advanced methods such as genetic search. It is further shown how to select features by optimizing multiple performance measures and how to wrap a learner with feature selection to use it in pipelines or benchmarks.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In contrast to filters (<a href="#sec-fs-filter"><span class="quarto-unresolved-ref">sec-fs-filter</span></a>), the learner used in the wrapper feature selection is <em>not</em> independent of learners used in subsequent modeling steps. The idea of wrapper methods is to directly include, i.e.&nbsp;wrap, the feature selection with the learner to optimize its performance.</p>
</div>
</div>
<p>In more detail, wrapper methods iteratively select features that optimize a performance measure. Instead of ranking features, a model is fit on a selected subset of features in each iteration and evaluated in resampling with respect to a selected performance measure. The strategy that determines which feature subset is used in each iteration is given by the <code>FSelector</code> object. A simple example is the sequential forward selection that starts with computing each single-feature model, selects the best one, and then iteratively adds the feature that leads to the largest performance improvement (<a href="#fig-sequential-forward-selection">Figure&nbsp;<span class="quarto-unresolved-ref">fig-sequential-forward-selection</span></a>).</p>
<div class="cell" data-hash="feature_selection_cache/html/fig-sequential-forward-selection_9c0c7d65ea6f651e1aa220575558493c">
<div class="cell-output-display">
<div id="fig-sequential-forward-selection-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="Figures/mlr3book_figures-15.svg" class="img-fluid figure-img" alt="Sequential Forward Selection."></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;6.2: Sequential Forward Selection.</figcaption><p></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div id="fig-sequential-forward-selection-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="Figures/mlr3book_figures-16.svg" class="img-fluid figure-img" alt="Sequential Forward Selection."></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;6.3: Sequential Forward Selection.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Wrapper methods can be used with any learner but need to train the learner potentially many times, leading to a computationally intensive method. All wrapper methods are implemented via the package <a href="https://mlr3fselect.mlr-org.com"><code>mlr3fselect</code></a>. In this chapter, we cover how to</p>
<ul>
<li>instantiate an <code>FSelector</code> object,</li>
<li>configure it, to e.g.&nbsp;respect a runtime limit or for different objectives,</li>
<li>run it or fuse it with a <code>Learner</code> via an <code>AutoFSelector</code>.</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Wrapper-based feature selection is very similar to HPO (<a href="#sec-optimization"><span class="quarto-unresolved-ref">sec-optimization</span></a>). The major difference is that we search for well-performing feature subsets instead of hyperparameter configurations. We will see below, that we can even use the same terminators, that some feature selection algorithms are similar to tuners and that we can also optimize multiple performance measures with feature selection.</p>
</div>
</div>
<section id="sec-fs-wrapper-example" class="level3" data-number="6.2.1"><h3 data-number="6.2.1" class="anchored" data-anchor-id="sec-fs-wrapper-example">
<span class="header-section-number">6.2.1</span> Simple Forward Selection Example</h3>
<p>We start with the simple example from above and do sequential forward selection with the penguins data:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-017_5554a927dc4f452e798a5e30017406ab">
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://mlr3fselect.mlr-org.com">"mlr3fselect"</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># subset features to ease visualization</span></span>
<span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">task</span><span class="op">$</span><span class="fu">select</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"bill_depth"</span>, <span class="st">"bill_length"</span>, <span class="st">"body_mass"</span>, <span class="st">"flipper_length"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fselect.html">fselect</a></span><span class="op">(</span></span>
<span>  fselector <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fs.html">fs</a></span><span class="op">(</span><span class="st">"sequential"</span><span class="op">)</span>,</span>
<span>  task <span class="op">=</span>  <span class="va">task</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In contrast to HPO (<a href="#sec-optimization"><span class="quarto-unresolved-ref">sec-optimization</span></a>), <code>fselect</code> directly starts the optimization and selects features. To show all analyzed feature subsets and the corresponding performance, we use <code>as.data.table(instance$archive)</code>. In this example, the <code>batch_nr</code> column represents the iteration of the sequential forward selection and we start by looking at the first iteration.</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-018_016c7713ca51e8d11bd8a24dec696352">
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">dt</span> <span class="op">=</span> <span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span></span>
<span><span class="va">dt</span><span class="op">[</span><span class="va">batch_nr</span> <span class="op">==</span> <span class="fl">1</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   bill_depth bill_length body_mass flipper_length classif.acc
1:       TRUE       FALSE     FALSE          FALSE      0.6957
2:      FALSE        TRUE     FALSE          FALSE      0.7652
3:      FALSE       FALSE      TRUE          FALSE      0.7043
4:      FALSE       FALSE     FALSE           TRUE      0.7913</code></pre>
</div>
</div>
<p>We see that the feature <code>flipper_length</code> achieved the highest prediction performance in the first iteration and is thus selected. We plot the performance over the iterations:</p>
<div class="cell" data-hash="feature_selection_cache/html/fig-fowardselection_c2bca013816f2dba291406abdce7d554">
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot</a></span><span class="op">(</span><span class="va">instance</span>, type <span class="op">=</span> <span class="st">"performance"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-fowardselection" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="feature_selection_files/figure-html/fig-fowardselection-1.png" class="img-fluid figure-img" alt="Plot showing model performance in sequential forward selection iterations, showing that adding a second feature to the model improves performance, while adding more feature achieves no further performance gain." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;6.4: Model performance in iterations of sequential forward selection.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>In the plot, we can see that adding a second feature further improves the performance to over 90%. To see which feature was added, we can go back to the archive and look at the second iteration:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-018-2_a9cb00bb87598951d9361a9c04d53da4">
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">dt</span><span class="op">[</span><span class="va">batch_nr</span> <span class="op">==</span> <span class="fl">2</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   bill_depth bill_length body_mass flipper_length classif.acc
1:       TRUE       FALSE     FALSE           TRUE      0.7652
2:      FALSE        TRUE     FALSE           TRUE      0.9391
3:      FALSE       FALSE      TRUE           TRUE      0.8174</code></pre>
</div>
</div>
<p>The third iteration confirms our conclusion from the plot, that adding a third feature does not improve performance:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-018-3_e6ea64fa4b19442d56ee75c5166e2a96">
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">dt</span><span class="op">[</span><span class="va">batch_nr</span> <span class="op">==</span> <span class="fl">3</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   bill_depth bill_length body_mass flipper_length classif.acc
1:       TRUE        TRUE     FALSE           TRUE      0.9391
2:      FALSE        TRUE      TRUE           TRUE      0.9391</code></pre>
</div>
</div>
<p>To directly show the best feature set, we can use:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-019_5838f91513c9cd202ce97ef4f1e906d0">
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span><span class="op">$</span><span class="va">result_feature_set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "bill_length"    "flipper_length"</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>instance$result_feature_set</code> shows features in alphabetical order and not in the order selected.</p>
</div>
</div>
<p>Internally, the <code>fselect</code> function creates an <code>FSelectInstanceSingleCrit</code> object and executes the feature selection with an <code>FSelector</code> object, based on the selected method, in this example an <code>FSelectorSequential</code> object. It uses the supplied resampling and measure to evaluate all feature subsets provided by the <code>FSelector</code> on the task.</p>
<p>At the heart of <a href="https://mlr3fselect.mlr-org.com"><code>mlr3fselect</code></a> are the R6 classes:</p>
<ul>
<li>
<code>FSelectInstanceSingleCrit</code>, <code>FSelectInstanceMultiCrit</code>: These two classes describe the feature selection problem and store the results.</li>
<li>
<code>FSelector</code>: This class is the base class for implementations of feature selection algorithms.</li>
</ul>
<p>In the following two sections, these classes will be created manually, to learn more about the <a href="https://mlr3fselect.mlr-org.com"><code>mlr3fselect</code></a> package.</p>
</section><section id="the-fselectinstance-classes" class="level3" data-number="6.2.2"><h3 data-number="6.2.2" class="anchored" data-anchor-id="the-fselectinstance-classes">
<span class="header-section-number">6.2.2</span> The <code>FSelectInstance</code> Classes</h3>
<p>To create an <code>FSelectInstanceSingleCrit</code> object, we use the sugar function <a href="https://mlr3fselect.mlr-org.com/reference/fsi.html" class="refcode"><code>fsi</code></a>, which is short for <code>FSelectInstanceSingleCrit$new()</code> or <code>FSelectInstanceMultiCrit$new()</code>, depending on the selected measure(s):</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-020_5a243c3d37d852655d9044e5f1d346b9">
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fsi.html">fsi</a></span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">task</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that we have not selected a feature selection algorithm and thus did not select any features, yet. We have also supplied a <code>Terminator</code>, which is used to stop the feature selection. For the forward selection in the example above, we did not need a terminator because we simply tried all remaining features until the full model (technically using <a href="https://bbotk.mlr-org.com/reference/mlr_terminators_none.html" class="refcode"><code>TerminatorNone</code></a>). However, we could still use a terminator to stop the forward selection early. For other feature selection algorithms such as <a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_random_search.html" class="refcode"><code>random search</code></a>, a terminator is required. The following terminator are available:</p>
<ul>
<li>Terminate after a given time (<a href="https://bbotk.mlr-org.com/reference/mlr_terminators_clock_time.html" class="refcode"><code>TerminatorClockTime</code></a>)</li>
<li>Terminate after a given amount of iterations (<a href="https://bbotk.mlr-org.com/reference/mlr_terminators_evals.html" class="refcode"><code>TerminatorEvals</code></a>)</li>
<li>Terminate after a specific performance is reached (<a href="https://bbotk.mlr-org.com/reference/mlr_terminators_perf_reached.html" class="refcode"><code>TerminatorPerfReached</code></a>)</li>
<li>Terminate when feature selection does not improve (<a href="https://bbotk.mlr-org.com/reference/mlr_terminators_stagnation.html" class="refcode"><code>TerminatorStagnation</code></a>)</li>
<li>A combination of the above in an <em>ALL</em> or <em>ANY</em> fashion (<a href="https://bbotk.mlr-org.com/reference/mlr_terminators_combo.html" class="refcode"><code>TerminatorCombo</code></a>)</li>
</ul>
<p>See also the description of terminators in HPO (<a href="#sec-terminator"><span class="quarto-unresolved-ref">sec-terminator</span></a>). Above we used the sugar function <a href="https://bbotk.mlr-org.com/reference/trm.html" class="refcode"><code>trm</code></a> to select <a href="https://bbotk.mlr-org.com/reference/mlr_terminators_evals.html" class="refcode"><code>TerminatorEvals</code></a> with 20 evaluations.</p>
<p>To start the feature selection, we still need to select an algorithm which are defined via the <code>FSelector</code> class, described in the next section.</p>
</section><section id="the-fselector-class" class="level3 page-columns page-full" data-number="6.2.3"><h3 data-number="6.2.3" class="anchored" data-anchor-id="the-fselector-class">
<span class="header-section-number">6.2.3</span> The <code>FSelector</code> Class</h3>
<p>The <code>FSelector</code> class is the base class for different feature selection algorithms. The following algorithms are currently implemented in <a href="https://mlr3fselect.mlr-org.com"><code>mlr3fselect</code></a>:</p>
<ul>
<li>Random search, trying random feature subsets until termination (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_random_search.html" class="refcode"><code>FSelectorRandomSearch</code></a>)</li>
<li>Exhaustive search, trying all possible feature subsets (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_exhaustive_search.html" class="refcode"><code>FSelectorExhaustiveSearch</code></a>)</li>
<li>Sequential search, i.e.&nbsp;sequential forward or backward selection (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_sequential.html" class="refcode"><code>FSelectorSequential</code></a>)</li>
<li>Recursive feature elimination, which uses learner’s importance scores to iteratively remove features with low feature importance (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_rfe.html" class="refcode"><code>FSelectorRFE</code></a>)</li>
<li>Design points, trying all user-supplied feature sets (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_design_points.html" class="refcode"><code>FSelectorDesignPoints</code></a>)</li>
<li>Genetic search, implementing a genetic algorithm which treats the features as a binary sequence and tries to find the best subset with mutations (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_genetic_search.html" class="refcode"><code>FSelectorGeneticSearch</code></a>)</li>
<li>Shadow variable search, which adds permuted copies of all features (shadow variables) and stops when a shadow variable is selected (<a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors_shadow_variable_search.html" class="refcode"><code>FSelectorShadowVariableSearch</code></a>)</li>
</ul>
<div class="page-columns page-full"><p>Note that all these methods can be stopped (early) with a terminator, e.g.&nbsp;an exhaustive search can be stopped after a given number of evaluations. More details on these algorithms can be found in the respective R help pages and on the <a href="https://mlr3fselect.mlr-org.com">mlr3fselect website</a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. In this example, we will use a simple random search and retrieve it from the dictionary <a href="https://mlr3fselect.mlr-org.com/reference/mlr_fselectors.html" class="refcode"><code>mlr_fselectors</code></a> with the <a href="https://mlr3fselect.mlr-org.com/reference/fs.html" class="refcode"><code>fs()</code></a> sugar function, which is short for <code>FSelectorRandomSearch$new()</code>:</p><div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;<a href="https://mlr3fselect.mlr-org.com">https://mlr3fselect.mlr-org.com</a></p></li></div></div>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-021_f0f06f3e63863f67ce2e9a416f71ebfd">
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">fselector</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fs.html">fs</a></span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section><section id="starting-the-feature-selection" class="level3" data-number="6.2.4"><h3 data-number="6.2.4" class="anchored" data-anchor-id="starting-the-feature-selection">
<span class="header-section-number">6.2.4</span> Starting the Feature Selection</h3>
<p>To start the feature selection, we pass the <code>FSelectInstanceSingleCrit</code> object to the <code>$optimize()</code> method of the initialized <code>FSelector</code> object:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-022_587f20afa918d6f7496132b85bb308e0">
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">fselector</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The algorithm proceeds as follows</p>
<ol type="1">
<li>The <code>FSelector</code> proposes at least one feature subset and may propose multiple subsets to improve parallelization, which can be controlled via the setting <code>batch_size</code>.</li>
<li>For each feature subset, the given learner is fitted on the task using the provided resampling and evaluated with the given measure.</li>
<li>All evaluations are stored in the archive of the <code>FSelectInstanceSingleCrit</code> object.</li>
<li>The terminator is queried if the budget is exhausted. If the budget is not exhausted, restart with 1) until it is.</li>
<li>Determine the feature subset with the best observed performance.</li>
<li>Store the best feature subset as the result in the instance object.</li>
</ol>
<p>The best feature subset and the corresponding measured performance can be accessed from the instance:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-023_916254b60f8d482e6e10fe61811ade45">
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">features</span>, <span class="va">classif.acc</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                          features classif.acc
1: bill_depth,bill_length,body_mass,flipper_length      0.9391</code></pre>
</div>
</div>
<p>As in the forward selection example above, one can investigate all resamplings which were undertaken, as they are stored in the archive of the <code>FSelectInstanceSingleCrit</code> object and can be accessed by using <code><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table()</a></code>:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-024_d1b3b17588dcdac71bdcf589e0ad9d91">
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">bill_depth</span>, <span class="va">bill_length</span>, <span class="va">body_mass</span>, <span class="va">flipper_length</span>, <span class="va">classif.acc</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    bill_depth bill_length body_mass flipper_length classif.acc
 1:       TRUE        TRUE      TRUE          FALSE      0.9043
 2:       TRUE        TRUE      TRUE          FALSE      0.9043
 3:       TRUE       FALSE      TRUE          FALSE      0.7043
 4:       TRUE        TRUE      TRUE           TRUE      0.9391
 5:       TRUE       FALSE      TRUE           TRUE      0.7565
---                                                            
16:      FALSE       FALSE      TRUE          FALSE      0.6870
17:       TRUE       FALSE      TRUE           TRUE      0.7565
18:       TRUE        TRUE     FALSE           TRUE      0.9391
19:       TRUE       FALSE     FALSE          FALSE      0.7565
20:      FALSE        TRUE     FALSE          FALSE      0.7478</code></pre>
</div>
</div>
<p>Now the optimized feature subset can be used to subset the task and fit the model on all observations:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-025_4208ef279297939945aab2dd911d930f">
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">task</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">task</span><span class="op">$</span><span class="fu">select</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">result_feature_set</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">task</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The trained model can now be used to make a prediction on external data.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>Predicting on observations present in the data used for feature selection should be avoided. The model has seen these observations already during feature selection and therefore performance evaluation results would be over-optimistic. Instead, to get unbiased performance estimates for the current task, nested resampling (see <a href="#sec-autofselect"><span class="quarto-unresolved-ref">sec-autofselect</span></a> and <a href="#sec-nested-resampling"><span class="quarto-unresolved-ref">sec-nested-resampling</span></a>) is required.</p>
</div>
</div>
</section><section id="sec-multicrit-featsel" class="level3" data-number="6.2.5"><h3 data-number="6.2.5" class="anchored" data-anchor-id="sec-multicrit-featsel">
<span class="header-section-number">6.2.5</span> Optimizing Multiple Performance Measures</h3>
<p>You might want to use multiple criteria to evaluate the performance of the feature subsets. For example, you might want to select the subset with the highest classification accuracy and lowest time to train the model. However, these two subsets will generally not coincide, i.e.&nbsp;the subset with highest classification accuracy will probably be another subset than that with lowest training time. With <a href="https://mlr3fselect.mlr-org.com"><code>mlr3fselect</code></a>, the result is the pareto-optimal solution, i.e.&nbsp;the best feature subset for each of the criteria that is not dominated by another subset. For the example with classification accuracy and training time, a feature subset that is best in accuracy <em>and</em> training time will dominate all other subsets and thus will be the only pareto-optimal solution. If, however, different subsets are best in the two criteria, both subsets are pareto-optimal. Again, we point out the similarity with HPO and refer to multi-objective hyperparameter optimization (see <a href="#sec-multi-metrics-tuning"><span class="quarto-unresolved-ref">sec-multi-metrics-tuning</span></a> and <span class="citation" data-cites="karl2022">Karl et al. (<a href="#ref-karl2022" role="doc-biblioref">2022</a>)</span>).</p>
<p>In the following example, we will perform feature selection on the sonar dataset. This time, we will use <a href="https://mlr3fselect.mlr-org.com/reference/FSelectInstanceMultiCrit.html" class="refcode"><code>FSelectInstanceMultiCrit</code></a> to select a subset of features that has high sensitivity, i.e.&nbsp;TPR, and high specificity, i.e.&nbsp;TNR. The feature selection process with multiple criteria is similar to that with a single criterion, except that we select two measures to be optimized:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-026_07c3a04c483f26dd8492d11f08a2abc8">
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fsi.html">fsi</a></span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msrs</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.tpr"</span>, <span class="st">"classif.tnr"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function <a href="https://mlr3fselect.mlr-org.com/reference/fsi.html" class="refcode"><code>fsi</code></a> creates an instance of <code>FSelectInstanceMultiCrit</code> if more than one measure is selected. We now create an <code>FSelector</code> and call the <code>$optimize()</code> function of the <code>FSelector</code> with the <code>FSelectInstanceMultiCrit</code> object, to search for the subset of features with the best TPR and FPR. Note that these two measures cannot both be optimal at the same time (except for the perfect classifier) and we expect several pareto-optimal solutions.</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-027_8a729071bfcd65b9b75c8b976a7f3298">
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">fselector</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fs.html">fs</a></span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span></span>
<span><span class="va">fselector</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As above, the best feature subsets and the corresponding measured performance can be accessed from the instance.</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-029_b1c6fb0937cd16290e6b9f82481dc839">
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">features</span>, <span class="va">classif.tpr</span>, <span class="va">classif.tnr</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                      features classif.tpr classif.tnr
1:  V1,V11,V13,V15,V16,V18,...       0.725      0.7931
2:  V1,V10,V12,V13,V14,V15,...       0.725      0.7931
3: V12,V13,V14,V16,V17,V19,...       0.850      0.4483
4:  V1,V10,V11,V13,V14,V15,...       0.725      0.7931
5: V12,V15,V20,V24,V26,V32,...       0.800      0.7586</code></pre>
</div>
</div>
<p>We see different tradeoffs of sensitivity and specificity but no feature subset is dominated by another, i.e.&nbsp;has worse sensitivity <em>and</em> specificity than any other subset.</p>
</section><section id="sec-autofselect" class="level3" data-number="6.2.6"><h3 data-number="6.2.6" class="anchored" data-anchor-id="sec-autofselect">
<span class="header-section-number">6.2.6</span> Automating the Feature Selection and Nested Resampling</h3>
<p>The <code>AutoFSelector</code> class wraps a learner and augments it with an automatic feature selection for a given task. Because the <code>AutoFSelector</code> itself inherits from the <a href="https://mlr3.mlr-org.com/reference/Learner.html" class="refcode"><code>Learner</code></a> base class, it can be used like any other learner. Below, a new learner is created. This learner is then wrapped in a random search feature selector, which automatically starts a feature selection on the given task using an inner resampling, as soon as the wrapped learner is trained. Here, the function <a href="https://mlr3fselect.mlr-org.com/reference/auto_fselector.html" class="refcode"><code>auto_fselector</code></a> creates an instance of <code>AutoFSelector</code>, i.e.&nbsp;it is short for <code>AutoFSelector$new()</code>.</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-030_1cb3bb5a7cef959f43e3e98a420dafdb">
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/auto_fselector.html">auto_fselector</a></span><span class="op">(</span></span>
<span>  fselector <span class="op">=</span> <span class="fu"><a href="https://mlr3fselect.mlr-org.com/reference/fs.html">fs</a></span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.log_reg"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msr</a></span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">at</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;AutoFSelector:classif.log_reg.fselector&gt;
* Model: list
* Packages: mlr3, mlr3fselect, mlr3learners, stats
* Predict Type: response
* Feature Types: logical, integer, numeric, character, factor,
  ordered
* Properties: loglik, twoclass</code></pre>
</div>
</div>
<p>We can now, as with any other learner, call the <code>$train()</code> and <code>$predict()</code> method. This time however, we pass it to <a href="https://mlr3.mlr-org.com/reference/benchmark.html" class="refcode"><code>benchmark()</code></a> to compare the optimized feature subset to the complete feature set. This way, the <code>AutoFSelector</code> will do its resampling for feature selection on the training set of the respective split of the outer resampling. The learner then undertakes predictions using the test set of the outer resampling. Here, the outer resampling refers to the resampling specified in <code><a href="https://mlr3.mlr-org.com/reference/benchmark.html">benchmark()</a></code>, whereas the inner resampling is that specified in <code><a href="https://mlr3fselect.mlr-org.com/reference/auto_fselector.html">auto_fselector()</a></code>. This is called nested resampling (see <a href="#sec-nested-resampling"><span class="quarto-unresolved-ref">sec-nested-resampling</span></a>) and yields unbiased performance measures, as the observations in the test set have not been used during feature selection or fitting of the respective learner.</p>
<p>In the call to <code><a href="https://mlr3.mlr-org.com/reference/benchmark.html">benchmark()</a></code>, we compare our wrapped learner <code>at</code> with a normal logistic regression <code>lrn("classif.log_reg")</code>. For that, we create a benchmark grid with the task, the learners and a 3-fold cross validation on the <a href="https://mlr3.mlr-org.com/reference/mlr_tasks_sonar.html" class="refcode"><code>sonar</code></a> data.</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-031_9eebd2be9c5a8a517c0f8294f7b09591">
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">grid</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/benchmark_grid.html">benchmark_grid</a></span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">tsk</a></span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">at</span>, <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">lrn</a></span><span class="op">(</span><span class="st">"classif.log_reg"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">rsmp</a></span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">bmr</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3.mlr-org.com/reference/benchmark.html">benchmark</a></span><span class="op">(</span><span class="va">grid</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, we compare those two learners regarding classification accuracy and training time:</p>
<div class="cell" data-hash="feature_selection_cache/html/feature-selection-032_2eefdbfd2de71afce5d8e5febaf54f56">
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">aggr</span> <span class="op">=</span> <span class="va">bmr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="fu"><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html">msrs</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.acc"</span>, <span class="st">"time_train"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://Rdatatable.gitlab.io/data.table/reference/as.data.table.html">as.data.table</a></span><span class="op">(</span><span class="va">aggr</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">learner_id</span>, <span class="va">classif.acc</span>, <span class="va">time_train</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                  learner_id classif.acc time_train
1: classif.log_reg.fselector      0.7061      0.548
2:           classif.log_reg      0.6776      0.020</code></pre>
</div>
</div>
<p>We can see that, in this example, the feature selection improves prediction performance but also drastically increases the training time, since the feature selection (including resampling and random search) is part of the model training of the wrapped learner.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>For wrapper methods, we use the <code>AutoFSelector</code> to wrap a learner with feature selection, whereas in <a href="#sec-fs-filter-based"><span class="quarto-unresolved-ref">sec-fs-filter-based</span></a> we used pipelines to combine learner and feature selection filter. The difference is that a filter is independent of the learner and can thus be calculated as a preprocessing operator before training a learner, while a wrapper is inseparable from the learner, as it needs to train the learner in each iteration with a different feature subset. Nevertheless, both approaches can be integrated into pipelines.</p>
</div>
</div>
</section></section><section id="conclusion" class="level2 page-columns page-full" data-number="6.3"><h2 data-number="6.3" class="anchored" data-anchor-id="conclusion">
<span class="header-section-number">6.3</span> Conclusion</h2>
<p>In this chapter, we learned how to perform feature selection with <code>mlr3</code>. We introduced filter and wrapper methods, combined feature selection with pipelines, learned how to automate the feature selection and covered the optimization of multiple performance measures. <a href="#tbl-api-feature-selection">Table&nbsp;<span class="quarto-unresolved-ref">tbl-api-feature-selection</span></a> gives an overview of the most important functions (S3) and classes (R6) used in this chapter.</p>
<div id="tbl-api-feature-selection" class="anchored">
<table class="table">
<caption>Table&nbsp;6.1: Core S3 ‘sugar’ functions for feature selection in mlr3 with the underlying R6 class that are constructed when these functions are called (if applicable) and a summary of the purpose of the functions.</caption>
<thead><tr class="header">
<th>S3 function</th>
<th>R6 Class</th>
<th>Summary</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://mlr3filters.mlr-org.com/reference/flt.html" class="refcode"><code>flt()</code></a></td>
<td><a href="https://www.rdocumentation.org/packages/base/topics/funprog" class="refcode"><code>Filter</code></a></td>
<td>Selects features by calculating a score for each feature</td>
</tr>
<tr class="even">
<td><code>Filter$calculate()</code></td>
<td><a href="https://www.rdocumentation.org/packages/base/topics/funprog" class="refcode"><code>Filter</code></a></td>
<td>Calculates scores on a given task</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3fselect.mlr-org.com/reference/fselect.html" class="refcode"><code>fselect()</code></a></td>
<td>
<a href="https://mlr3fselect.mlr-org.com/reference/FSelectInstanceSingleCrit.html" class="refcode"><code>FSelectInstanceSingleCrit</code></a> or <a href="https://mlr3fselect.mlr-org.com/reference/FSelectInstanceMultiCrit.html" class="refcode"><code>FSelectInstanceMultiCrit</code></a>
</td>
<td>Specifies a feature selection problem and stores the results</td>
</tr>
<tr class="even">
<td><a href="https://mlr3fselect.mlr-org.com/reference/fs.html" class="refcode"><code>fs()</code></a></td>
<td><a href="https://mlr3fselect.mlr-org.com/reference/FSelector.html" class="refcode"><code>FSelector</code></a></td>
<td>Specifies a feature selection algorithm</td>
</tr>
<tr class="odd">
<td><code>FSelector$optimize()</code></td>
<td><a href="https://mlr3fselect.mlr-org.com/reference/FSelector.html" class="refcode"><code>FSelector</code></a></td>
<td>Executes the features selection specified by the <code>FSelectInstance</code> with the algorithm specified by the <code>FSelector</code>
</td>
</tr>
<tr class="even">
<td><a href="https://mlr3fselect.mlr-org.com/reference/auto_fselector.html" class="refcode"><code>auto_fselector()</code></a></td>
<td><a href="https://mlr3fselect.mlr-org.com/reference/AutoFSelector.html" class="refcode"><code>AutoFSelector</code></a></td>
<td>Defines a learner that includes feature selection</td>
</tr>
</tbody>
</table>
</div>
<section id="resources" class="level3 unnumbered unlisted page-columns page-full"><h3 class="unnumbered unlisted anchored" data-anchor-id="resources">Resources</h3>
<ul>
<li>A list of implemented filters in the <a href="https://mlr3filters.mlr-org.com"><code>mlr3filters</code></a> package is provided on the <a href="https://mlr3filters.mlr-org.com">mlr3filters website</a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</li>
<li>A summary of wrapper-based feature selection with the <a href="https://mlr3fselect.mlr-org.com"><code>mlr3fselect</code></a> package is provided in the <a href="https://cheatsheets.mlr-org.com/mlr3fselect.pdf">mlr3fselect cheatsheet</a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</li>
<li>An overview of feature selection methods is provided by <span class="citation" data-cites="chandrashekar2014">Chandrashekar and Sahin (<a href="#ref-chandrashekar2014" role="doc-biblioref">2014</a>)</span>.</li>
<li>A more formal and detailed introduction to filters and wrappers is given in <span class="citation" data-cites="guyon2003">Guyon and Elisseeff (<a href="#ref-guyon2003" role="doc-biblioref">2003</a>)</span>.</li>
<li>
<span class="citation" data-cites="bommert2020">Bommert et al. (<a href="#ref-bommert2020" role="doc-biblioref">2020</a>)</span> perform a benchmark of filter methods.</li>
<li>Filters can be used as part of a machine learning pipeline (<a href="#sec-pipelines"><span class="quarto-unresolved-ref">sec-pipelines</span></a>).</li>
<li>Filters can be optimized with HPO (<a href="#sec-optimization"><span class="quarto-unresolved-ref">sec-optimization</span></a>).</li>
</ul><div class="no-row-height column-margin column-container"><li id="fn5"><p><sup>5</sup>&nbsp;<a href="https://mlr3filters.mlr-org.com">https://mlr3filters.mlr-org.com</a></p></li><li id="fn6"><p><sup>6</sup>&nbsp;<a href="https://cheatsheets.mlr-org.com/mlr3fselect.pdf">https://cheatsheets.mlr-org.com/mlr3fselect.pdf</a></p></li></div></section></section><section id="exercises" class="level2" data-number="6.4"><h2 data-number="6.4" class="anchored" data-anchor-id="exercises">
<span class="header-section-number">6.4</span> Exercises</h2>
<ol type="1">
<li>Calculate a correlation filter on the <a href="https://mlr3.mlr-org.com/reference/mlr_tasks_mtcars.html" class="refcode"><code>Motor Trend</code></a> dataset (<code>mtcars</code>).</li>
<li>Use the filter from the first exercise to select the five best features in the <code>mtcars</code> dataset.</li>
<li>Apply a backward selection to the <a href="https://mlr3.mlr-org.com/reference/mlr_tasks_penguins.html" class="refcode"><code>penguins</code></a> dataset with a classification tree learner <code>"classif.rpart"</code> and holdout resampling by the measure classification accuracy. Compare the results with those in <a href="#sec-fs-wrapper-example"><span class="quarto-unresolved-ref">sec-fs-wrapper-example</span></a>. Answer the following questions:
<ol type="a">
<li>Do the selected features differ?</li>
<li>Which feature selection method achieves a higher classification accuracy?</li>
<li>Are the accuracy values in b) directly comparable? If not, what has to be changed to make them comparable?</li>
</ol>
</li>
<li>Automate the feature selection as in <a href="#sec-autofselect"><span class="quarto-unresolved-ref">sec-autofselect</span></a> with the <a href="https://mlr3.mlr-org.com/reference/mlr_tasks_sonar.html" class="refcode"><code>sonar</code></a> dataset and a logistic regression learner (<code>"classif.log_reg"</code>). Hint: Remember to call <code><a href="https://mlr3learners.mlr-org.com">library("mlr3learners")</a></code> for the logistic regression learner.</li>
</ol></section><section id="citation" class="level2" data-number="6.5"><h2 data-number="6.5" class="anchored" data-anchor-id="citation">
<span class="header-section-number">6.5</span> Citation</h2>
<p>Please cite this chapter as:</p>
<p>Wright MN. (2024). Feature Selection. In Bischl B, Sonabend R, Kotthoff L, Lang M, (Eds.), <em>Applied Machine Learning Using mlr3 in R</em>. CRC Press. https://mlr3book.mlr-org.com/feature_selection.html.</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-bommert2020" class="csl-entry" role="listitem">
Bommert, Andrea, Xudong Sun, Bernd Bischl, Jörg Rahnenführer, and Michel Lang. 2020. <span>“Benchmark for Filter Methods for Feature Selection in High-Dimensional Classification Data.”</span> <em>Computational Statistics &amp; Data Analysis</em> 143: 106839. https://doi.org/<a href="https://doi.org/10.1016/j.csda.2019.106839">https://doi.org/10.1016/j.csda.2019.106839</a>.
</div>
<div id="ref-chandrashekar2014" class="csl-entry" role="listitem">
Chandrashekar, Girish, and Ferat Sahin. 2014. <span>“A Survey on Feature Selection Methods.”</span> <em>Computers and Electrical Engineering</em> 40 (1): 16–28. https://doi.org/<a href="https://doi.org/10.1016/j.compeleceng.2013.11.024">https://doi.org/10.1016/j.compeleceng.2013.11.024</a>.
</div>
<div id="ref-guyon2003" class="csl-entry" role="listitem">
Guyon, Isabelle, and André Elisseeff. 2003. <span>“An Introduction to Variable and Feature Selection.”</span> <em>Journal of Machine Learning Research</em> 3 (Mar): 1157–82.
</div>
<div id="ref-karl2022" class="csl-entry" role="listitem">
Karl, Florian, Tobias Pielok, Julia Moosbauer, Florian Pfisterer, Stefan Coors, Martin Binder, Lennart Schneider, et al. 2022. <span>“Multi-Objective Hyperparameter Optimization–an Overview.”</span> <em>arXiv Preprint arXiv:2206.07438</em>.
</div>
<div id="ref-Kohavi1997" class="csl-entry" role="listitem">
Kohavi, Ron, and George H. John. 1997. <span>“Wrappers for Feature Subset Selection.”</span> <em>Artificial Intelligence</em> 97 (1): 273–324. https://doi.org/<a href="https://doi.org/10.1016/S0004-3702(97)00043-X">https://doi.org/10.1016/S0004-3702(97)00043-X</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter7/sequential_pipelines.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb58" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Feature Selection {#sec-feature-selection}</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_setup.qmd &gt;}}</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="in">`r chapter = "Feature Selection"`</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="in">`r authors(chapter)`</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>Feature selection, also known as variable or descriptor selection, is the process of finding a subset of features to use with a given task and learner.</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>Using an *optimal set* of features can have several benefits:</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>improved predictive performance, since we reduce overfitting on irrelevant features,</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>robust models that do not rely on noisy features,</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>simpler models that are easier to interpret,</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>faster model fitting, e.g. for model updates,</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>faster prediction, and</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>no need to collect potentially expensive features.</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>However, these objectives will not necessarily be optimized by the same *optimal set* of features and thus feature selection can be seen as a multi-objective optimization problem.</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>In this chapter, we mostly focus on feature selection as a means of improving predictive performance, but also briefly cover optimization of multiple criteria (@sec-multicrit-featsel).</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>Reducing the amount of features can improve models across many scenarios, but it can be especially helpful in datasets that have a high number of features in comparison to the number of datapoints.</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>Many learners perform implicit, also called embedded, feature selection, e.g. via the choice of variables used for splitting in a decision tree.</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>Most other feature selection methods are model agnostic, i.e. they can be used together with any learner.</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>Of the many different approaches to identifying relevant features, we will focus on two general concepts, which are described in detail below: Filter and Wrapper methods <span class="co">[</span><span class="ot">@guyon2003;@chandrashekar2014</span><span class="co">]</span>.</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>For this chapter, the reader should know the basic concepts of <span class="in">`mlr3`</span> (@sec-basics), i.e. know about tasks (@sec-tasks) and learners (@sec-learners).</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>Basics about performance evaluation (@sec-performance), i.e. resampling (@sec-resampling) and benchmarking (@sec-benchmarking) are helpful but not strictly necessary.</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a><span class="fu">## Filters {#sec-fs-filter}</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>Filter methods are preprocessing steps that can be applied before training a model.</span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>A very simple filter approach could look like this:</span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>calculate the correlation coefficient $\rho$ between each feature and a numeric target variable, and</span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>select all features with $\rho &gt; 0.2$ for further modeling steps.</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a>This approach is a *univariate* filter because it only considers the univariate relationship between each feature and the target variable.</span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>Further, it can only be applied to regression tasks with continuous features and the threshold of $\rho &gt; 0.2$ is quite arbitrary.</span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a>Thus, more advanced filter methods, e.g. *multivariate* filters based on feature importance, usually perform better <span class="co">[</span><span class="ot">@bommert2020</span><span class="co">]</span>.</span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a>On the other hand, a benefit of univariate filters is that they are usually computationally cheaper than more complex filter or wrapper methods.</span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a>In the following, it is described how to calculate univariate, multivariate and feature importance filters, how to access implicitly selected features, how to integrate filters in a machine learning pipeline and how to optimize filter thresholds.</span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a>Filter algorithms select features by assigning numeric scores to each feature, e.g. correlation between feature and target variables, use these to rank the features and select a feature subset based on the ranking.</span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a>Features that are assigned lower scores can then be omitted in subsequent modeling steps.</span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a>All filters are implemented via the package <span class="in">`r mlr3filters`</span>.</span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>Below, we cover how to</span>
<span id="cb58-47"><a href="#cb58-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-48"><a href="#cb58-48" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>instantiate a <span class="in">`Filter`</span> object,</span>
<span id="cb58-49"><a href="#cb58-49" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>calculate scores for a given task, and</span>
<span id="cb58-50"><a href="#cb58-50" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>use calculated scores to select or drop features.</span>
<span id="cb58-51"><a href="#cb58-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-52"><a href="#cb58-52" aria-hidden="true" tabindex="-1"></a>Special cases of filters are feature importance filters (@sec-fs-var-imp-filters) and embedded methods (@sec-fs-embedded-methods).</span>
<span id="cb58-53"><a href="#cb58-53" aria-hidden="true" tabindex="-1"></a>Feature importance filters select features that are important according to the model induced by a selected <span class="in">`Learner`</span>.</span>
<span id="cb58-54"><a href="#cb58-54" aria-hidden="true" tabindex="-1"></a>They rely on the learner to extract information on feature importance from a trained model, for example, by inspecting a learned decision tree and returning the features that are used as split variables, or by computing model-agnostic feature importance (@sec-interpretation) values for each feature.</span>
<span id="cb58-55"><a href="#cb58-55" aria-hidden="true" tabindex="-1"></a>Embedded methods use the feature selection that is implicitly done by some learners and directly retrieve the internally selected features from the learner.</span>
<span id="cb58-56"><a href="#cb58-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-57"><a href="#cb58-57" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb58-58"><a href="#cb58-58" aria-hidden="true" tabindex="-1"></a>The learner used in a feature importance or embedded filter is independent of learners used in subsequent modeling steps. For example, one might use feature importance of a random forest for feature selection and train a neural network on the reduced feature set.</span>
<span id="cb58-59"><a href="#cb58-59" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-60"><a href="#cb58-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-61"><a href="#cb58-61" aria-hidden="true" tabindex="-1"></a>Many filter methods are implemented in <span class="in">`r mlr3filters`</span>, for example:</span>
<span id="cb58-62"><a href="#cb58-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-63"><a href="#cb58-63" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Correlation, calculating Pearson or Spearman correlation between numeric features and numeric targets (<span class="in">`r ref("FilterCorrelation")`</span>)</span>
<span id="cb58-64"><a href="#cb58-64" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Information gain, i.e. mutual information of the feature and the target or the reduction of uncertainty of the target due to a feature (<span class="in">`r ref("FilterInformationGain")`</span>)</span>
<span id="cb58-65"><a href="#cb58-65" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Minimal joint mutual information maximization, minimizing the joint information between selected features to avoid redundancy (<span class="in">`r ref("FilterJMIM")`</span>)</span>
<span id="cb58-66"><a href="#cb58-66" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Permutation score, which calculates permutation feature importance (see <span class="co">[</span><span class="ot">@sec-interpretation</span><span class="co">]</span>) with a given learner for each feature (<span class="in">`r ref("FilterPermutation")`</span>)</span>
<span id="cb58-67"><a href="#cb58-67" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Area under the ROC curve calculated for each feature separately (<span class="in">`r ref("FilterAUC")`</span>)</span>
<span id="cb58-68"><a href="#cb58-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-69"><a href="#cb58-69" aria-hidden="true" tabindex="-1"></a>Most of the filter methods have some limitations, e.g. the correlation filter can only be calculated for regression tasks with numeric features.</span>
<span id="cb58-70"><a href="#cb58-70" aria-hidden="true" tabindex="-1"></a>For a full list of all implemented filter methods we refer the reader to the <span class="in">`r link("https://mlr3filters.mlr-org.com", "mlr3filters website")`</span>, which also shows the supported task and features types.</span>
<span id="cb58-71"><a href="#cb58-71" aria-hidden="true" tabindex="-1"></a>A benchmark of filter methods was performed by @bommert2020, who recommend to not rely on a single filter method but try several ones if the available computational resources allow.</span>
<span id="cb58-72"><a href="#cb58-72" aria-hidden="true" tabindex="-1"></a>If only a single filter method is to be used, the authors recommend to use a feature importance filter using random forest permutation importance (see <span class="co">[</span><span class="ot">@sec-fs-var-imp-filters</span><span class="co">]</span>), similar to the permutation method described above, but also the JMIM and AUC filters performed well in their comparison.</span>
<span id="cb58-73"><a href="#cb58-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-74"><a href="#cb58-74" aria-hidden="true" tabindex="-1"></a><span class="fu">### Calculating Filter Values {#sec-fs-calc}</span></span>
<span id="cb58-75"><a href="#cb58-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-76"><a href="#cb58-76" aria-hidden="true" tabindex="-1"></a>The first step is to create a new R object using the class of the desired filter method.</span>
<span id="cb58-77"><a href="#cb58-77" aria-hidden="true" tabindex="-1"></a>Similar to other instances in <span class="in">`r mlr3`</span>, these are registered in a dictionary (<span class="in">`r ref("mlr_filters")`</span>) with an associated shortcut function <span class="in">`r ref("flt()")`</span>.</span>
<span id="cb58-78"><a href="#cb58-78" aria-hidden="true" tabindex="-1"></a>Each object of class <span class="in">`Filter`</span> has a <span class="in">`$calculate()`</span> method which computes the filter values and ranks them in a descending order.</span>
<span id="cb58-79"><a href="#cb58-79" aria-hidden="true" tabindex="-1"></a>For example, we can use the information gain filter described above:</span>
<span id="cb58-80"><a href="#cb58-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-81"><a href="#cb58-81" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-001}</span></span>
<span id="cb58-82"><a href="#cb58-82" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"mlr3verse"</span>)</span>
<span id="cb58-83"><a href="#cb58-83" aria-hidden="true" tabindex="-1"></a>filter <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>)</span>
<span id="cb58-84"><a href="#cb58-84" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-85"><a href="#cb58-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-86"><a href="#cb58-86" aria-hidden="true" tabindex="-1"></a>Such a <span class="in">`Filter`</span> object can now be used to calculate the filter on the penguins data and get the results:</span>
<span id="cb58-87"><a href="#cb58-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-88"><a href="#cb58-88" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-002}</span></span>
<span id="cb58-89"><a href="#cb58-89" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-90"><a href="#cb58-90" aria-hidden="true" tabindex="-1"></a>filter<span class="sc">$</span><span class="fu">calculate</span>(task)</span>
<span id="cb58-91"><a href="#cb58-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-92"><a href="#cb58-92" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(filter)</span>
<span id="cb58-93"><a href="#cb58-93" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-94"><a href="#cb58-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-95"><a href="#cb58-95" aria-hidden="true" tabindex="-1"></a>Some filters have hyperparameters, which can be changed similar to setting hyperparameters of a <span class="in">`r ref("Learner")`</span> using <span class="in">`$param_set$values`</span>.</span>
<span id="cb58-96"><a href="#cb58-96" aria-hidden="true" tabindex="-1"></a>For example, to calculate <span class="in">`"spearman"`</span> instead of <span class="in">`"pearson"`</span> correlation with the correlation filter:</span>
<span id="cb58-97"><a href="#cb58-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-98"><a href="#cb58-98" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-003}</span></span>
<span id="cb58-99"><a href="#cb58-99" aria-hidden="true" tabindex="-1"></a>filter_cor <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"correlation"</span>)</span>
<span id="cb58-100"><a href="#cb58-100" aria-hidden="true" tabindex="-1"></a>filter_cor<span class="sc">$</span>param_set<span class="sc">$</span>values <span class="ot">=</span> <span class="fu">list</span>(<span class="at">method =</span> <span class="st">"spearman"</span>)</span>
<span id="cb58-101"><a href="#cb58-101" aria-hidden="true" tabindex="-1"></a>filter_cor<span class="sc">$</span>param_set</span>
<span id="cb58-102"><a href="#cb58-102" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-103"><a href="#cb58-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-104"><a href="#cb58-104" aria-hidden="true" tabindex="-1"></a>As noted above, the correlation filter can only be calculated for regression tasks with numeric features and can thus not be used with the penguins data.</span>
<span id="cb58-105"><a href="#cb58-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-106"><a href="#cb58-106" aria-hidden="true" tabindex="-1"></a><span class="fu">### Feature Importance Filters {#sec-fs-var-imp-filters}</span></span>
<span id="cb58-107"><a href="#cb58-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-108"><a href="#cb58-108" aria-hidden="true" tabindex="-1"></a>To use feature importance filters, we can use a learner with integrated feature importance methods.</span>
<span id="cb58-109"><a href="#cb58-109" aria-hidden="true" tabindex="-1"></a>All learners with the property "importance" have this functionality.</span>
<span id="cb58-110"><a href="#cb58-110" aria-hidden="true" tabindex="-1"></a>A list of all learners with this property can be found with</span>
<span id="cb58-111"><a href="#cb58-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-112"><a href="#cb58-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-004}</span></span>
<span id="cb58-113"><a href="#cb58-113" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(mlr_learners)[<span class="fu">sapply</span>(properties, <span class="cf">function</span>(x) <span class="st">"importance"</span> <span class="sc">%in%</span> x)]</span>
<span id="cb58-114"><a href="#cb58-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-115"><a href="#cb58-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-116"><a href="#cb58-116" aria-hidden="true" tabindex="-1"></a>or on the <span class="in">`r link("https://mlr-org.com/learners.html", "mlr3 website")`</span>.</span>
<span id="cb58-117"><a href="#cb58-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-118"><a href="#cb58-118" aria-hidden="true" tabindex="-1"></a>For some learners, the desired filter method needs to be set during learner creation.</span>
<span id="cb58-119"><a href="#cb58-119" aria-hidden="true" tabindex="-1"></a>For example, learner <span class="in">`r ref("mlr_learners_classif.ranger", text = "classif.ranger")`</span> comes with multiple integrated methods, c.f. the help page of <span class="in">`r ref("ranger::ranger()")`</span>.</span>
<span id="cb58-120"><a href="#cb58-120" aria-hidden="true" tabindex="-1"></a>To use the feature importance method "impurity", select it during learner construction:</span>
<span id="cb58-121"><a href="#cb58-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-122"><a href="#cb58-122" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-005}</span></span>
<span id="cb58-123"><a href="#cb58-123" aria-hidden="true" tabindex="-1"></a>lrn <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.ranger"</span>, <span class="at">importance =</span> <span class="st">"impurity"</span>)</span>
<span id="cb58-124"><a href="#cb58-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-125"><a href="#cb58-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-126"><a href="#cb58-126" aria-hidden="true" tabindex="-1"></a>We first have to remove missing data because the learner cannot handle missing data, i.e. it does not have the property "missing":</span>
<span id="cb58-127"><a href="#cb58-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-128"><a href="#cb58-128" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-006}</span></span>
<span id="cb58-129"><a href="#cb58-129" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-130"><a href="#cb58-130" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span><span class="fu">filter</span>(<span class="fu">which</span>(<span class="fu">complete.cases</span>(task<span class="sc">$</span><span class="fu">data</span>())))</span>
<span id="cb58-131"><a href="#cb58-131" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-132"><a href="#cb58-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-133"><a href="#cb58-133" aria-hidden="true" tabindex="-1"></a>Now we can use the <span class="in">`r ref("mlr_filters_importance", text = "FilterImportance")`</span> filter class:</span>
<span id="cb58-134"><a href="#cb58-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-135"><a href="#cb58-135" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-006-2}</span></span>
<span id="cb58-136"><a href="#cb58-136" aria-hidden="true" tabindex="-1"></a>filter <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"importance"</span>, <span class="at">learner =</span> lrn)</span>
<span id="cb58-137"><a href="#cb58-137" aria-hidden="true" tabindex="-1"></a>filter<span class="sc">$</span><span class="fu">calculate</span>(task)</span>
<span id="cb58-138"><a href="#cb58-138" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(filter)</span>
<span id="cb58-139"><a href="#cb58-139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-140"><a href="#cb58-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-141"><a href="#cb58-141" aria-hidden="true" tabindex="-1"></a><span class="fu">### Embedded Methods {#sec-fs-embedded-methods}</span></span>
<span id="cb58-142"><a href="#cb58-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-143"><a href="#cb58-143" aria-hidden="true" tabindex="-1"></a>Many learners internally select a subset of the features which they find helpful for prediction, but ignore other features.</span>
<span id="cb58-144"><a href="#cb58-144" aria-hidden="true" tabindex="-1"></a>For example, a decision tree might never select some features for splitting.</span>
<span id="cb58-145"><a href="#cb58-145" aria-hidden="true" tabindex="-1"></a>These subsets can be used for feature selection, which we call embedded methods because the feature selection is embedded in the learner.</span>
<span id="cb58-146"><a href="#cb58-146" aria-hidden="true" tabindex="-1"></a>The selected features (and those not selected) can be queried if the learner has the <span class="in">`"selected_features"`</span> property.</span>
<span id="cb58-147"><a href="#cb58-147" aria-hidden="true" tabindex="-1"></a>As above, we can find those learners with</span>
<span id="cb58-148"><a href="#cb58-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-149"><a href="#cb58-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-007}</span></span>
<span id="cb58-150"><a href="#cb58-150" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(mlr_learners)[<span class="fu">sapply</span>(properties, <span class="cf">function</span>(x) <span class="st">"selected_features"</span> <span class="sc">%in%</span> x)]</span>
<span id="cb58-151"><a href="#cb58-151" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-152"><a href="#cb58-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-153"><a href="#cb58-153" aria-hidden="true" tabindex="-1"></a>or on the <span class="in">`r link("https://mlr-org.com/learners.html", "mlr3 website")`</span>.</span>
<span id="cb58-154"><a href="#cb58-154" aria-hidden="true" tabindex="-1"></a>For example, we can use the <span class="in">`r ref("mlr_learners_classif.rpart", text = "classif.rpart")`</span> learner.</span>
<span id="cb58-155"><a href="#cb58-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-156"><a href="#cb58-156" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-007-2}</span></span>
<span id="cb58-157"><a href="#cb58-157" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-158"><a href="#cb58-158" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb58-159"><a href="#cb58-159" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span><span class="fu">train</span>(task)</span>
<span id="cb58-160"><a href="#cb58-160" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span><span class="fu">selected_features</span>()</span>
<span id="cb58-161"><a href="#cb58-161" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-162"><a href="#cb58-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-163"><a href="#cb58-163" aria-hidden="true" tabindex="-1"></a>The features selected by the model can be extracted by a <span class="in">`Filter`</span> object, where <span class="in">`$calculate()`</span> corresponds to training the learner on the given task:</span>
<span id="cb58-164"><a href="#cb58-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-165"><a href="#cb58-165" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-008}</span></span>
<span id="cb58-166"><a href="#cb58-166" aria-hidden="true" tabindex="-1"></a>filter <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"selected_features"</span>, <span class="at">learner =</span> learner)</span>
<span id="cb58-167"><a href="#cb58-167" aria-hidden="true" tabindex="-1"></a>filter<span class="sc">$</span><span class="fu">calculate</span>(task)</span>
<span id="cb58-168"><a href="#cb58-168" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(filter)</span>
<span id="cb58-169"><a href="#cb58-169" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-170"><a href="#cb58-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-171"><a href="#cb58-171" aria-hidden="true" tabindex="-1"></a>Contrary to other filter methods, embedded methods just return value of 1 (selected features) and 0 (dropped feature).</span>
<span id="cb58-172"><a href="#cb58-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-173"><a href="#cb58-173" aria-hidden="true" tabindex="-1"></a><span class="fu">### Filter-based Feature Selection {#sec-fs-filter-based}</span></span>
<span id="cb58-174"><a href="#cb58-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-175"><a href="#cb58-175" aria-hidden="true" tabindex="-1"></a>After calculating a score for each feature, one has to select the features to be kept or those to be dropped from further modeling steps.</span>
<span id="cb58-176"><a href="#cb58-176" aria-hidden="true" tabindex="-1"></a>For the <span class="in">`"selected_features"`</span> filter described in embedded methods (@sec-fs-embedded-methods), this step is straight-forward since the methods assigns either a value of 1 for a feature to be kept or 0 for a feature to be dropped. Below, we find the names of features with a value of 1 and select those feature with <span class="in">`task$select()`</span>:</span>
<span id="cb58-177"><a href="#cb58-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-178"><a href="#cb58-178" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-009}</span></span>
<span id="cb58-179"><a href="#cb58-179" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-180"><a href="#cb58-180" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb58-181"><a href="#cb58-181" aria-hidden="true" tabindex="-1"></a>filter <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"selected_features"</span>, <span class="at">learner =</span> learner)</span>
<span id="cb58-182"><a href="#cb58-182" aria-hidden="true" tabindex="-1"></a>filter<span class="sc">$</span><span class="fu">calculate</span>(task)</span>
<span id="cb58-183"><a href="#cb58-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-184"><a href="#cb58-184" aria-hidden="true" tabindex="-1"></a><span class="co"># select all features used by rpart</span></span>
<span id="cb58-185"><a href="#cb58-185" aria-hidden="true" tabindex="-1"></a>keep <span class="ot">=</span> <span class="fu">names</span>(<span class="fu">which</span>(filter<span class="sc">$</span>scores <span class="sc">==</span> <span class="dv">1</span>))</span>
<span id="cb58-186"><a href="#cb58-186" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span><span class="fu">select</span>(keep)</span>
<span id="cb58-187"><a href="#cb58-187" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span>feature_names</span>
<span id="cb58-188"><a href="#cb58-188" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-189"><a href="#cb58-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-190"><a href="#cb58-190" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb58-191"><a href="#cb58-191" aria-hidden="true" tabindex="-1"></a>To select features, we use the function <span class="in">`task$select()`</span> and not <span class="in">`task$filter()`</span>, which is used to filter rows (not columns) of the data matrix, see task mutators (@sec-tasks-mutators).</span>
<span id="cb58-192"><a href="#cb58-192" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-193"><a href="#cb58-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-194"><a href="#cb58-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-195"><a href="#cb58-195" aria-hidden="true" tabindex="-1"></a>For filter methods which assign continuous scores, there are essentially two ways to select features:</span>
<span id="cb58-196"><a href="#cb58-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-197"><a href="#cb58-197" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>select the top $k$ features, or</span>
<span id="cb58-198"><a href="#cb58-198" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>select all features with a score above a threshold $\tau$,</span>
<span id="cb58-199"><a href="#cb58-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-200"><a href="#cb58-200" aria-hidden="true" tabindex="-1"></a>where the first option is equivalent to dropping the bottom $p-k$ features.</span>
<span id="cb58-201"><a href="#cb58-201" aria-hidden="true" tabindex="-1"></a>For both options, one has to decide on a threshold, which is often quite arbitrary.</span>
<span id="cb58-202"><a href="#cb58-202" aria-hidden="true" tabindex="-1"></a>For example, to implement the first option with the information gain filter:</span>
<span id="cb58-203"><a href="#cb58-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-204"><a href="#cb58-204" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-010}</span></span>
<span id="cb58-205"><a href="#cb58-205" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-206"><a href="#cb58-206" aria-hidden="true" tabindex="-1"></a>filter <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>)</span>
<span id="cb58-207"><a href="#cb58-207" aria-hidden="true" tabindex="-1"></a>filter<span class="sc">$</span><span class="fu">calculate</span>(task)</span>
<span id="cb58-208"><a href="#cb58-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-209"><a href="#cb58-209" aria-hidden="true" tabindex="-1"></a><span class="co"># select top 3 features from information gain filter</span></span>
<span id="cb58-210"><a href="#cb58-210" aria-hidden="true" tabindex="-1"></a>keep <span class="ot">=</span> <span class="fu">names</span>(<span class="fu">head</span>(filter<span class="sc">$</span>scores, <span class="dv">3</span>))</span>
<span id="cb58-211"><a href="#cb58-211" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span><span class="fu">select</span>(keep)</span>
<span id="cb58-212"><a href="#cb58-212" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span>feature_names</span>
<span id="cb58-213"><a href="#cb58-213" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-214"><a href="#cb58-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-215"><a href="#cb58-215" aria-hidden="true" tabindex="-1"></a>Or, the second option with $\tau = 0.5$:</span>
<span id="cb58-216"><a href="#cb58-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-217"><a href="#cb58-217" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-011}</span></span>
<span id="cb58-218"><a href="#cb58-218" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-219"><a href="#cb58-219" aria-hidden="true" tabindex="-1"></a>filter <span class="ot">=</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>)</span>
<span id="cb58-220"><a href="#cb58-220" aria-hidden="true" tabindex="-1"></a>filter<span class="sc">$</span><span class="fu">calculate</span>(task)</span>
<span id="cb58-221"><a href="#cb58-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-222"><a href="#cb58-222" aria-hidden="true" tabindex="-1"></a><span class="co"># select all features with score &gt;0.5 from information gain filter</span></span>
<span id="cb58-223"><a href="#cb58-223" aria-hidden="true" tabindex="-1"></a>keep <span class="ot">=</span> <span class="fu">names</span>(<span class="fu">which</span>(filter<span class="sc">$</span>scores <span class="sc">&gt;</span> <span class="fl">0.5</span>))</span>
<span id="cb58-224"><a href="#cb58-224" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span><span class="fu">select</span>(keep)</span>
<span id="cb58-225"><a href="#cb58-225" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span>feature_names</span>
<span id="cb58-226"><a href="#cb58-226" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-227"><a href="#cb58-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-228"><a href="#cb58-228" aria-hidden="true" tabindex="-1"></a>Filters can be integrated into pipelines.</span>
<span id="cb58-229"><a href="#cb58-229" aria-hidden="true" tabindex="-1"></a>Pipelines define machine learning workflows in graphs and by that greatly simplify the combination of different steps such as preprocessing operations, resampling or ensemble learning.</span>
<span id="cb58-230"><a href="#cb58-230" aria-hidden="true" tabindex="-1"></a>While pipelines are described in detail in @sec-pipelines, here is a brief preview where filter-based feature selection is combined with a learner:</span>
<span id="cb58-231"><a href="#cb58-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-232"><a href="#cb58-232" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-012}</span></span>
<span id="cb58-233"><a href="#cb58-233" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3pipelines)</span>
<span id="cb58-234"><a href="#cb58-234" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-235"><a href="#cb58-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-236"><a href="#cb58-236" aria-hidden="true" tabindex="-1"></a><span class="co"># combine filter (keep top 3 features) with learner</span></span>
<span id="cb58-237"><a href="#cb58-237" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"filter"</span>, <span class="at">filter =</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>), <span class="at">filter.nfeat =</span> <span class="dv">3</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb58-238"><a href="#cb58-238" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"learner"</span>, <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>))</span>
<span id="cb58-239"><a href="#cb58-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-240"><a href="#cb58-240" aria-hidden="true" tabindex="-1"></a><span class="co"># now it can be used as any learner, but it includes the feature selection</span></span>
<span id="cb58-241"><a href="#cb58-241" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">as_learner</span>(graph)</span>
<span id="cb58-242"><a href="#cb58-242" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span><span class="fu">train</span>(task)</span>
<span id="cb58-243"><a href="#cb58-243" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-244"><a href="#cb58-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-245"><a href="#cb58-245" aria-hidden="true" tabindex="-1"></a>Pipelines can also be used to apply HPO (@sec-optimization) to the filter, i.e. tune the filter threshold to optimize the feature selection regarding prediction performance, and to embed this in resampling.</span>
<span id="cb58-246"><a href="#cb58-246" aria-hidden="true" tabindex="-1"></a>We first combine a filter with a learner,</span>
<span id="cb58-247"><a href="#cb58-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-248"><a href="#cb58-248" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-013}</span></span>
<span id="cb58-249"><a href="#cb58-249" aria-hidden="true" tabindex="-1"></a>graph <span class="ot">=</span> <span class="fu">po</span>(<span class="st">"filter"</span>, <span class="at">filter =</span> <span class="fu">flt</span>(<span class="st">"information_gain"</span>)) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb58-250"><a href="#cb58-250" aria-hidden="true" tabindex="-1"></a>  <span class="fu">po</span>(<span class="st">"learner"</span>, <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>))</span>
<span id="cb58-251"><a href="#cb58-251" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">as_learner</span>(graph)</span>
<span id="cb58-252"><a href="#cb58-252" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-253"><a href="#cb58-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-254"><a href="#cb58-254" aria-hidden="true" tabindex="-1"></a>and tune how many feature to include</span>
<span id="cb58-255"><a href="#cb58-255" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-014, message=FALSE, warning=FALSE}</span></span>
<span id="cb58-256"><a href="#cb58-256" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"mlr3tuning"</span>)</span>
<span id="cb58-257"><a href="#cb58-257" aria-hidden="true" tabindex="-1"></a>ps <span class="ot">=</span> <span class="fu">ps</span>(<span class="at">information_gain.filter.nfeat =</span> <span class="fu">p_int</span>(<span class="at">lower =</span> <span class="dv">1</span>, <span class="at">upper =</span> <span class="dv">7</span>))</span>
<span id="cb58-258"><a href="#cb58-258" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> TuningInstanceSingleCrit<span class="sc">$</span><span class="fu">new</span>(</span>
<span id="cb58-259"><a href="#cb58-259" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> task,</span>
<span id="cb58-260"><a href="#cb58-260" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> learner,</span>
<span id="cb58-261"><a href="#cb58-261" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>),</span>
<span id="cb58-262"><a href="#cb58-262" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> <span class="fu">msr</span>(<span class="st">"classif.acc"</span>),</span>
<span id="cb58-263"><a href="#cb58-263" aria-hidden="true" tabindex="-1"></a>  <span class="at">search_space =</span> ps,</span>
<span id="cb58-264"><a href="#cb58-264" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"none"</span>)</span>
<span id="cb58-265"><a href="#cb58-265" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-266"><a href="#cb58-266" aria-hidden="true" tabindex="-1"></a>tuner <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"grid_search"</span>)</span>
<span id="cb58-267"><a href="#cb58-267" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb58-268"><a href="#cb58-268" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-269"><a href="#cb58-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-270"><a href="#cb58-270" aria-hidden="true" tabindex="-1"></a>The output above shows only the best result.</span>
<span id="cb58-271"><a href="#cb58-271" aria-hidden="true" tabindex="-1"></a>To show the results of all tuning steps, retrieve them from the archive of the tuning instance:</span>
<span id="cb58-272"><a href="#cb58-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-273"><a href="#cb58-273" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-015}</span></span>
<span id="cb58-274"><a href="#cb58-274" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)</span>
<span id="cb58-275"><a href="#cb58-275" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-276"><a href="#cb58-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-277"><a href="#cb58-277" aria-hidden="true" tabindex="-1"></a>We can also plot the tuning results:</span>
<span id="cb58-278"><a href="#cb58-278" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-016}</span></span>
<span id="cb58-279"><a href="#cb58-279" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-tunefilter</span></span>
<span id="cb58-280"><a href="#cb58-280" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Model performance with different numbers of features, selected by an information gain filter.</span></span>
<span id="cb58-281"><a href="#cb58-281" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Plot showing model performance in filter-based feature selection, showing that adding a second and third feature to the model improves performance, while adding more feature achieves no further performance gain.</span></span>
<span id="cb58-282"><a href="#cb58-282" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(instance)</span>
<span id="cb58-283"><a href="#cb58-283" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-284"><a href="#cb58-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-285"><a href="#cb58-285" aria-hidden="true" tabindex="-1"></a>For more details, see Pipelines (@sec-pipelines) and Hyperparameter Optimization (@sec-optimization).</span>
<span id="cb58-286"><a href="#cb58-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-287"><a href="#cb58-287" aria-hidden="true" tabindex="-1"></a><span class="fu">## Wrapper Methods {#sec-fs-wrapper}</span></span>
<span id="cb58-288"><a href="#cb58-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-289"><a href="#cb58-289" aria-hidden="true" tabindex="-1"></a>Wrapper methods work by fitting models on selected feature subsets and evaluating their performance <span class="co">[</span><span class="ot">@Kohavi1997</span><span class="co">]</span>.</span>
<span id="cb58-290"><a href="#cb58-290" aria-hidden="true" tabindex="-1"></a>This can be done in a sequential fashion, e.g. by iteratively adding features to the model in sequential forward selection, or in a parallel fashion, e.g. by evaluating random feature subsets in a random search.</span>
<span id="cb58-291"><a href="#cb58-291" aria-hidden="true" tabindex="-1"></a>Below, the use of these simple approaches is described in a common framework along with more advanced methods such as genetic search.</span>
<span id="cb58-292"><a href="#cb58-292" aria-hidden="true" tabindex="-1"></a>It is further shown how to select features by optimizing multiple performance measures and how to wrap a learner with feature selection to use it in pipelines or benchmarks.</span>
<span id="cb58-293"><a href="#cb58-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-294"><a href="#cb58-294" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb58-295"><a href="#cb58-295" aria-hidden="true" tabindex="-1"></a>In contrast to filters (@sec-fs-filter), the learner used in the wrapper feature selection is *not* independent of learners used in subsequent modeling steps.</span>
<span id="cb58-296"><a href="#cb58-296" aria-hidden="true" tabindex="-1"></a>The idea of wrapper methods is to directly include, i.e. wrap, the feature selection with the learner to optimize its performance.</span>
<span id="cb58-297"><a href="#cb58-297" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-298"><a href="#cb58-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-299"><a href="#cb58-299" aria-hidden="true" tabindex="-1"></a>In more detail, wrapper methods iteratively select features that optimize a performance measure.</span>
<span id="cb58-300"><a href="#cb58-300" aria-hidden="true" tabindex="-1"></a>Instead of ranking features, a model is fit on a selected subset of features in each iteration and evaluated in resampling with respect to a selected performance measure.</span>
<span id="cb58-301"><a href="#cb58-301" aria-hidden="true" tabindex="-1"></a>The strategy that determines which feature subset is used in each iteration is given by the <span class="in">`FSelector`</span> object.</span>
<span id="cb58-302"><a href="#cb58-302" aria-hidden="true" tabindex="-1"></a>A simple example is the sequential forward selection that starts with computing each single-feature model, selects the best one, and then iteratively adds the feature that leads to the largest performance improvement (@fig-sequential-forward-selection).</span>
<span id="cb58-303"><a href="#cb58-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-304"><a href="#cb58-304" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-003}</span></span>
<span id="cb58-305"><a href="#cb58-305" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-sequential-forward-selection</span></span>
<span id="cb58-306"><a href="#cb58-306" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Sequential Forward Selection.</span></span>
<span id="cb58-307"><a href="#cb58-307" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Sequential Forward Selection.</span></span>
<span id="cb58-308"><a href="#cb58-308" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb58-309"><a href="#cb58-309" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"Figures/mlr3book_figures-15.svg"</span>, <span class="st">"Figures/mlr3book_figures-15.png"</span>)</span>
<span id="cb58-310"><a href="#cb58-310" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"Figures/mlr3book_figures-16.svg"</span>, <span class="st">"Figures/mlr3book_figures-16.png"</span>)</span>
<span id="cb58-311"><a href="#cb58-311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-312"><a href="#cb58-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-313"><a href="#cb58-313" aria-hidden="true" tabindex="-1"></a>Wrapper methods can be used with any learner but need to train the learner potentially many times, leading to a computationally intensive method.</span>
<span id="cb58-314"><a href="#cb58-314" aria-hidden="true" tabindex="-1"></a>All wrapper methods are implemented via the package <span class="in">`r mlr3fselect`</span>.</span>
<span id="cb58-315"><a href="#cb58-315" aria-hidden="true" tabindex="-1"></a>In this chapter, we cover how to</span>
<span id="cb58-316"><a href="#cb58-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-317"><a href="#cb58-317" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>instantiate an <span class="in">`FSelector`</span> object,</span>
<span id="cb58-318"><a href="#cb58-318" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>configure it, to e.g. respect a runtime limit or for different objectives,</span>
<span id="cb58-319"><a href="#cb58-319" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>run it or fuse it with a <span class="in">`Learner`</span> via an <span class="in">`AutoFSelector`</span>.</span>
<span id="cb58-320"><a href="#cb58-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-321"><a href="#cb58-321" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb58-322"><a href="#cb58-322" aria-hidden="true" tabindex="-1"></a>Wrapper-based feature selection is very similar to HPO (@sec-optimization).</span>
<span id="cb58-323"><a href="#cb58-323" aria-hidden="true" tabindex="-1"></a>The major difference is that we search for well-performing feature subsets instead of hyperparameter configurations.</span>
<span id="cb58-324"><a href="#cb58-324" aria-hidden="true" tabindex="-1"></a>We will see below, that we can even use the same terminators, that some feature selection algorithms are similar to tuners and that we can also optimize multiple performance measures with feature selection.</span>
<span id="cb58-325"><a href="#cb58-325" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-326"><a href="#cb58-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-327"><a href="#cb58-327" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simple Forward Selection Example {#sec-fs-wrapper-example}</span></span>
<span id="cb58-328"><a href="#cb58-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-329"><a href="#cb58-329" aria-hidden="true" tabindex="-1"></a>We start with the simple example from above and do sequential forward selection with the penguins data:</span>
<span id="cb58-330"><a href="#cb58-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-331"><a href="#cb58-331" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-017, message=FALSE}</span></span>
<span id="cb58-332"><a href="#cb58-332" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"mlr3fselect"</span>)</span>
<span id="cb58-333"><a href="#cb58-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-334"><a href="#cb58-334" aria-hidden="true" tabindex="-1"></a><span class="co"># subset features to ease visualization</span></span>
<span id="cb58-335"><a href="#cb58-335" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-336"><a href="#cb58-336" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span><span class="fu">select</span>(<span class="fu">c</span>(<span class="st">"bill_depth"</span>, <span class="st">"bill_length"</span>, <span class="st">"body_mass"</span>, <span class="st">"flipper_length"</span>))</span>
<span id="cb58-337"><a href="#cb58-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-338"><a href="#cb58-338" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">fselect</span>(</span>
<span id="cb58-339"><a href="#cb58-339" aria-hidden="true" tabindex="-1"></a>  <span class="at">fselector =</span> <span class="fu">fs</span>(<span class="st">"sequential"</span>),</span>
<span id="cb58-340"><a href="#cb58-340" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span>  task,</span>
<span id="cb58-341"><a href="#cb58-341" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb58-342"><a href="#cb58-342" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>),</span>
<span id="cb58-343"><a href="#cb58-343" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> <span class="fu">msr</span>(<span class="st">"classif.acc"</span>)</span>
<span id="cb58-344"><a href="#cb58-344" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-345"><a href="#cb58-345" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-346"><a href="#cb58-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-347"><a href="#cb58-347" aria-hidden="true" tabindex="-1"></a>In contrast to HPO (@sec-optimization), <span class="in">`fselect`</span> directly starts the optimization and selects features.</span>
<span id="cb58-348"><a href="#cb58-348" aria-hidden="true" tabindex="-1"></a>To show all analyzed feature subsets and the corresponding performance, we use <span class="in">`as.data.table(instance$archive)`</span>.</span>
<span id="cb58-349"><a href="#cb58-349" aria-hidden="true" tabindex="-1"></a>In this example, the <span class="in">`batch_nr`</span> column represents the iteration of the sequential forward selection and we start by looking at the first iteration.</span>
<span id="cb58-350"><a href="#cb58-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-351"><a href="#cb58-351" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-018}</span></span>
<span id="cb58-352"><a href="#cb58-352" aria-hidden="true" tabindex="-1"></a>dt <span class="ot">=</span> <span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)</span>
<span id="cb58-353"><a href="#cb58-353" aria-hidden="true" tabindex="-1"></a>dt[batch_nr <span class="sc">==</span> <span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb58-354"><a href="#cb58-354" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-355"><a href="#cb58-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-356"><a href="#cb58-356" aria-hidden="true" tabindex="-1"></a>We see that the feature <span class="in">`flipper_length`</span> achieved the highest prediction performance in the first iteration and is thus selected.</span>
<span id="cb58-357"><a href="#cb58-357" aria-hidden="true" tabindex="-1"></a>We plot the performance over the iterations:</span>
<span id="cb58-358"><a href="#cb58-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-359"><a href="#cb58-359" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-018-5}</span></span>
<span id="cb58-360"><a href="#cb58-360" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-fowardselection</span></span>
<span id="cb58-361"><a href="#cb58-361" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Model performance in iterations of sequential forward selection.</span></span>
<span id="cb58-362"><a href="#cb58-362" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Plot showing model performance in sequential forward selection iterations, showing that adding a second feature to the model improves performance, while adding more feature achieves no further performance gain.</span></span>
<span id="cb58-363"><a href="#cb58-363" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(instance, <span class="at">type =</span> <span class="st">"performance"</span>)</span>
<span id="cb58-364"><a href="#cb58-364" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-365"><a href="#cb58-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-366"><a href="#cb58-366" aria-hidden="true" tabindex="-1"></a>In the plot, we can see that adding a second feature further improves the performance to over 90%.</span>
<span id="cb58-367"><a href="#cb58-367" aria-hidden="true" tabindex="-1"></a>To see which feature was added, we can go back to the archive and look at the second iteration:</span>
<span id="cb58-368"><a href="#cb58-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-369"><a href="#cb58-369" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-018-2}</span></span>
<span id="cb58-370"><a href="#cb58-370" aria-hidden="true" tabindex="-1"></a>dt[batch_nr <span class="sc">==</span> <span class="dv">2</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb58-371"><a href="#cb58-371" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-372"><a href="#cb58-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-373"><a href="#cb58-373" aria-hidden="true" tabindex="-1"></a>The third iteration confirms our conclusion from the plot, that adding a third feature does not improve performance:</span>
<span id="cb58-374"><a href="#cb58-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-375"><a href="#cb58-375" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-018-3}</span></span>
<span id="cb58-376"><a href="#cb58-376" aria-hidden="true" tabindex="-1"></a>dt[batch_nr <span class="sc">==</span> <span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb58-377"><a href="#cb58-377" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-378"><a href="#cb58-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-379"><a href="#cb58-379" aria-hidden="true" tabindex="-1"></a>To directly show the best feature set, we can use:</span>
<span id="cb58-380"><a href="#cb58-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-381"><a href="#cb58-381" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-019}</span></span>
<span id="cb58-382"><a href="#cb58-382" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result_feature_set</span>
<span id="cb58-383"><a href="#cb58-383" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-384"><a href="#cb58-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-385"><a href="#cb58-385" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb58-386"><a href="#cb58-386" aria-hidden="true" tabindex="-1"></a><span class="in">`instance$result_feature_set`</span> shows features in alphabetical order and not in the order selected.</span>
<span id="cb58-387"><a href="#cb58-387" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-388"><a href="#cb58-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-389"><a href="#cb58-389" aria-hidden="true" tabindex="-1"></a>Internally, the <span class="in">`fselect`</span> function creates an <span class="in">`FSelectInstanceSingleCrit`</span> object and executes the feature selection with an <span class="in">`FSelector`</span> object, based on the selected method, in this example an <span class="in">`FSelectorSequential`</span> object.</span>
<span id="cb58-390"><a href="#cb58-390" aria-hidden="true" tabindex="-1"></a>It uses the supplied resampling and measure to evaluate all feature subsets provided by the <span class="in">`FSelector`</span> on the task.</span>
<span id="cb58-391"><a href="#cb58-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-392"><a href="#cb58-392" aria-hidden="true" tabindex="-1"></a>At the heart of <span class="in">`r mlr3fselect`</span> are the R6 classes:</span>
<span id="cb58-393"><a href="#cb58-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-394"><a href="#cb58-394" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`FSelectInstanceSingleCrit`</span>, <span class="in">`FSelectInstanceMultiCrit`</span>: These two classes describe the feature selection problem and store the results.</span>
<span id="cb58-395"><a href="#cb58-395" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`FSelector`</span>: This class is the base class for implementations of feature selection algorithms.</span>
<span id="cb58-396"><a href="#cb58-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-397"><a href="#cb58-397" aria-hidden="true" tabindex="-1"></a>In the following two sections, these classes will be created manually, to learn more about the <span class="in">`r mlr3fselect`</span> package.</span>
<span id="cb58-398"><a href="#cb58-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-399"><a href="#cb58-399" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `FSelectInstance` Classes</span></span>
<span id="cb58-400"><a href="#cb58-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-401"><a href="#cb58-401" aria-hidden="true" tabindex="-1"></a>To create an <span class="in">`FSelectInstanceSingleCrit`</span> object, we use the sugar function <span class="in">`r ref("fsi")`</span>, which is short for <span class="in">`FSelectInstanceSingleCrit$new()`</span> or <span class="in">`FSelectInstanceMultiCrit$new()`</span>, depending on the selected measure(s):</span>
<span id="cb58-402"><a href="#cb58-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-403"><a href="#cb58-403" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-020}</span></span>
<span id="cb58-404"><a href="#cb58-404" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">fsi</span>(</span>
<span id="cb58-405"><a href="#cb58-405" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> task,</span>
<span id="cb58-406"><a href="#cb58-406" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb58-407"><a href="#cb58-407" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>),</span>
<span id="cb58-408"><a href="#cb58-408" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> <span class="fu">msr</span>(<span class="st">"classif.acc"</span>),</span>
<span id="cb58-409"><a href="#cb58-409" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">20</span>)</span>
<span id="cb58-410"><a href="#cb58-410" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-411"><a href="#cb58-411" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-412"><a href="#cb58-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-413"><a href="#cb58-413" aria-hidden="true" tabindex="-1"></a>Note that we have not selected a feature selection algorithm and thus did not select any features, yet.</span>
<span id="cb58-414"><a href="#cb58-414" aria-hidden="true" tabindex="-1"></a>We have also supplied a <span class="in">`Terminator`</span>, which is used to stop the feature selection.</span>
<span id="cb58-415"><a href="#cb58-415" aria-hidden="true" tabindex="-1"></a>For the forward selection in the example above, we did not need a terminator because we simply tried all remaining features until the full model (technically using <span class="in">`r ref("TerminatorNone")`</span>).</span>
<span id="cb58-416"><a href="#cb58-416" aria-hidden="true" tabindex="-1"></a>However, we could still use a terminator to stop the forward selection early.</span>
<span id="cb58-417"><a href="#cb58-417" aria-hidden="true" tabindex="-1"></a>For other feature selection algorithms such as <span class="in">`r ref("FSelectorRandomSearch", text = "random search")`</span>, a terminator is required.</span>
<span id="cb58-418"><a href="#cb58-418" aria-hidden="true" tabindex="-1"></a>The following terminator are available:</span>
<span id="cb58-419"><a href="#cb58-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-420"><a href="#cb58-420" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Terminate after a given time (<span class="in">`r ref("TerminatorClockTime")`</span>)</span>
<span id="cb58-421"><a href="#cb58-421" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Terminate after a given amount of iterations (<span class="in">`r ref("TerminatorEvals")`</span>)</span>
<span id="cb58-422"><a href="#cb58-422" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Terminate after a specific performance is reached (<span class="in">`r ref("TerminatorPerfReached")`</span>)</span>
<span id="cb58-423"><a href="#cb58-423" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Terminate when feature selection does not improve (<span class="in">`r ref("TerminatorStagnation")`</span>)</span>
<span id="cb58-424"><a href="#cb58-424" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>A combination of the above in an *ALL* or *ANY* fashion (<span class="in">`r ref("TerminatorCombo")`</span>)</span>
<span id="cb58-425"><a href="#cb58-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-426"><a href="#cb58-426" aria-hidden="true" tabindex="-1"></a>See also the description of terminators in HPO (@sec-terminator).</span>
<span id="cb58-427"><a href="#cb58-427" aria-hidden="true" tabindex="-1"></a>Above we used the sugar function <span class="in">`r ref("trm")`</span> to select <span class="in">`r ref("TerminatorEvals")`</span> with 20 evaluations.</span>
<span id="cb58-428"><a href="#cb58-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-429"><a href="#cb58-429" aria-hidden="true" tabindex="-1"></a>To start the feature selection, we still need to select an algorithm which are defined via the <span class="in">`FSelector`</span> class, described in the next section.</span>
<span id="cb58-430"><a href="#cb58-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-431"><a href="#cb58-431" aria-hidden="true" tabindex="-1"></a><span class="fu">### The `FSelector` Class</span></span>
<span id="cb58-432"><a href="#cb58-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-433"><a href="#cb58-433" aria-hidden="true" tabindex="-1"></a>The <span class="in">`FSelector`</span> class is the base class for different feature selection algorithms.</span>
<span id="cb58-434"><a href="#cb58-434" aria-hidden="true" tabindex="-1"></a>The following algorithms are currently implemented in <span class="in">`r mlr3fselect`</span>:</span>
<span id="cb58-435"><a href="#cb58-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-436"><a href="#cb58-436" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Random search, trying random feature subsets until termination (<span class="in">`r ref("FSelectorRandomSearch")`</span>)</span>
<span id="cb58-437"><a href="#cb58-437" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Exhaustive search, trying all possible feature subsets (<span class="in">`r ref("FSelectorExhaustiveSearch")`</span>)</span>
<span id="cb58-438"><a href="#cb58-438" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Sequential search, i.e. sequential forward or backward selection (<span class="in">`r ref("FSelectorSequential")`</span>)</span>
<span id="cb58-439"><a href="#cb58-439" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Recursive feature elimination, which uses learner's importance scores to iteratively remove features with low feature importance (<span class="in">`r ref("FSelectorRFE")`</span>)</span>
<span id="cb58-440"><a href="#cb58-440" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Design points, trying all user-supplied feature sets (<span class="in">`r ref("FSelectorDesignPoints")`</span>)</span>
<span id="cb58-441"><a href="#cb58-441" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Genetic search, implementing a genetic algorithm which treats the features as a binary sequence and tries to find the best subset with mutations (<span class="in">`r ref("FSelectorGeneticSearch")`</span>)</span>
<span id="cb58-442"><a href="#cb58-442" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Shadow variable search, which adds permuted copies of all features (shadow variables) and stops when a shadow variable is selected (<span class="in">`r ref("FSelectorShadowVariableSearch")`</span>)</span>
<span id="cb58-443"><a href="#cb58-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-444"><a href="#cb58-444" aria-hidden="true" tabindex="-1"></a>Note that all these methods can be stopped (early) with a terminator, e.g. an exhaustive search can be stopped after a given number of evaluations.</span>
<span id="cb58-445"><a href="#cb58-445" aria-hidden="true" tabindex="-1"></a>More details on these algorithms can be found in the respective R help pages and on the <span class="in">`r link("https://mlr3fselect.mlr-org.com", "mlr3fselect website")`</span>.</span>
<span id="cb58-446"><a href="#cb58-446" aria-hidden="true" tabindex="-1"></a>In this example, we will use a simple random search and retrieve it from the dictionary <span class="in">`r ref("mlr_fselectors")`</span> with the <span class="in">`r ref("fs()")`</span> sugar function, which is short for <span class="in">`FSelectorRandomSearch$new()`</span>:</span>
<span id="cb58-447"><a href="#cb58-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-448"><a href="#cb58-448" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-021}</span></span>
<span id="cb58-449"><a href="#cb58-449" aria-hidden="true" tabindex="-1"></a>fselector <span class="ot">=</span> <span class="fu">fs</span>(<span class="st">"random_search"</span>)</span>
<span id="cb58-450"><a href="#cb58-450" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-451"><a href="#cb58-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-452"><a href="#cb58-452" aria-hidden="true" tabindex="-1"></a><span class="fu">### Starting the Feature Selection</span></span>
<span id="cb58-453"><a href="#cb58-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-454"><a href="#cb58-454" aria-hidden="true" tabindex="-1"></a>To start the feature selection, we pass the <span class="in">`FSelectInstanceSingleCrit`</span> object to the <span class="in">`$optimize()`</span> method of the initialized <span class="in">`FSelector`</span> object:</span>
<span id="cb58-455"><a href="#cb58-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-456"><a href="#cb58-456" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-022, output=FALSE}</span></span>
<span id="cb58-457"><a href="#cb58-457" aria-hidden="true" tabindex="-1"></a>fselector<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb58-458"><a href="#cb58-458" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-459"><a href="#cb58-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-460"><a href="#cb58-460" aria-hidden="true" tabindex="-1"></a>The algorithm proceeds as follows</span>
<span id="cb58-461"><a href="#cb58-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-462"><a href="#cb58-462" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The <span class="in">`FSelector`</span> proposes at least one feature subset and may propose multiple subsets to improve parallelization, which can be controlled via the setting <span class="in">`batch_size`</span>.</span>
<span id="cb58-463"><a href="#cb58-463" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>For each feature subset, the given learner is fitted on the task using the provided resampling and evaluated with the given measure.</span>
<span id="cb58-464"><a href="#cb58-464" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>All evaluations are stored in the archive of the <span class="in">`FSelectInstanceSingleCrit`</span> object.</span>
<span id="cb58-465"><a href="#cb58-465" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The terminator is queried if the budget is exhausted. If the budget is not exhausted, restart with 1) until it is.</span>
<span id="cb58-466"><a href="#cb58-466" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Determine the feature subset with the best observed performance.</span>
<span id="cb58-467"><a href="#cb58-467" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Store the best feature subset as the result in the instance object.</span>
<span id="cb58-468"><a href="#cb58-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-469"><a href="#cb58-469" aria-hidden="true" tabindex="-1"></a>The best feature subset and the corresponding measured performance can be accessed from the instance:</span>
<span id="cb58-470"><a href="#cb58-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-471"><a href="#cb58-471" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-023}</span></span>
<span id="cb58-472"><a href="#cb58-472" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.table</span>(instance<span class="sc">$</span>result)[, .(features, classif.acc)]</span>
<span id="cb58-473"><a href="#cb58-473" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-474"><a href="#cb58-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-475"><a href="#cb58-475" aria-hidden="true" tabindex="-1"></a>As in the forward selection example above, one can investigate all resamplings which were undertaken, as they are stored in the archive of the <span class="in">`FSelectInstanceSingleCrit`</span> object and can be accessed by using <span class="in">`as.data.table()`</span>:</span>
<span id="cb58-476"><a href="#cb58-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-477"><a href="#cb58-477" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-024}</span></span>
<span id="cb58-478"><a href="#cb58-478" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)[, .(bill_depth, bill_length, body_mass, flipper_length, classif.acc)]</span>
<span id="cb58-479"><a href="#cb58-479" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-480"><a href="#cb58-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-481"><a href="#cb58-481" aria-hidden="true" tabindex="-1"></a>Now the optimized feature subset can be used to subset the task and fit the model on all observations:</span>
<span id="cb58-482"><a href="#cb58-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-483"><a href="#cb58-483" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-025, eval=FALSE}</span></span>
<span id="cb58-484"><a href="#cb58-484" aria-hidden="true" tabindex="-1"></a>task <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"penguins"</span>)</span>
<span id="cb58-485"><a href="#cb58-485" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb58-486"><a href="#cb58-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-487"><a href="#cb58-487" aria-hidden="true" tabindex="-1"></a>task<span class="sc">$</span><span class="fu">select</span>(instance<span class="sc">$</span>result_feature_set)</span>
<span id="cb58-488"><a href="#cb58-488" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span><span class="fu">train</span>(task)</span>
<span id="cb58-489"><a href="#cb58-489" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-490"><a href="#cb58-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-491"><a href="#cb58-491" aria-hidden="true" tabindex="-1"></a>The trained model can now be used to make a prediction on external data.</span>
<span id="cb58-492"><a href="#cb58-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-493"><a href="#cb58-493" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb58-494"><a href="#cb58-494" aria-hidden="true" tabindex="-1"></a>Predicting on observations present in the data used for feature selection should be avoided.</span>
<span id="cb58-495"><a href="#cb58-495" aria-hidden="true" tabindex="-1"></a>The model has seen these observations already during feature selection and therefore performance evaluation results would be over-optimistic.</span>
<span id="cb58-496"><a href="#cb58-496" aria-hidden="true" tabindex="-1"></a>Instead, to get unbiased performance estimates for the current task, nested resampling (see @sec-autofselect and @sec-nested-resampling) is required.</span>
<span id="cb58-497"><a href="#cb58-497" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-498"><a href="#cb58-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-499"><a href="#cb58-499" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optimizing Multiple Performance Measures {#sec-multicrit-featsel}</span></span>
<span id="cb58-500"><a href="#cb58-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-501"><a href="#cb58-501" aria-hidden="true" tabindex="-1"></a>You might want to use multiple criteria to evaluate the performance of the feature subsets.</span>
<span id="cb58-502"><a href="#cb58-502" aria-hidden="true" tabindex="-1"></a>For example, you might want to select the subset with the highest classification accuracy and lowest time to train the model.</span>
<span id="cb58-503"><a href="#cb58-503" aria-hidden="true" tabindex="-1"></a>However, these two subsets will generally not coincide, i.e. the subset with highest classification accuracy will probably be another subset than that with lowest training time.</span>
<span id="cb58-504"><a href="#cb58-504" aria-hidden="true" tabindex="-1"></a>With <span class="in">`r mlr3fselect`</span>, the result is the pareto-optimal solution, i.e. the best feature subset for each of the criteria that is not dominated by another subset.</span>
<span id="cb58-505"><a href="#cb58-505" aria-hidden="true" tabindex="-1"></a>For the example with classification accuracy and training time, a feature subset that is best in accuracy *and* training time will dominate all other subsets and thus will be the only pareto-optimal solution.</span>
<span id="cb58-506"><a href="#cb58-506" aria-hidden="true" tabindex="-1"></a>If, however, different subsets are best in the two criteria, both subsets are pareto-optimal.</span>
<span id="cb58-507"><a href="#cb58-507" aria-hidden="true" tabindex="-1"></a>Again, we point out the similarity with HPO and refer to multi-objective hyperparameter optimization (see @sec-multi-metrics-tuning and @karl2022).</span>
<span id="cb58-508"><a href="#cb58-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-509"><a href="#cb58-509" aria-hidden="true" tabindex="-1"></a>In the following example, we will perform feature selection on the sonar dataset. This time, we will use <span class="in">`r ref("FSelectInstanceMultiCrit")`</span> to select a subset of features that has high sensitivity, i.e. TPR, and high specificity, i.e. TNR. The feature selection process with multiple criteria is similar to that with a single criterion, except that we select two measures to be optimized:</span>
<span id="cb58-510"><a href="#cb58-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-511"><a href="#cb58-511" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-026}</span></span>
<span id="cb58-512"><a href="#cb58-512" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">fsi</span>(</span>
<span id="cb58-513"><a href="#cb58-513" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> <span class="fu">tsk</span>(<span class="st">"sonar"</span>),</span>
<span id="cb58-514"><a href="#cb58-514" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb58-515"><a href="#cb58-515" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>),</span>
<span id="cb58-516"><a href="#cb58-516" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> <span class="fu">msrs</span>(<span class="fu">c</span>(<span class="st">"classif.tpr"</span>, <span class="st">"classif.tnr"</span>)),</span>
<span id="cb58-517"><a href="#cb58-517" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">20</span>)</span>
<span id="cb58-518"><a href="#cb58-518" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-519"><a href="#cb58-519" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-520"><a href="#cb58-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-521"><a href="#cb58-521" aria-hidden="true" tabindex="-1"></a>The function <span class="in">`r ref("fsi")`</span> creates an instance of <span class="in">`FSelectInstanceMultiCrit`</span> if more than one measure is selected.</span>
<span id="cb58-522"><a href="#cb58-522" aria-hidden="true" tabindex="-1"></a>We now create an <span class="in">`FSelector`</span> and call the <span class="in">`$optimize()`</span> function of the <span class="in">`FSelector`</span> with the <span class="in">`FSelectInstanceMultiCrit`</span> object, to search for the subset of features with the best TPR and FPR.</span>
<span id="cb58-523"><a href="#cb58-523" aria-hidden="true" tabindex="-1"></a>Note that these two measures cannot both be optimal at the same time (except for the perfect classifier) and we expect several pareto-optimal solutions.</span>
<span id="cb58-524"><a href="#cb58-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-525"><a href="#cb58-525" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-027, output=FALSE}</span></span>
<span id="cb58-526"><a href="#cb58-526" aria-hidden="true" tabindex="-1"></a>fselector <span class="ot">=</span> <span class="fu">fs</span>(<span class="st">"random_search"</span>)</span>
<span id="cb58-527"><a href="#cb58-527" aria-hidden="true" tabindex="-1"></a>fselector<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb58-528"><a href="#cb58-528" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-529"><a href="#cb58-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-530"><a href="#cb58-530" aria-hidden="true" tabindex="-1"></a>As above, the best feature subsets and the corresponding measured performance can be accessed from the instance.</span>
<span id="cb58-531"><a href="#cb58-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-532"><a href="#cb58-532" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-029}</span></span>
<span id="cb58-533"><a href="#cb58-533" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>result)[, .(features, classif.tpr, classif.tnr)]</span>
<span id="cb58-534"><a href="#cb58-534" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-535"><a href="#cb58-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-536"><a href="#cb58-536" aria-hidden="true" tabindex="-1"></a>We see different tradeoffs of sensitivity and specificity but no feature subset is dominated by another, i.e. has worse sensitivity *and* specificity than any other subset.</span>
<span id="cb58-537"><a href="#cb58-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-538"><a href="#cb58-538" aria-hidden="true" tabindex="-1"></a><span class="fu">### Automating the Feature Selection and Nested Resampling {#sec-autofselect}</span></span>
<span id="cb58-539"><a href="#cb58-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-540"><a href="#cb58-540" aria-hidden="true" tabindex="-1"></a>The <span class="in">`AutoFSelector`</span> class wraps a learner and augments it with an automatic feature selection for a given task.</span>
<span id="cb58-541"><a href="#cb58-541" aria-hidden="true" tabindex="-1"></a>Because the <span class="in">`AutoFSelector`</span> itself inherits from the <span class="in">`r ref("Learner")`</span> base class, it can be used like any other learner.</span>
<span id="cb58-542"><a href="#cb58-542" aria-hidden="true" tabindex="-1"></a>Below, a new learner is created.</span>
<span id="cb58-543"><a href="#cb58-543" aria-hidden="true" tabindex="-1"></a>This learner is then wrapped in a random search feature selector, which automatically starts a feature selection on the given task using an inner resampling, as soon as the wrapped learner is trained.</span>
<span id="cb58-544"><a href="#cb58-544" aria-hidden="true" tabindex="-1"></a>Here, the function <span class="in">`r ref("auto_fselector")`</span> creates an instance of <span class="in">`AutoFSelector`</span>, i.e. it is short for <span class="in">`AutoFSelector$new()`</span>.</span>
<span id="cb58-545"><a href="#cb58-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-546"><a href="#cb58-546" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-030}</span></span>
<span id="cb58-547"><a href="#cb58-547" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_fselector</span>(</span>
<span id="cb58-548"><a href="#cb58-548" aria-hidden="true" tabindex="-1"></a>  <span class="at">fselector =</span> <span class="fu">fs</span>(<span class="st">"random_search"</span>),</span>
<span id="cb58-549"><a href="#cb58-549" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.log_reg"</span>),</span>
<span id="cb58-550"><a href="#cb58-550" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>),</span>
<span id="cb58-551"><a href="#cb58-551" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> <span class="fu">msr</span>(<span class="st">"classif.acc"</span>),</span>
<span id="cb58-552"><a href="#cb58-552" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">10</span>)</span>
<span id="cb58-553"><a href="#cb58-553" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-554"><a href="#cb58-554" aria-hidden="true" tabindex="-1"></a>at</span>
<span id="cb58-555"><a href="#cb58-555" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-556"><a href="#cb58-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-557"><a href="#cb58-557" aria-hidden="true" tabindex="-1"></a>We can now, as with any other learner, call the <span class="in">`$train()`</span> and <span class="in">`$predict()`</span> method.</span>
<span id="cb58-558"><a href="#cb58-558" aria-hidden="true" tabindex="-1"></a>This time however, we pass it to <span class="in">`r ref("benchmark()")`</span> to compare the optimized feature subset to the complete feature set.</span>
<span id="cb58-559"><a href="#cb58-559" aria-hidden="true" tabindex="-1"></a>This way, the <span class="in">`AutoFSelector`</span> will do its resampling for feature selection on the training set of the respective split of the outer resampling.</span>
<span id="cb58-560"><a href="#cb58-560" aria-hidden="true" tabindex="-1"></a>The learner then undertakes predictions using the test set of the outer resampling.</span>
<span id="cb58-561"><a href="#cb58-561" aria-hidden="true" tabindex="-1"></a>Here, the outer resampling refers to the resampling specified in <span class="in">`benchmark()`</span>, whereas the inner resampling is that specified in <span class="in">`auto_fselector()`</span>.</span>
<span id="cb58-562"><a href="#cb58-562" aria-hidden="true" tabindex="-1"></a>This is called nested resampling (see @sec-nested-resampling) and yields unbiased performance measures, as the observations in the test set have not been used during feature selection or fitting of the respective learner.</span>
<span id="cb58-563"><a href="#cb58-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-564"><a href="#cb58-564" aria-hidden="true" tabindex="-1"></a>In the call to <span class="in">`benchmark()`</span>, we compare our wrapped learner <span class="in">`at`</span> with a normal logistic regression <span class="in">`lrn("classif.log_reg")`</span>.</span>
<span id="cb58-565"><a href="#cb58-565" aria-hidden="true" tabindex="-1"></a>For that, we create a benchmark grid with the task, the learners and a 3-fold cross validation on the <span class="in">`r ref("mlr_tasks_sonar", text = "sonar")`</span> data.</span>
<span id="cb58-566"><a href="#cb58-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-567"><a href="#cb58-567" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-031, warning=FALSE}</span></span>
<span id="cb58-568"><a href="#cb58-568" aria-hidden="true" tabindex="-1"></a>grid <span class="ot">=</span> <span class="fu">benchmark_grid</span>(</span>
<span id="cb58-569"><a href="#cb58-569" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> <span class="fu">tsk</span>(<span class="st">"sonar"</span>),</span>
<span id="cb58-570"><a href="#cb58-570" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">list</span>(at, <span class="fu">lrn</span>(<span class="st">"classif.log_reg"</span>)),</span>
<span id="cb58-571"><a href="#cb58-571" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>)</span>
<span id="cb58-572"><a href="#cb58-572" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-573"><a href="#cb58-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-574"><a href="#cb58-574" aria-hidden="true" tabindex="-1"></a>bmr <span class="ot">=</span> <span class="fu">benchmark</span>(grid)</span>
<span id="cb58-575"><a href="#cb58-575" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-576"><a href="#cb58-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-577"><a href="#cb58-577" aria-hidden="true" tabindex="-1"></a>Now, we compare those two learners regarding classification accuracy and training time:</span>
<span id="cb58-578"><a href="#cb58-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-579"><a href="#cb58-579" aria-hidden="true" tabindex="-1"></a><span class="in">```{r feature-selection-032}</span></span>
<span id="cb58-580"><a href="#cb58-580" aria-hidden="true" tabindex="-1"></a>aggr <span class="ot">=</span> bmr<span class="sc">$</span><span class="fu">aggregate</span>(<span class="fu">msrs</span>(<span class="fu">c</span>(<span class="st">"classif.acc"</span>, <span class="st">"time_train"</span>)))</span>
<span id="cb58-581"><a href="#cb58-581" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(aggr)[, .(learner_id, classif.acc, time_train)]</span>
<span id="cb58-582"><a href="#cb58-582" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb58-583"><a href="#cb58-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-584"><a href="#cb58-584" aria-hidden="true" tabindex="-1"></a>We can see that, in this example, the feature selection improves prediction performance but also drastically increases the training time, since the feature selection (including resampling and random search) is part of the model training of the wrapped learner.</span>
<span id="cb58-585"><a href="#cb58-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-586"><a href="#cb58-586" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb58-587"><a href="#cb58-587" aria-hidden="true" tabindex="-1"></a>For wrapper methods, we use the <span class="in">`AutoFSelector`</span> to wrap a learner with feature selection, whereas in @sec-fs-filter-based we used pipelines to combine learner and feature selection filter.</span>
<span id="cb58-588"><a href="#cb58-588" aria-hidden="true" tabindex="-1"></a>The difference is that a filter is independent of the learner and can thus be calculated as a preprocessing operator before training a learner, while a wrapper is inseparable from the learner, as it needs to train the learner in each iteration with a different feature subset.</span>
<span id="cb58-589"><a href="#cb58-589" aria-hidden="true" tabindex="-1"></a>Nevertheless, both approaches can be integrated into pipelines.</span>
<span id="cb58-590"><a href="#cb58-590" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb58-591"><a href="#cb58-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-592"><a href="#cb58-592" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb58-593"><a href="#cb58-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-594"><a href="#cb58-594" aria-hidden="true" tabindex="-1"></a>In this chapter, we learned how to perform feature selection with <span class="in">`mlr3`</span>.</span>
<span id="cb58-595"><a href="#cb58-595" aria-hidden="true" tabindex="-1"></a>We introduced filter and wrapper methods, combined feature selection with pipelines, learned how to automate the feature selection and covered the optimization of multiple performance measures.</span>
<span id="cb58-596"><a href="#cb58-596" aria-hidden="true" tabindex="-1"></a>@tbl-api-feature-selection gives an overview of the most important functions (S3) and classes (R6) used in this chapter.</span>
<span id="cb58-597"><a href="#cb58-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-598"><a href="#cb58-598" aria-hidden="true" tabindex="-1"></a>| S3 function | R6 Class | Summary |</span>
<span id="cb58-599"><a href="#cb58-599" aria-hidden="true" tabindex="-1"></a>| --- | --- | --- |</span>
<span id="cb58-600"><a href="#cb58-600" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("flt()")`</span>   | <span class="in">`r ref("Filter")`</span> | Selects features by calculating a score for each feature |</span>
<span id="cb58-601"><a href="#cb58-601" aria-hidden="true" tabindex="-1"></a>| <span class="in">`Filter$calculate()`</span>   | <span class="in">`r ref("Filter")`</span> | Calculates scores on a given task |</span>
<span id="cb58-602"><a href="#cb58-602" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("fselect()")`</span> | <span class="in">`r ref("FSelectInstanceSingleCrit")`</span> or  <span class="in">`r ref("FSelectInstanceMultiCrit")`</span> | Specifies a feature selection problem and stores the results |</span>
<span id="cb58-603"><a href="#cb58-603" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("fs()")`</span> | <span class="in">`r ref("FSelector")`</span> | Specifies a feature selection algorithm |</span>
<span id="cb58-604"><a href="#cb58-604" aria-hidden="true" tabindex="-1"></a>| <span class="in">`FSelector$optimize()`</span> | <span class="in">`r ref("FSelector")`</span> | Executes the features selection specified by the <span class="in">`FSelectInstance`</span> with the algorithm specified by the <span class="in">`FSelector`</span> |</span>
<span id="cb58-605"><a href="#cb58-605" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("auto_fselector()")`</span> | <span class="in">`r ref("AutoFSelector")`</span> | Defines a learner that includes feature selection |</span>
<span id="cb58-606"><a href="#cb58-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-607"><a href="#cb58-607" aria-hidden="true" tabindex="-1"></a>:Core S3 'sugar' functions for feature selection in mlr3 with the underlying R6 class that are constructed when these functions are called (if applicable) and a summary of the purpose of the functions. {#tbl-api-feature-selection}</span>
<span id="cb58-608"><a href="#cb58-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-609"><a href="#cb58-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-610"><a href="#cb58-610" aria-hidden="true" tabindex="-1"></a><span class="fu">### Resources{.unnumbered .unlisted}</span></span>
<span id="cb58-611"><a href="#cb58-611" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>A list of implemented filters in the <span class="in">`r mlr3filters`</span> package is provided on the <span class="in">`r link("https://mlr3filters.mlr-org.com", "mlr3filters website")`</span>.</span>
<span id="cb58-612"><a href="#cb58-612" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>A summary of wrapper-based feature selection with the <span class="in">`r mlr3fselect`</span> package is provided in the <span class="in">`r link("https://cheatsheets.mlr-org.com/mlr3fselect.pdf", "mlr3fselect cheatsheet")`</span>.</span>
<span id="cb58-613"><a href="#cb58-613" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>An overview of feature selection methods is provided by @chandrashekar2014.</span>
<span id="cb58-614"><a href="#cb58-614" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>A more formal and detailed introduction to filters and wrappers is given in @guyon2003.</span>
<span id="cb58-615"><a href="#cb58-615" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>@bommert2020 perform a benchmark of filter methods.</span>
<span id="cb58-616"><a href="#cb58-616" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Filters can be used as part of a machine learning pipeline (@sec-pipelines).</span>
<span id="cb58-617"><a href="#cb58-617" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Filters can be optimized with HPO (@sec-optimization).</span>
<span id="cb58-618"><a href="#cb58-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-619"><a href="#cb58-619" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercises</span></span>
<span id="cb58-620"><a href="#cb58-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-621"><a href="#cb58-621" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Calculate a correlation filter on the <span class="in">`r ref("mlr_tasks_mtcars", text = "Motor Trend")`</span> dataset (<span class="in">`mtcars`</span>).</span>
<span id="cb58-622"><a href="#cb58-622" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Use the filter from the first exercise to select the five best features in the <span class="in">`mtcars`</span> dataset.</span>
<span id="cb58-623"><a href="#cb58-623" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Apply a backward selection to the <span class="in">`r ref("mlr_tasks_penguins", text = "penguins")`</span> dataset with a classification tree learner <span class="in">`"classif.rpart"`</span> and holdout resampling by the measure classification accuracy. Compare the results with those in @sec-fs-wrapper-example. Answer the following questions:</span>
<span id="cb58-624"><a href="#cb58-624" aria-hidden="true" tabindex="-1"></a>    a. Do the selected features differ?</span>
<span id="cb58-625"><a href="#cb58-625" aria-hidden="true" tabindex="-1"></a>    b. Which feature selection method achieves a higher classification accuracy?</span>
<span id="cb58-626"><a href="#cb58-626" aria-hidden="true" tabindex="-1"></a>    c. Are the accuracy values in b) directly comparable? If not, what has to be changed to make them comparable?</span>
<span id="cb58-627"><a href="#cb58-627" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Automate the feature selection as in @sec-autofselect with the <span class="in">`r ref("mlr_tasks_sonar", text = "sonar")`</span> dataset and a logistic regression learner (<span class="in">`"classif.log_reg"`</span>). Hint: Remember to call <span class="in">`library("mlr3learners")`</span> for the logistic regression learner.</span>
<span id="cb58-628"><a href="#cb58-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-629"><a href="#cb58-629" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb58-630"><a href="#cb58-630" aria-hidden="true" tabindex="-1"></a><span class="in">`r citeas(chapter)`</span></span>
<span id="cb58-631"><a href="#cb58-631" aria-hidden="true" tabindex="-1"></a>:::</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">All content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> <br> © Bernd Bischl, Raphael Sonabend, Lars Kotthoff, Michel Lang.</div>   
    <div class="nav-footer-center"><a href="https://mlr-org.com">Website</a> | <a href="https://github.com/mlr-org/mlr3book">GitHub</a> | <a href="https://mlr-org.com/gallery">Gallery</a> | <a href="https://lmmisld-lmu-stats-slds.srv.mwn.de/mlr_invite/">Mattermost</a></div>
    <div class="nav-footer-right">Built with <a href="https://quarto.org/">Quarto</a>.</div>
  </div>
</footer>


<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>