<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.272">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Applied Machine Learning Using mlr3 in R - 4&nbsp; Hyperparameter Optimization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" rel="next">
<link href="../../chapters/chapter3/evaluation_and_benchmarking.html" rel="prev">
<link href="../../Figures/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script><style>html{ scroll-behavior: smooth; }</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body class="nav-sidebar floating slimcontent">


<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html">Tuning and Feature Selection</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter4/hyperparameter_optimization.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Applied Machine Learning Using mlr3 in R</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mlr-org/mlr3book/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../Applied-Machine-Learning-Using-mlr3-in-R.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/introduction_and_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction and Overview</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false">
 <span class="menu-text">Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/data_and_basic_modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data and Basic Modeling</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Tuning and Feature Selection</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter4/hyperparameter_optimization.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter6/feature_selection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Pipelines and Preprocessing</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter7/sequential_pipelines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter9/preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Preprocessing</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Advanced Topics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter10/advanced_technical_aspects_of_mlr3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Advanced Technical Aspects of mlr3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter11/large-scale_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Large-Scale Benchmarking</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter12/model_interpretation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Model Interpretation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter13/beyond_regression_and_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Beyond Regression and Classification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter14/algorithmic_fairness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Algorithmic Fairness</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/citation_information.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Citation Information</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/session_info.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Session Info</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/solutions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Solutions to exercises</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/tasks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Tasks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/overview-tables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Overview Tables</span></span></a>
  </div>
</li>
          <li class="px-0"><hr class="sidebar-divider hi "></li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Table of contents</h2>
   
  <ul>
<li>
<a href="#sec-model-tuning" id="toc-sec-model-tuning" class="nav-link active" data-scroll-target="#sec-model-tuning"><span class="header-section-number">4.1</span> Model Tuning</a>
  <ul class="collapse">
<li><a href="#sec-learner-search-space" id="toc-sec-learner-search-space" class="nav-link" data-scroll-target="#sec-learner-search-space"><span class="header-section-number">4.1.1</span> Learner and Search Space</a></li>
  <li><a href="#sec-terminator" id="toc-sec-terminator" class="nav-link" data-scroll-target="#sec-terminator"><span class="header-section-number">4.1.2</span> Terminator</a></li>
  <li><a href="#sec-tuning-instance" id="toc-sec-tuning-instance" class="nav-link" data-scroll-target="#sec-tuning-instance"><span class="header-section-number">4.1.3</span> Tuning Instance with <code>ti</code></a></li>
  <li><a href="#sec-tuner" id="toc-sec-tuner" class="nav-link" data-scroll-target="#sec-tuner"><span class="header-section-number">4.1.4</span> Tuner</a></li>
  <li><a href="#sec-logarithmic-transformations" id="toc-sec-logarithmic-transformations" class="nav-link" data-scroll-target="#sec-logarithmic-transformations"><span class="header-section-number">4.1.5</span> Logarithmic Transformations</a></li>
  <li><a href="#sec-analyzing-result" id="toc-sec-analyzing-result" class="nav-link" data-scroll-target="#sec-analyzing-result"><span class="header-section-number">4.1.6</span> Analyzing and Using the Result</a></li>
  </ul>
</li>
  <li><a href="#sec-autotuner" id="toc-sec-autotuner" class="nav-link" data-scroll-target="#sec-autotuner"><span class="header-section-number">4.2</span> Automating with <code>tune</code> and <code>auto_tuner</code></a></li>
  <li>
<a href="#sec-nested-resampling" id="toc-sec-nested-resampling" class="nav-link" data-scroll-target="#sec-nested-resampling"><span class="header-section-number">4.3</span> Nested Resampling</a>
  <ul class="collapse">
<li><a href="#resampling-an-autotuner" id="toc-resampling-an-autotuner" class="nav-link" data-scroll-target="#resampling-an-autotuner"><span class="header-section-number">4.3.1</span> Resampling an <code>AutoTuner</code></a></li>
  <li><a href="#sec-resample-overfitting" id="toc-sec-resample-overfitting" class="nav-link" data-scroll-target="#sec-resample-overfitting"><span class="header-section-number">4.3.2</span> The Right (and Wrong) Way to Estimate Generalization Performance</a></li>
  </ul>
</li>
  <li>
<a href="#sec-defining-search-spaces" id="toc-sec-defining-search-spaces" class="nav-link" data-scroll-target="#sec-defining-search-spaces"><span class="header-section-number">4.4</span> More Advanced Search Spaces</a>
  <ul class="collapse">
<li><a href="#scalar-parameter-tuning" id="toc-scalar-parameter-tuning" class="nav-link" data-scroll-target="#scalar-parameter-tuning"><span class="header-section-number">4.4.1</span> Scalar Parameter Tuning</a></li>
  <li><a href="#sec-tune-ps" id="toc-sec-tune-ps" class="nav-link" data-scroll-target="#sec-tune-ps"><span class="header-section-number">4.4.2</span> Defining Search Spaces with <code>ps</code></a></li>
  <li><a href="#sec-tune-trafo" id="toc-sec-tune-trafo" class="nav-link" data-scroll-target="#sec-tune-trafo"><span class="header-section-number">4.4.3</span> Transformations and Tuning Over Vectors</a></li>
  <li><a href="#sec-optimization-depends" id="toc-sec-optimization-depends" class="nav-link" data-scroll-target="#sec-optimization-depends"><span class="header-section-number">4.4.4</span> Hyperparameter Dependencies</a></li>
  <li><a href="#sec-tuning-spaces" id="toc-sec-tuning-spaces" class="nav-link" data-scroll-target="#sec-tuning-spaces"><span class="header-section-number">4.4.5</span> Recommended Search Spaces with <code>mlr3tuningspaces</code></a></li>
  </ul>
</li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">4.5</span> Conclusion</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">4.6</span> Exercises</a></li>
  <li><a href="#citation" id="toc-citation" class="nav-link" data-scroll-target="#citation"><span class="header-section-number">4.7</span> Citation</a></li>
  </ul><div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter4/hyperparameter_optimization.qmd" class="toc-action">Edit this page</a></p><p><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action">Report an issue</a></p><p><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter4/hyperparameter_optimization.qmd" class="toc-action">View source</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-optimization" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header><p><strong>Marc Becker</strong> <br><em>Ludwig-Maximilians-Universität München</em></p>
<p><strong>Lennart Schneider</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML)</em></p>
<p><strong>Sebastian Fischer</strong> <br><em>Ludwig-Maximilians-Universität München</em> <br><br></p>
<div class="page-columns page-full"><p>Machine learning algorithms usually include parameters and hyperparameters. Parameters are the model coefficients or weights or other information that are determined by the learning algorithm based on the training data. In contrast, hyperparameters, are configured by the user and determine how the model will fit its parameters, i.e., how the model is built. Examples include setting the number of trees in a random forest, penalty settings in support vector machines, or the learning rate in a neural network.</p><div class="no-row-height column-margin column-container"><span class="">Hyperparameters</span></div></div>
<div class="page-columns page-full"><p>The goal of hyperparameter optimization (HPO, see <a href="#sec-model-tuning"><span class="quarto-unresolved-ref">sec-model-tuning</span></a>) or model tuning is to find the optimal configuration of hyperparameters of a machine learning algorithm for a given task. There is no closed-form mathematical representation (nor analytic gradient information) for model agnostic HPO. Instead, we follow a black-box optimization approach: a machine learning algorithm is configured with values chosen for one or more hyperparameters, this algorithm is then evaluated (using a resampling method) and its performance is measured. This process is repeated with multiple configurations and finally the configuration with the best performance is selected. HPO closely relates to model evaluation (<a href="#sec-performance"><span class="quarto-unresolved-ref">sec-performance</span></a>) as the objective is to find a hyperparameter configuration that optimizes the generalization performance. Broadly speaking, we could think of finding the optimal model configuration in the same way as selecting a model from a benchmark experiment, where in this case each model in the experiment is the same algorithm but with different hyperparameter configurations. For example, we could benchmark three support vector machines (SVMs) with three difference <code>cost</code> values. However, human trial-and-error is time-consuming, subjective and often biased, error-prone, and computationally inefficient. Instead, many sophisticated hyperparameter optimization methods (<a href="#sec-tuner"><span class="quarto-unresolved-ref">sec-tuner</span></a>) (or ‘tuners’) have been developed over the past few decades for robust and efficient HPO. Besides simple approaches such as a random search or grid search, most hyperparameter optimization methods employ iterative techniques that propose different configurations over time, often exhibiting adaptive behavior guided towards potentially optimal hyperparameter configurations. These methods continually propose new configurations until a termination criterion is met, at which point the optimal configuration is returned. This iterative approach is depicted in a typical optimization loop as shown in Figure (<a href="#fig-optimization-loop">Figure&nbsp;<span class="quarto-unresolved-ref">fig-optimization-loop</span></a>). For more general details on HPO and more theoretical background, we recommend <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="#ref-hpo_practical" role="doc-biblioref">2023</a>)</span> and <span class="citation" data-cites="hpo_automl">Feurer and Hutter (<a href="#ref-hpo_automl" role="doc-biblioref">2019</a>)</span>.</p><div class="no-row-height column-margin column-container"><span class="">Hyperparameter Optimization</span></div></div>
<!-- FIXME: The line from "Evaluate by Resampling" to a "Terminator" should be an arrow -->
<div class="cell" data-hash="hyperparameter_optimization_cache/html/fig-optimization-loop_06ef8c9978d8f26a38f2240ee14cf060">
<div class="cell-output-display">
<div id="fig-optimization-loop" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="Figures/mlr3book_figures-9.svg" class="quarto-discovered-preview-image img-fluid figure-img" alt="Diagram showing 13 boxes representing model-agnostic HPO.  On the top are two boxes, one that says  &quot;Search Space&quot; and the other &quot;Tuner&quot;, these are connected by a line to &quot;Propose Hyperparameter Configurations&quot;. That box has an arrow pointing towards another box &quot;Evaluate by Resampling&quot;, which has four blue boxes pointing towards it  &quot;Task&quot;, &quot;Learner&quot;, &quot;Resampling&quot;, and &quot;Measure&quot;. &quot;Evaluate by Resampling&quot; has one line below it connected to &quot;Objective&quot;, and an arrow to the right connected to &quot;Terminator&quot;. This &quot;Terminator&quot; box has an arrow pointing down to &quot;Optimal Hyperparameter Configuration&quot; and right to &quot;Update Tuner&quot;. Finally the &quot;Update Tuner&quot; box has a line below it connecting to &quot;Archive&quot; and an arrow above it connecting back to &quot;Propose Hyperparameter Configurations&quot;."></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.1: Representation of the hyperparameter optimization loop in mlr3tuning. Blue - Hyperparameter optimization loop. Purple - Objects of the tuning instance supplied by the user. Blue-Green - Internally created objects of the tuning instance. Green - Optimization Algorithm.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<section id="sec-model-tuning" class="level2 page-columns page-full" data-number="4.1"><h2 data-number="4.1" class="anchored" data-anchor-id="sec-model-tuning">
<span class="header-section-number">4.1</span> Model Tuning</h2>
<p><a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a> is the hyperparameter optimization package of the <code>mlr3</code> ecosystem. At the heart of the package are the R6 classes</p>
<ul>
<li>
<a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceSingleCrit.html" class="refcode"><code>TuningInstanceSingleCrit</code></a>, which is used to construct a tuning ‘instance’, describe the optimization problem, and store the results; and</li>
<li>
<a href="https://mlr3tuning.mlr-org.com/reference/Tuner.html" class="refcode"><code>Tuner</code></a> which is used to configure and run optimization algorithms.</li>
</ul>
<p>In this section, we will cover these classes as well as other supporting functions and classes. Throughout this section, we will look at optimizing an SVM classifier from <a href="https://cran.r-project.org/package=e1071"><code>e1071</code></a> on the <code>sonar</code> dataset as a running example.</p>
<section id="sec-learner-search-space" class="level3 page-columns page-full" data-number="4.1.1"><h3 data-number="4.1.1" class="anchored" data-anchor-id="sec-learner-search-space">
<span class="header-section-number">4.1.1</span> Learner and Search Space</h3>
<p>The tuning process begins by deciding which hyperparameters to tune and what range to tune them over. The first place to start is therefore picking a learner and looking at the possible hyperparameters to tune with <code>$param_set</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-004_98524b3c08d4e29ef160f9fffb50425c">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">id</span>, <span class="va">class</span>, <span class="va">lower</span>, <span class="va">upper</span>, <span class="va">nlevels</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>               id    class lower upper nlevels
 1:     cachesize ParamDbl  -Inf   Inf     Inf
 2: class.weights ParamUty    NA    NA     Inf
 3:         coef0 ParamDbl  -Inf   Inf     Inf
 4:          cost ParamDbl     0   Inf     Inf
 5:         cross ParamInt     0   Inf     Inf
---                                           
12:            nu ParamDbl  -Inf   Inf     Inf
13:         scale ParamUty    NA    NA     Inf
14:     shrinking ParamLgl    NA    NA       2
15:     tolerance ParamDbl     0   Inf     Inf
16:          type ParamFct    NA    NA       2</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>Given infinite resources, we could tune all hyperparameters jointly, but in reality that is not possible, so usually only a subset of hyperparameters can be tuned. This subset is referred to as the search space or tuning space. In this example we will tune the numeric regularization and kernel width hyperparameters, <code>cost</code> and <code>gamma</code>; see the help page for <a href="https://www.rdocumentation.org/packages/e1071/topics/svm" class="refcode"><code>e1071::svm()</code></a> for full details on the model implementation including hyperparameters. In practice, search spaces are usually more complex and can require expert knowledge to define them. <a href="#sec-defining-search-spaces"><span class="quarto-unresolved-ref">sec-defining-search-spaces</span></a> provides more detailed insight into the creation of tuning spaces, including using <a href="https://mlr3tuningspaces.mlr-org.com"><code>mlr3tuningspaces</code></a> to load search spaces that have been established in published scientific articles.</p><div class="no-row-height column-margin column-container"><span class="">Search Space</span></div></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In rare cases parameter sets may include hyperparameters that cannot be tuned. These will usually be ‘technical’ (or ‘control’) parameters that provide information about <em>how</em> the model is being fit but do not control the training process itself, for example the <code>verbose</code> hyperparameter in <code>lrn("classif.ranger")</code> controls how much information is displayed to the user during training.</p>
</div>
</div>
<p>For numeric hyperparameters (we will explore others later) one must specify the bounds to tune over. We do this by constructing a learner and using <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a> to set the lower and upper limits for the parameters we want to tune. This function allows us to mark the hyperparameter for subsequent tuning in the specified range.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-006_f41afa2c99b02c5688c18ad4f09d1342">
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  type  <span class="op">=</span> <span class="st">"C-classification"</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">learner</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;LearnerClassifSVM:classif.svm&gt;
* Model: -
* Parameters: type=C-classification, kernel=radial,
  cost=&lt;RangeTuneToken&gt;, gamma=&lt;RangeTuneToken&gt;
* Packages: mlr3, mlr3learners, e1071
* Predict Types:  [response], prob
* Feature Types: logical, integer, numeric
* Properties: multiclass, twoclass</code></pre>
</div>
</div>
<p>Here we have constructed a classification SVM, <code>lrn("classif.svm")</code>, selected the type of model as <code>"C-classification"</code>, set the kernel to <code>"radial"</code>, and specified that we plan to tune the <code>cost</code> and <code>gamma</code> parameters over the range <span class="math inline">\([0.1,100000]\)</span> and <span class="math inline">\([0.1,1]\)</span> respectively (though these are usually tuned on a log scale, see <a href="#sec-logarithmic-transformations"><span class="quarto-unresolved-ref">sec-logarithmic-transformations</span></a>). Note that calling <code>$train()</code> on a learner with a tune token (e.g., <code>cost=&lt;RangeTuneToken&gt;</code>) will throw an error.</p>
<p>Now we have decided which hyperparameters to tune, we must now specify when to stop the tuning process.</p>
</section><section id="sec-terminator" class="level3" data-number="4.1.2"><h3 data-number="4.1.2" class="anchored" data-anchor-id="sec-terminator">
<span class="header-section-number">4.1.2</span> Terminator</h3>
<p><code>mlr3tuning</code> includes many methods to specify when to terminate an algorithm (<a href="#tbl-terms">Table&nbsp;<span class="quarto-unresolved-ref">tbl-terms</span></a>), which are implemented in <a href="https://bbotk.mlr-org.com/reference/Terminator.html" class="refcode"><code>Terminator</code></a> classes. Terminators are stored in the <a href="https://bbotk.mlr-org.com/reference/mlr_terminators.html" class="refcode"><code>mlr_terminators</code></a> dictionary and are constructed with the sugar function <a href="https://bbotk.mlr-org.com/reference/trm.html" class="refcode"><code>trm()</code></a>.</p>
<div id="tbl-terms" class="anchored">
<table class="table">
<caption>Table&nbsp;4.1: Terminators available in <code>mlr3tuning</code>, their function call and default parameters. A complete and up-to-date list can be found at <a href="https://mlr-org.com/terminators.html">https://mlr-org.com/terminators.html</a>.</caption>
<thead><tr class="header">
<th>Terminator</th>
<th>Function call and default parameters</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Clock Time</td>
<td><code>trm("clock_time", stop_time = "2022-11-06 08:42:53 CET")</code></td>
</tr>
<tr class="even">
<td>Combo</td>
<td><code>trm("combo", terminators = list(run_time_100, evals_200, any = TRUE))</code></td>
</tr>
<tr class="odd">
<td>None</td>
<td><code>trm("none")</code></td>
</tr>
<tr class="even">
<td>Number of Evaluations</td>
<td><code>trm("evals", n_evals = 500)</code></td>
</tr>
<tr class="odd">
<td>Performance Level</td>
<td><code>trm("perf_reached", level = 0.1)</code></td>
</tr>
<tr class="even">
<td>Run Time</td>
<td><code>trm("run_time", secs = 100)</code></td>
</tr>
<tr class="odd">
<td>Stagnation</td>
<td><code>trm("stagnation", iters = 5, threshold = 1e-5)</code></td>
</tr>
</tbody>
</table>
</div>
<p>The most commonly used terminators are those that stop the tuning after a certain time (<code>trm("run_time")</code>) or the number of evaluations (<code>trm("evals")</code>). Choosing a runtime is often based on practical considerations and intuition. Using a time limit can be important on compute clusters where a maximum runtime for a compute job may need to be specified. The <code>trm("perf_reached")</code> terminator stops the tuning when a certain performance level is reached, which can be helpful if a certain performance is seen as sufficient for the practical use of the model, however if this is set too optimistically the tuning may never terminate. The <code>trm("stagnation")</code> terminator stops when no progress is made for a number of iterations. The minimum progress is specified by the <code>threshold</code> argument, note this can be difficult to select as the optimization could stop too soon for complex search spaces despite room for (possibly significant) improvement. <code>trm("none")</code> is used for tuners that control termination themselves. Finally, any of these terminators can be freely combined with the <code>trm("combo")</code> terminator, which can be used to specify if HPO finishes when any (<code>any = TRUE</code>) terminator is triggered or when all (<code>any = FALSE</code>) are triggered.</p>
</section><section id="sec-tuning-instance" class="level3 page-columns page-full" data-number="4.1.3"><h3 data-number="4.1.3" class="anchored" data-anchor-id="sec-tuning-instance">
<span class="header-section-number">4.1.3</span> Tuning Instance with <code>ti</code>
</h3>
<p>The tuning instance collects together the tuner-agnostic information required to optimize a model, i.e., all information about the tuning process, except for the tuning algorithm itself. This includes the task to tune over, the learner to tune, the resampling method and measure used to analytically compare hyperparameter optimization configurations, and the terminator to determine when the measure has been optimized ‘enough’.</p>
<div class="page-columns page-full"><p>A tuning instance can be constructed manually with the <a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a> function, or automated (<a href="#sec-simplified-tuning"><span class="quarto-unresolved-ref">sec-simplified-tuning</span></a>) with the <a href="https://mlr3tuning.mlr-org.com/reference/tune.html" class="refcode"><code>tune()</code></a> function. We cover the manual approach first as this allows finer control of tuning and a more nuanced discussion about the design and use of <code>mlr3tuning</code>.</p><div class="no-row-height column-margin column-container"><span class="">Tuning Instance</span></div></div>
<p>Continuing our example, we will construct a single-objective tuning problem (i.e., tuning over <em>one</em> measure) by using the <code><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti()</a></code> function to create a <a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceSingleCrit.html" class="refcode"><code>TuningInstanceSingleCrit</code></a>, we will return to multi-objective tuning in <a href="#sec-multi-metrics-tuning"><span class="quarto-unresolved-ref">sec-multi-metrics-tuning</span></a>.</p>
<p>For this example we will use three-fold CV and optimize the classification error measure. Note that in the next section we will continue our example with a grid search tuner, so we select <code>trm("none")</code>.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-007_8515309f1837ec9b0bc30395b09fa273">
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_sonar</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"sonar"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">ti</span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">learner</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu">trm</span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;TuningInstanceSingleCrit&gt;
* State:  Not optimized
* Objective: &lt;ObjectiveTuning:classif.svm_on_sonar&gt;
* Search Space:
      id    class lower upper nlevels
1:  cost ParamDbl   0.1 1e+05     Inf
2: gamma ParamDbl   0.1 1e+00     Inf
* Terminator: &lt;TerminatorNone&gt;</code></pre>
</div>
</div>
</section><section id="sec-tuner" class="level3 page-columns page-full" data-number="4.1.4"><h3 data-number="4.1.4" class="anchored" data-anchor-id="sec-tuner">
<span class="header-section-number">4.1.4</span> Tuner</h3>
<p>With all the pieces of our tuning problem assembled, we can now decide <em>how</em> to tune our model. There are multiple <a href="https://mlr3tuning.mlr-org.com/reference/Tuner.html" class="refcode"><code>Tuner</code></a> classes in <code>mlr3tuning</code>, which implement different HPO (or more generally speaking black-box optimization) algorithms (<a href="#tbl-tuners">Table&nbsp;<span class="quarto-unresolved-ref">tbl-tuners</span></a>).</p>
<div id="tbl-tuners" class="anchored">
<table class="table">
<caption>Table&nbsp;4.2: Tuning algorithms available in <code>mlr3tuning</code>, their function call and the package in which the algorithm is implemented. A complete and up-to-date list can be found at <a href="https://mlr-org.com/tuners.html">https://mlr-org.com/tuners.html</a>.</caption>
<thead><tr class="header">
<th>Tuner</th>
<th>Function call</th>
<th>Package</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Random Search</td>
<td><code>tnr("random_search")</code></td>
<td><a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a></td>
</tr>
<tr class="even">
<td>Grid Search</td>
<td><code>tnr("grid_search")</code></td>
<td><a href="https://mlr3tuning.mlr-org.com"><code>mlr3tuning</code></a></td>
</tr>
<tr class="odd">
<td>Bayesian Optimization</td>
<td><code>tnr("mbo")</code></td>
<td><a href="https://mlr3mbo.mlr-org.com"><code>mlr3mbo</code></a></td>
</tr>
<tr class="even">
<td>CMA-ES</td>
<td><code>tnr("cmaes")</code></td>
<td><a href="https://cran.r-project.org/package=adagio"><code>adagio</code></a></td>
</tr>
<tr class="odd">
<td>Iterative Racing</td>
<td><code>tnr("irace")</code></td>
<td><a href="https://cran.r-project.org/package=irace"><code>irace</code></a></td>
</tr>
<tr class="even">
<td>Hyperband</td>
<td><code>tnr("hyperband")</code></td>
<td><a href="https://mlr3hyperband.mlr-org.com"><code>mlr3hyperband</code></a></td>
</tr>
<tr class="odd">
<td>Generalized Simulated Annealing</td>
<td><code>tnr("gensa")</code></td>
<td><a href="https://cran.r-project.org/package=GenSA"><code>GenSA</code></a></td>
</tr>
<tr class="even">
<td>Nonlinear Optimization</td>
<td><code>tnr("nloptr")</code></td>
<td><a href="https://cran.r-project.org/package=nloptr"><code>nloptr</code></a></td>
</tr>
</tbody>
</table>
</div>
<section id="search-strategies" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="search-strategies">Search strategies</h4>
<p>Grid search and random search <span class="citation" data-cites="bergstra2012">(<a href="#ref-bergstra2012" role="doc-biblioref">Bergstra and Bengio 2012</a>)</span> are the most basic algorithms and are often selected first in initial experiments. The idea of grid search is to exhaustively evaluate every possible combination of given hyperparameter values. Categorical hyperparameters are usually evaluated over all possible values they can take while values to consider for numeric hyperparameters are determined by a given resolution, which is the number of distinct values to try per hyperparameter. Numeric and integer hyperparameters are spaced equidistantly in their box constraints (upper and lower bounds), and categorical hyperparameters usually have all possible values considered. Random search involves randomly selecting values for each hyperparameter independently from a pre-specified distribution, usually uniform. Both methods are non-adaptive, which means each proposed configuration ignores the performance of previous configurations. Due to their simplicity, both grid search and random search can handle mixed search spaces (i.e., hyperparameters can be numeric, integer, or categorical) as well as hierarchical search spaces (<a href="#sec-defining-search-spaces"><span class="quarto-unresolved-ref">sec-defining-search-spaces</span></a>).</p>
</section><section id="adaptive-algorithms" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="adaptive-algorithms">Adaptive algorithms</h4>
<p>Adaptive algorithms learn from previously evaluated configurations to find good configurations more quickly, examples in <a href="https://mlr3.mlr-org.com"><code>mlr3</code></a> include Bayesian optimization (also called model-based optimization), Covariance Matrix Adaptation Evolution Strategy (CMA-ES), Iterative Racing, and Hyperband.</p>
<!-- FIXME - It might make sense to shorten this once I've read MBO if there's a lot of duplication -->
<p>Bayesian optimization (<a href="#sec-bayesian-optimization"><span class="quarto-unresolved-ref">sec-bayesian-optimization</span></a>) <span class="citation" data-cites="Snoek2012">(e.g., <a href="#ref-Snoek2012" role="doc-biblioref">Snoek, Larochelle, and Adams 2012</a>)</span> describes a family of iterative optimization algorithms that use a surrogate model to approximate the unknown function that is to be optimized – in HPO the mapping from a hyperparameter configuration to the estimated generalization performance. Any Bayesian optimization algorithm starts by observing an initial design of observations and then trains the surrogate model on all data points and performance values observed so far. The algorithm then uses an acquisition function that usually relies on both the mean and variance prediction of the surrogate model to determine which points of the search space are promising candidates that should be evaluated next. By optimizing the acquisition function itself, the next candidate point is chosen for evaluation, evaluated and the process repeats itself by re-fitting or updating the surrogate model on the updated set of observed data points. Bayesian optimization is very flexible (e.g.&nbsp;mixed and hierarchical search spaces can easily be handled by choosing a suitable surrogate model), and highly sample efficient, i.e., compared to other algorithms, much less function evaluations are needed to find good configurations. On the downside, the optimization overhead of Bayesian optimization is comparably large (e.g., in each iteration, training of the surrogate model and optimizing the acquisition function) and therefore really shines in the context of very costly function evaluations and tight optimization budget.</p>
<p>CMA-ES <span class="citation" data-cites="hansen2011">(<a href="#ref-hansen2011" role="doc-biblioref">Hansen and Auger 2011</a>)</span> is an evolutionary strategy that maintains a probability distribution over candidate points, with the distribution represented by a mean vector and covariance matrix. A new set of candidate points is generated by sampling from this distribution, with the probability of each candidate being proportional to its performance. The covariance matrix is adapted over time to reflect the performance landscape.</p>
<p>Racing algorithms work by iteratively discarding configurations that show poor performance, as determined by statistical tests. Iterative Racing <span class="citation" data-cites="lopez2016">(<a href="#ref-lopez2016" role="doc-biblioref">López-Ibáñez et al. 2016</a>)</span> starts by ‘racing’ down an initial population of randomly sampled configurations from a parameterized density and then uses the surviving configurations of the race to stochastically update the density of the subsequent race to focus on promising regions of the search space, and so on.</p>
<p>Multi-fidelity HPO is an adaptive method that leverages the predictive power of computationally cheap lower fidelity evaluations (i.e., poorer quality predictions such as those arising from neural networks with a small number of epochs) to improve the overall optimization efficiency. This concept is used in Hyperband (<a href="#sec-hyperband"><span class="quarto-unresolved-ref">sec-hyperband</span></a>), a popular multi-fidelity hyperparameter optimization algorithm that dynamically allocates increasingly more resources to promising configurations and terminates low-performing ones. Hyperband tends to outperform random search as the optimization budget is used much more efficiently.</p>
<p>Other implemented algorithms for numeric search spaces are Generalized Simulated Annealing <span class="citation" data-cites="xiang2013 tsallis1996">(<a href="#ref-xiang2013" role="doc-biblioref">Xiang et al. 2013</a>; <a href="#ref-tsallis1996" role="doc-biblioref">Tsallis and Stariolo 1996</a>)</span> and various nonlinear optimization algorithms. These can be useful if evaluations are rather cheap as they require more function evaluations and are therefore less sample efficient than other sophisticated methods (e.g., bayesian optimization) but are more commonly used for general, numeric black-box optimization.</p>
</section><section id="choosing-strategies" class="level4 unnumbered unlisted page-columns page-full"><h4 class="unnumbered unlisted anchored" data-anchor-id="choosing-strategies">Choosing strategies</h4>
<p>As a rule of thumb, if the search space is small and consists of categorical hyperparameters, a grid search may be able to exhaustively evaluate the entire search space in a reasonable time. However, grid search is generally not recommended due to the curse of dimensionality – the grid size ‘blows up’ very quickly as number of parameters to tune increases – and insufficient coverage of numeric search spaces. Grid search by construction also cannot evaluate a large number of unique values per hyperparameter, which is suboptimal when some hyperparameters have minimal impact on performance while others do.</p>
<p>In such scenarios, a random search is often a better choice as it considers more unique values per hyperparameter compared to grid search. Random search is also suitable for small optimization budgets and quick concept experiments. However, with larger optimization budgets, more guided optimization algorithms such as evolutionary strategies or Bayesian optimization tend to perform better and are more likely to result in peak performance. Evolutionary strategies are available in <code>mlr3</code> via the <a href="https://cran.r-project.org/package=miesmuschel"><code>miesmuschel</code></a> package, however these will not be covered in this book.</p>
<p>When choosing between evolutionary strategies and Bayesian optimization, the cost of function evaluation is highly relevant. If hyperparameter configurations can be evaluated quickly, evolutionary strategies often find good configurations within a reasonable time frame. On the other hand, if model evaluations are time-consuming and the optimization budget is limited, Bayesian optimization is usually preferred, this will be covered in <a href="#sec-bayesian-optimization"><span class="quarto-unresolved-ref">sec-bayesian-optimization</span></a>.</p>
<p>Finally, in cases where the hyperparameter optimization problem involves a meaningful fidelity parameter (e.g., number of epochs, number of trees, number of boosting rounds) and optimization budget needs to be spent efficiently, multi-fidelity hyperparameter optimization algorithms like Hyperband may be worth considering. For further details on different tuners and practical recommendations, we refer to <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="#ref-hpo_practical" role="doc-biblioref">2023</a>)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <code>$param_classes</code> and <code>$properties</code> fields of a <code>Tuner</code> respectively provide information about which classes of hyperparameters can be handled and what properties the tuner can handle (e.g., hyperparameter dependencies (<a href="#sec-defining-search-spaces"><span class="quarto-unresolved-ref">sec-defining-search-spaces</span></a>)):</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-3_0869147138d22c31336800c87488adbb">
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span><span class="op">$</span><span class="va">param_classes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "ParamLgl" "ParamInt" "ParamDbl" "ParamFct"</code></pre>
</div>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span><span class="op">$</span><span class="va">properties</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "dependencies" "single-crit"  "multi-crit"  </code></pre>
</div>
</div>
</div>
</div>
<p>For our SVM example, we will use a grid search with a resolution of 5 for efficiency reasons here (in practice a larger resolution would be preferred). Recall that the resolution is the number of distinct values to try <em>per hyperparameter</em>, which means in our example the tuner will construct a 5x5 grid of 25 configurations of equally spaced points between the specified upper and lower bounds. All configurations will be tried by the tuner (in random order) until either all configurations are evaluated or the terminator (<a href="#sec-terminator"><span class="quarto-unresolved-ref">sec-terminator</span></a>) signals that the budget is exhausted. For grid and random search tuners, the <code>batch_size</code> parameter controls how many configurations are evaluated at the same time (see <a href="#sec-parallelization"><span class="quarto-unresolved-ref">sec-parallelization</span></a>) and also determines how many configurations should be applied before the terminator should check if the termination criterion has been reached.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-008_d3124c7592a725940b8781f2c54d5825">
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tuner</span> <span class="op">=</span> <span class="fu">tnr</span><span class="op">(</span><span class="st">"grid_search"</span>, resolution <span class="op">=</span> <span class="fl">5</span>, batch_size <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">tuner</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;TunerGridSearch&gt;: Grid Search
* Parameters: resolution=5, batch_size=10
* Parameter classes: ParamLgl, ParamInt, ParamDbl, ParamFct
* Properties: dependencies, single-crit, multi-crit
* Packages: mlr3tuning</code></pre>
</div>
</div>
<div class="page-columns page-full"><p>The <code>resolution</code> and <code>batch_size</code> parameters are termed control parameters, and other tuners will have other parameters that can be set, as with learners these are accessible with <code>$param_set</code>.</p><div class="no-row-height column-margin column-container"><span class="">Control Parameters</span></div></div>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-009_72858a980b697413ae7bcd3fdb392dea">
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tuner</span><span class="op">$</span><span class="va">param_set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
                  id    class lower upper nlevels        default value
1:        batch_size ParamInt     1   Inf     Inf &lt;NoDefault[3]&gt;    10
2:        resolution ParamInt     1   Inf     Inf &lt;NoDefault[3]&gt;     5
3: param_resolutions ParamUty    NA    NA     Inf &lt;NoDefault[3]&gt;      </code></pre>
</div>
</div>
<p>Whilst changing the control parameters of the tuner can improve optimal performance, it is likely the default settings will fit most needs.</p>
</section><section id="triggering-the-tuning-process" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="triggering-the-tuning-process">Triggering the tuning process</h4>
<p>Now that we have all our components, we can start the tuning process. To do this we simply pass the constructed <a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceSingleCrit.html" class="refcode"><code>TuningInstanceSingleCrit</code></a> to the <code>$optimize()</code> method of the initialized <a href="https://mlr3tuning.mlr-org.com/reference/Tuner.html" class="refcode"><code>Tuner</code></a>, which triggers the hyperparameter optimization loop (<a href="#fig-optimization-loop">Figure&nbsp;<span class="quarto-unresolved-ref">fig-optimization-loop</span></a>).</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-010_33c49979ba7fe63dfadf895d30604fc8">
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tuner</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost gamma learner_param_vals  x_domain classif.ce
1: 25000   0.1          &lt;list[4]&gt; &lt;list[2]&gt;     0.2449</code></pre>
</div>
</div>
<p>The optimizer returns the best hyperparameter configuration and the corresponding performance, this information is also stored in <code>instance$result</code>. The first columns (here <code>cost</code> and <code>gamma</code>) will be named after the tuned hyperparameters and show the optimal values from the searched tuning spaces. The <code>$learner_param_vals</code> field lists the optimal hyperparameters from tuning, as well as the values of any other hyperparameters that were manually changed from the defaults, this is useful for onward model use (<a href="#sec-analyzing-result"><span class="quarto-unresolved-ref">sec-analyzing-result</span></a>).</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-4_673f433db22f477f8eca039e38948fb7">
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">$</span><span class="va">learner_param_vals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[[1]]$kernel
[1] "radial"

[[1]]$type
[1] "C-classification"

[[1]]$cost
[1] 25000

[[1]]$gamma
[1] 0.1</code></pre>
</div>
</div>
<p>The <code>$x_domain</code> field contains the optimal values of the tuned hyperparameters, which is most useful in the context of hyperparameter transformations, which we will briefly turn to next.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>A common mistake when tuning is to report the performance estimated on the resampling sets on which the tuning was performed (<code>instance$result$classif.ce</code>) as an estimate of the model’s performance. The correct method is to test the model on more unseen data, which can be efficiently performed with nested resampling, we will discuss this in <a href="#sec-resample-overfitting"><span class="quarto-unresolved-ref">sec-resample-overfitting</span></a>.</p>
</div>
</div>
</section></section><section id="sec-logarithmic-transformations" class="level3" data-number="4.1.5"><h3 data-number="4.1.5" class="anchored" data-anchor-id="sec-logarithmic-transformations">
<span class="header-section-number">4.1.5</span> Logarithmic Transformations</h3>
<p>For many hyperparameters that have infinite (or very large) bounds, tuning on a logarithmic scale is more efficient than tuning on a linear scale. By example, consider sampling uniformly in the interval <span class="math inline">\([log(1e-5), log(1e5)]\)</span> and then exponentiating the outcome:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-011_adee57b12a19e25915cc07b559727e35">
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">cost</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1000</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1e-5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">1e5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">exp_cost</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">cost</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The histograms below show how we are initially sampling within a narrow range (<span class="math inline">\([-11.5, 11.5]\)</span>) then exponentiating results in the majority of points being relatively small but a few being very large.</p>
<div id="fig-logscale" class="cell quarto-layout-panel" data-hash="hyperparameter_optimization_cache/html/fig-logscale_374adc3766a0f6a63ee0e06c47b5c042">
<figure class="figure"><div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-logscale-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="hyperparameter_optimization_files/figure-html/fig-logscale-1.png" class="img-fluid figure-img" alt="Histogram showing the distribution of uniformly sampled values from the interval [log(1e-5), log(1e5)]. The left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] and the right plot shows the transformed values on the logarithmic scale between [1e-5, 1e5]." data-ref-parent="fig-logscale" width="672"></p>
<p></p><figcaption class="figure-caption">(a) Values on the linear scale sampled by the tuner.</figcaption><p></p>
</figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-logscale-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="hyperparameter_optimization_files/figure-html/fig-logscale-2.png" class="img-fluid figure-img" alt="Histogram showing the distribution of uniformly sampled values from the interval [log(1e-5), log(1e5)]. The left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] and the right plot shows the transformed values on the logarithmic scale between [1e-5, 1e5]." data-ref-parent="fig-logscale" width="672"></p>
<p></p><figcaption class="figure-caption">(b) Transformed values on the logarithmic scale as seen by the learner.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.2: Histogram of uniformly sampled values from the interval <span class="math inline">\([log(1e-5), log(1e5)]\)</span>.</figcaption><p></p>
</figure>
</div>
<p>To add this transformation to a hyperparameter we simply pass <code>logscale = TRUE</code> to <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a>.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-013_65750436250ae74f62b5ce590d7c18e2">
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">ti</span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">learner</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu">trm</span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">tuner</span><span class="op">$</span><span class="fu">optimize</span><span class="op">(</span><span class="va">instance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost  gamma learner_param_vals  x_domain classif.ce
1: 5.756 -5.756          &lt;list[4]&gt; &lt;list[2]&gt;     0.1394</code></pre>
</div>
</div>
<p>We can see from this example that using the log transformation improved our model training as <code>classif.ce</code> is smaller.</p>
<p>Note that the fields <code>cost</code> and <code>gamma</code> show the optimal values <em>before</em> transformation, whereas <code>x_domain</code> and <code>learner_param_vals</code> contain optimal values <em>after</em> transformation, it is these latter fields you would take forward for future model use.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-014_7c014e814a5db6883acb860375b5716d">
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span><span class="op">$</span><span class="va">result</span><span class="op">$</span><span class="va">x_domain</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[[1]]$cost
[1] 316.2

[[1]]$gamma
[1] 0.003162</code></pre>
</div>
</div>
<p>In <a href="#sec-search-space-scratch"><span class="quarto-unresolved-ref">sec-search-space-scratch</span></a> we will look at how to implement more complex, custom transformations to any hyperparameter or combination of hyperparameters. Now we will look at how to put everything into practice so we can make use of the tuned model (and the transformed hyperparameters).</p>
</section><section id="sec-analyzing-result" class="level3" data-number="4.1.6"><h3 data-number="4.1.6" class="anchored" data-anchor-id="sec-analyzing-result">
<span class="header-section-number">4.1.6</span> Analyzing and Using the Result</h3>
<p>Independently of whether you use <a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/tune.html" class="refcode"><code>tune()</code></a>, or if you include transformations or not, the output is the same and the instance’s archive lists all evaluated hyperparameter configurations:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-016_45822c7d002b428473a9d59a601267a8">
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       cost   gamma classif.ce
 1: -11.513  -5.756     0.4665
 2:  -5.756 -11.513     0.4665
 3:  -5.756  11.513     0.4665
 4:   0.000  -5.756     0.2308
 5:   5.756  -5.756     0.1394
---                           
21:   0.000   5.756     0.4665
22:   0.000  11.513     0.4665
23:   5.756  11.513     0.4665
24:  11.513 -11.513     0.2161
25:  11.513   0.000     0.4665</code></pre>
</div>
</div>
<p>Each row of the archive is a different evaluated configuration. The columns here show the tested configurations (before transformation) and the chosen performance measure. We can also manually inspect the archive to determine other important features such as time of evaluation, model runtime, and any errors or warnings that occurred during tuning.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-017_979383754f4ed7801231a79de47c838e">
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">timestamp</span>, <span class="va">runtime_learners</span>, <span class="va">errors</span>, <span class="va">warnings</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             timestamp runtime_learners errors warnings
1: 2023-06-18 11:48:12            0.030      0        0
2: 2023-06-18 11:48:12            0.029      0        0
3: 2023-06-18 11:48:12            0.030      0        0</code></pre>
</div>
</div>
<p>Another powerful feature of the instance is that we can score the internal <a href="https://mlr3.mlr-org.com/reference/ResampleResult.html" class="refcode"><code>ResampleResult</code></a>s on a different performance measure, for example looking at false negative rate and false positive rate as well as classification error:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-018_96f5c539295c4b47ca57edbbcb832cce">
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">instance</span><span class="op">$</span><span class="va">archive</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msrs</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.fpr"</span>, <span class="st">"classif.fnr"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span> ,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span>, <span class="va">classif.fpr</span>, <span class="va">classif.fnr</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      cost   gamma classif.ce classif.fpr classif.fnr
1: -11.513  -5.756     0.4665      1.0000     0.00000
2:  -5.756 -11.513     0.4665      1.0000     0.00000
3:  -5.756  11.513     0.4665      1.0000     0.00000
4:   0.000  -5.756     0.2308      0.3186     0.14997
5:   5.756  -5.756     0.1394      0.2089     0.08056</code></pre>
</div>
</div>
<p>You can access all the resamplings in a <a href="https://mlr3.mlr-org.com/reference/BenchmarkResult.html" class="refcode"><code>BenchmarkResult</code></a> object with <code>instance$archive$benchmark_result</code>.</p>
<p>Finally, to visualize the results, you can use the <code>autoplot</code> implemented in <a href="https://mlr3viz.mlr-org.com"><code>mlr3viz</code></a> (<a href="#fig-surface">Figure&nbsp;<span class="quarto-unresolved-ref">fig-surface</span></a>). In this example we can observe one of the flaws (by design) in grid search, despite testing 25 configurations, we only saw 5 unique values for each hyperparameter.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/fig-surface_c400ff79dbcd30af7b9cc51a672aa33d">
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">instance</span>, type <span class="op">=</span> <span class="st">"surface"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-surface" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="hyperparameter_optimization_files/figure-html/fig-surface-1.png" class="img-fluid figure-img" alt="Heatmap showing model performance during HPO. y-axis is 'gamma' parameter between (-10,10) and x-axis is 'cost' parameter between (-10,10). The heatmap shows squares covering all points on the plot and circular points indicating configurations tried in our optimization. The top-left quadrant is all yellow indicating poor performance when gamma is high and cost is low. The bottom-right is dark blue indicating good performance when cost is high and gamma is low." width="672"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.3: Model performance with different configurations for <code>cost</code> and <code>gamma</code>. Bright yellow regions represent the model performing worse and dark blue performing better. We can see that high <code>cost</code> values and low <code>gamma</code> values achieve the best performance. Note that we should not directly infer the performance of new unseen values from the heatmap since it is only an interpolation based on a surrogate model (<code>regr.ranger</code>). However, we can see the general interaction between the hyperparameters.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<section id="training-an-optimized-model" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="training-an-optimized-model">Training an optimized model</h4>
<p>Once the learner has been tuned we can start to use it like any other model in the <code>mlr3</code> universe. To do this we simply construct a new learner with the same underlying algorithm and set the learner hyperparameters to the optimal configuration:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-020_1a63fb436625328a3d8f1c6f08d533ad">
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_svm_tuned</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span><span class="op">)</span></span>
<span><span class="va">lrn_svm_tuned</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="va">values</span> <span class="op">=</span> <span class="va">instance</span><span class="op">$</span><span class="va">result_learner_param_vals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can train the learner on the full dataset and we are ready to make predictions. The trained model can then be used to predict new, external data:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-021_b7bd942952eeaa078909789fc8e3f873">
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_svm_tuned</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_sonar</span><span class="op">)</span><span class="op">$</span><span class="va">model</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
svm.default(x = data, y = task$truth(), type = "C-classification", 
    kernel = "radial", gamma = 0.00316227766016838, cost = 316.227766016838, 
    probability = (self$predict_type == "prob"))


Parameters:
   SVM-Type:  C-classification 
 SVM-Kernel:  radial 
       cost:  316.2 

Number of Support Vectors:  93</code></pre>
</div>
</div>
</section></section></section><section id="sec-autotuner" class="level2" data-number="4.2"><h2 data-number="4.2" class="anchored" data-anchor-id="sec-autotuner">
<span class="header-section-number">4.2</span> Automating with <code>tune</code> and <code>auto_tuner</code>
</h2>
<p>In the previous section, we looked at constructing and manually putting together the components of HPO by creating a tuning instance using <a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a>, passing this to the tuner, and then calling <code>$optimize()</code> to start the tuning process. <code>mlr3tuning</code> includes two helper methods to simplify this process further.</p>
<p>The first helper function is <a href="https://mlr3tuning.mlr-org.com/reference/tune.html" class="refcode"><code>tune()</code></a>, which creates the tuning instance and calls <code>$optimize()</code> for you. You may prefer the manual method with <code><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti()</a></code> if you want to view and make changes to the instance before tuning.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-015_98d6282810d64ded096a05d71b4ca486">
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tnr_grid_search</span> <span class="op">=</span> <span class="fu">tnr</span><span class="op">(</span><span class="st">"grid_search"</span>, resolution <span class="op">=</span> <span class="fl">5</span>, batch_size <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">lrn_svm</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">rsmp_cv3</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">msr_ce</span> <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">tune</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_grid_search</span>,</span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_svm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_cv3</span>,</span>
<span>  measures <span class="op">=</span> <span class="va">msr_ce</span></span>
<span><span class="op">)</span><span class="op">$</span><span class="va">result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost  gamma learner_param_vals  x_domain classif.ce
1: 5.756 -5.756          &lt;list[4]&gt; &lt;list[2]&gt;     0.1444</code></pre>
</div>
</div>
<p>The other helper function is <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html" class="refcode"><code>auto_tuner</code></a>, which creates an object of class <a href="https://mlr3tuning.mlr-org.com/reference/AutoTuner.html" class="refcode"><code>AutoTuner</code></a>. The <code>AutoTuner</code> inherits from the <a href="https://mlr3.mlr-org.com/reference/Learner.html" class="refcode"><code>Learner</code></a> class and wraps all the information needed for tuning, which means you can treat a learner waiting to be optimized just like any other learner. Under the hood, the <code>AutoTuner</code> essentially runs <code><a href="https://mlr3tuning.mlr-org.com/reference/tune.html">tune()</a></code> on the data that is passed to the model when <code>$train()</code> is called and then sets the learner parameters with the optimal configurations.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-022_e9fad50e4621dde2b7530bb373660872">
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_grid_search</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_svm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_cv3</span>,</span>
<span>  measure <span class="op">=</span> <span class="va">msr_ce</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">at</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;AutoTuner:classif.svm.tuned&gt;
* Model: list
* Search Space:
&lt;ParamSet&gt;
      id    class  lower upper nlevels        default value
1:  cost ParamDbl -11.51 11.51     Inf &lt;NoDefault[3]&gt;      
2: gamma ParamDbl -11.51 11.51     Inf &lt;NoDefault[3]&gt;      
Trafo is set.
* Packages: mlr3, mlr3tuning, mlr3learners, e1071
* Predict Type: response
* Feature Types: logical, integer, numeric
* Properties: multiclass, twoclass</code></pre>
</div>
</div>
<div class="cell" data-layout-align="center" data-hash="hyperparameter_optimization_cache/html/fig-auto-tuner_953d0c832ae0bc7dae444299cdf54ad8">
<div class="cell-output-display">
<div id="fig-auto-tuner" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="Figures/mlr3book_figures-12.svg" class="img-fluid figure-img" alt="The figure shows the auto tuner."></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.4: Illustration of an auto tuner.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>And we can now call <code>$train()</code>, which will first tune the hyperparameters in the search space listed above before fitting the optimal model.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-023_dea9a70159163ecc1850b192a71851c9">
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">split</span> <span class="op">=</span> <span class="fu">partition</span><span class="op">(</span><span class="va">tsk_sonar</span><span class="op">)</span></span>
<span><span class="va">at</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_sonar</span>, row_ids <span class="op">=</span> <span class="va">split</span><span class="op">$</span><span class="va">train</span><span class="op">)</span></span>
<span><span class="va">at</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span><span class="va">tsk_sonar</span>, row_ids <span class="op">=</span> <span class="va">split</span><span class="op">$</span><span class="va">test</span><span class="op">)</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
    0.2029 </code></pre>
</div>
</div>
<p>The <code>AutoTuner</code> contains a tuning instance that can be analyzed like any other instance.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-5_d61c15385647d2d878dcc924d1af3460">
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span><span class="op">$</span><span class="va">tuning_instance</span><span class="op">$</span><span class="va">result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    cost  gamma learner_param_vals  x_domain classif.ce
1: 5.756 -5.756          &lt;list[4]&gt; &lt;list[2]&gt;     0.1727</code></pre>
</div>
</div>
<p>We could also pass the <code>AutoTuner</code> to <a href="https://mlr3.mlr-org.com/reference/resample.html" class="refcode"><code>resample()</code></a> and <a href="https://mlr3.mlr-org.com/reference/benchmark.html" class="refcode"><code>benchmark()</code></a>, which would result in a nested resampling, discussed next.</p>
</section><section id="sec-nested-resampling" class="level2 page-columns page-full" data-number="4.3"><h2 data-number="4.3" class="anchored" data-anchor-id="sec-nested-resampling">
<span class="header-section-number">4.3</span> Nested Resampling</h2>
<p>HPO requires additional resampling to reduce bias when estimating performance of the model. If the same data is used for determining the optimal configuration and the evaluation of the resulting model itself, the actual performance estimate of the model might be severely biased <span class="citation" data-cites="Simon2007">(<a href="#ref-Simon2007" role="doc-biblioref">Simon 2007</a>)</span>. This is analogous to optimism of the training error described in <span class="citation" data-cites="james2013introduction">James et al. (<a href="#ref-james2013introduction" role="doc-biblioref">2013</a>)</span>, which occurs when training error is taken as an estimate of out-of-sample performance.</p>
<div class="page-columns page-full"><p>Nested resampling separates model optimization from the process of estimating the performance of the tuned model by adding an additional resampling, i.e., while model performance is estimated using a resampling method in the ‘usual way’, tuning is then performed by resampling the resampled data (<a href="#fig-nested-resampling">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nested-resampling</span></a>). For more details and a formal introduction to nested resampling the reader is referred to <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="#ref-hpo_practical" role="doc-biblioref">2023</a>)</span> and <span class="citation" data-cites="Simon2007">Simon (<a href="#ref-Simon2007" role="doc-biblioref">2007</a>)</span>.</p><div class="no-row-height column-margin column-container"><span class="">Nested Resampling</span></div></div>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/fig-nested-resampling_9f99195e0e19818d7cde543befc4640a">
<div class="cell-output-display">
<div id="fig-nested-resampling" class="quarto-figure quarto-figure-center anchored">
<figure class="figure"><p><img src="Figures/mlr3book_figures-11.svg" class="img-fluid figure-img" alt="The image shows three rows of large blocks representing three-fold CV for the outer resampling. Below the blocks are four further rows of small blocks representing four-fold CV for the inner resampling. The training sets are represented in light blue and the test sets in dark blue."></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.5: An illustration of nested resampling. The large blocks represent 3-fold CV for the outer resampling for model evaluation and the small blocks represent 4-fold CV for the inner resampling for HPO. The light blue blocks are the training sets and the dark blue blocks are the test sets.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p><a href="#fig-nested-resampling">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nested-resampling</span></a> represents the following example of nested resampling:</p>
<ol type="1">
<li>Outer resampling – Instantiate 3-fold CV to create different testing and training datasets.</li>
<li>Inner resampling – Within the outer training data instantiate 4-fold CV to create different inner testing and training datasets.</li>
<li>HPO – Tune the hyperparameters on the outer training set (large, light blue blocks) using the inner data splits.</li>
<li>Training – Fit the learner on the outer training dataset using the optimal hyperparameter configuration obtained from the inner resampling (small blocks).</li>
<li>Evaluation – Evaluate the performance of the learner on the outer testing data (large, dark blue block).</li>
<li>Cross-validation – Repeat (2)-(5) for each of the three folds.</li>
<li>Aggregation – Take the sample mean of the three performance values for an unbiased performance estimate.</li>
</ol>
<p>The inner resampling produces generalization performance estimates for each configuration and selects the optimal configuration to be evaluated on the outer resampling. The outer resampling then produces generalization estimates for these optimal configurations. The result from the outer resampling can be used for comparison to other models trained and tested on the same outer folds.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Nested resampling is computationally expensive, three outer folds and four inner folds with a grid search of resolution 5 used to tune 2 parameters, results in <code>3*4*5*5 = 300</code> iterations of model training/testing. If you have the resources we recommend utilizing parallelization when tuning (<a href="#sec-parallelization"><span class="quarto-unresolved-ref">sec-parallelization</span></a>).</p>
</div>
</div>
<p>A common mistake is to try and use nested resampling as a method to select optimal model configurations. Nested resampling is a method to compare models and to estimate the generalization performance of a tuned model, however, this is the performance based on multiple different configurations (one from each outer fold) and not performance based on a <em>single</em> configuration (<a href="#sec-resample-overfitting"><span class="quarto-unresolved-ref">sec-resample-overfitting</span></a>). If you are interested in identifying optimal configurations, then use <a href="https://mlr3tuning.mlr-org.com/reference/tune.html" class="refcode"><code>tune()</code></a>/<a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html" class="refcode"><code>auto_tuner()</code></a> with <code>$train()</code>.</p>
<section id="resampling-an-autotuner" class="level3" data-number="4.3.1"><h3 data-number="4.3.1" class="anchored" data-anchor-id="resampling-an-autotuner">
<span class="header-section-number">4.3.1</span> Resampling an <code>AutoTuner</code>
</h3>
<p>Whilst the theory of nested resampling may seem complicated, it is all automated in <code>mlr3tuning</code> by simply passing an <a href="https://mlr3tuning.mlr-org.com/reference/AutoTuner.html" class="refcode"><code>AutoTuner</code></a> to <a href="https://mlr3.mlr-org.com/reference/resample.html" class="refcode"><code>resample()</code></a> or <a href="https://mlr3.mlr-org.com/reference/benchmark.html" class="refcode"><code>benchmark()</code></a>. Continuing with our previous example, we will use the auto-tuner to resample a support vector classifier with 3-fold CV in the outer-resampling and 4-fold CV in the inner resampling.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-025_9924a9f43cf54161bdbdc7323321fb36">
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">at</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_grid_search</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_svm</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">4</span><span class="op">)</span>,</span>
<span>  measure <span class="op">=</span> <span class="va">msr_ce</span>,</span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">rr</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_sonar</span>, <span class="va">at</span>, <span class="va">rsmp_cv3</span>, store_models <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rr</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ResampleResult&gt; with 3 resampling iterations
 task_id        learner_id resampling_id iteration warnings errors
   sonar classif.svm.tuned            cv         1        0      0
   sonar classif.svm.tuned            cv         2        0      0
   sonar classif.svm.tuned            cv         3        0      0</code></pre>
</div>
</div>
<p>Note that we set <code>store_models = TRUE</code> so that the <code>AutoTuner</code> models (fitted on the outer training data) are stored, which also enables investigation of the inner tuning instances. Whilst we used K-fold CV for both the inner and outer resampling strategy, you could use different resampling strategies (<a href="#sec-resampling"><span class="quarto-unresolved-ref">sec-resampling</span></a>) and also different parallelization methods (<a href="#sec-nested-resampling-parallelization"><span class="quarto-unresolved-ref">sec-nested-resampling-parallelization</span></a>).</p>
<p>The estimated performance of a tuned model is reported as the aggregated performance of all outer resampling iterations, which is an unbiased estimate of future model performance.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-028_d41bd5a9bcfcffe9b803c696ad0c436f">
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
    0.1589 </code></pre>
</div>
</div>
<p>In addition to the methods described in <a href="#sec-resampling"><span class="quarto-unresolved-ref">sec-resampling</span></a>, <a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_results.html" class="refcode"><code>extract_inner_tuning_results()</code></a> and <a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_archives.html" class="refcode"><code>extract_inner_tuning_archives()</code></a> return the optimal configurations (across all outer folds) and full tuning archives, respectively.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-026_260d4cc2748230731fdef846b3013563">
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">extract_inner_tuning_results</span><span class="op">(</span><span class="va">rr</span><span class="op">)</span><span class="op">[</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">iteration</span>, <span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   iteration  cost  gamma classif.ce
1:         1 11.51 -5.756     0.2174
2:         2 11.51 -5.756     0.2086
3:         3 11.51 -5.756     0.1796</code></pre>
</div>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">extract_inner_tuning_archives</span><span class="op">(</span><span class="va">rr</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,</span>
<span>  <span class="fu">.</span><span class="op">(</span><span class="va">iteration</span>, <span class="va">cost</span>, <span class="va">gamma</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   iteration   cost   gamma classif.ce
1:         1 -11.51 -11.513     0.5286
2:         1 -11.51  11.513     0.5286
3:         1   0.00  -5.756     0.2981</code></pre>
</div>
</div>
</section><section id="sec-resample-overfitting" class="level3" data-number="4.3.2"><h3 data-number="4.3.2" class="anchored" data-anchor-id="sec-resample-overfitting">
<span class="header-section-number">4.3.2</span> The Right (and Wrong) Way to Estimate Generalization Performance</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>In this short section we will demonstrate with a brief example that only nested resampling with the <code>$aggregate()</code> method provides a reliable estimate of the model’s generalization performance.</p>
<p>We will do this by tuning and (un-nested) resampling a learner on training data and evaluating the in-sample performance, which is the performance of the best performing hyperparameter. Then we will compute the out-of-sample, generalization, performance, which is the performance of the tuned learner trained on the full dataset and evaluated on a test dataset. Finally, we will show how using nested resampling returns a good estimate of the generalization performance, even when only the training data is used.</p>
<p>In this experiment we tune several parameters from <code>lrn("classif.xgboost")</code>, in doing so we can simultaneously show that nested resampling returns the best estimate of the generalization performance <em>and</em> that the insample performance will be overly-optimistic if hyperparameters are ‘meta’-overfitting the data (we use the term ‘meta-overfitting’ as they are overfitting to a subset of the training data during resampling as opposed to the full training data). To best estimate the generalization performance we make use of the <code>"moons"</code> <a href="https://mlr3.mlr-org.com/reference/TaskGenerator.html" class="refcode"><code>TaskGenerator</code></a>. The <code>TaskGenerator</code> class is used when you want to simulate data for use in experiments, these are very useful in cases such as this experiment when you need access to an infinite number of datapoints to estimate quantities such as the generalization error.</p>
<p>We begin by loading our learner, task generator, and generating 100 training data points and 1,000,000 testing data points.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/exp1_c892ac62c861f8e51d417626caab4d8f">
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_xgboost</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.xgboost"</span>,</span>
<span>  eta               <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-4</span>, <span class="fl">1</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  max_depth         <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>,</span>
<span>  colsample_bytree  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  colsample_bylevel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  lambda            <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-3</span>, <span class="fl">1e3</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  alpha             <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-3</span>, <span class="fl">1e3</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  subsample         <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">tsk_moons</span> <span class="op">=</span> <span class="fu">tgen</span><span class="op">(</span><span class="st">"moons"</span><span class="op">)</span></span>
<span><span class="va">tsk_moons_train</span> <span class="op">=</span> <span class="va">tsk_moons</span><span class="op">$</span><span class="fu">generate</span><span class="op">(</span><span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">tsk_moons_test</span> <span class="op">=</span> <span class="va">tsk_moons</span><span class="op">$</span><span class="fu">generate</span><span class="op">(</span><span class="fl">1000000</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we will tune the learner with respect to the classification error and use holdout resampling and random search with 700 evaluations, we compute the in-sample performance as the performance for the optimal hyperparameter configuration.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/exp2_5686b9e5e63f30089bab5d87473754f5">
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tnr_random</span> <span class="op">=</span> <span class="fu">tnr</span><span class="op">(</span><span class="st">"random_search"</span><span class="op">)</span></span>
<span><span class="va">rsmp_holdout</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"holdout"</span><span class="op">)</span></span>
<span><span class="va">trm_evals700</span> <span class="op">=</span> <span class="fu">trm</span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">700</span><span class="op">)</span></span>
<span></span>
<span><span class="va">instance</span> <span class="op">=</span> <span class="fu">tune</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_random</span>,</span>
<span>  task <span class="op">=</span> <span class="va">tsk_moons_train</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_xgboost</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_holdout</span>,</span>
<span>  measures <span class="op">=</span> <span class="va">msr_ce</span>,</span>
<span>  terminator <span class="op">=</span> <span class="va">trm_evals700</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">insample</span> <span class="op">=</span> <span class="va">instance</span><span class="op">$</span><span class="va">result_y</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next we compute the out-of-sample performance, which is the aggregate of scores over the outer resampling method (below we use 5-fold CV) using an <code>AutoTuner</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/exp3_3a0fd32fc40e12b5683003f5f8c5568f">
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># same setup as above</span></span>
<span><span class="va">at</span> <span class="op">=</span> <span class="fu">auto_tuner</span><span class="op">(</span></span>
<span>  tuner <span class="op">=</span> <span class="va">tnr_random</span>,</span>
<span>  learner <span class="op">=</span> <span class="va">lrn_xgboost</span>,</span>
<span>  resampling <span class="op">=</span> <span class="va">rsmp_holdout</span>,</span>
<span>  measure <span class="op">=</span> <span class="va">msr_ce</span>,</span>
<span>  terminator <span class="op">=</span> <span class="va">trm_evals700</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">outsample</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_moons_train</span>, <span class="va">at</span>, <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And finally we estimate the generalization error by training the tuned learner (i.e., using the values from the <code>instance</code> above) on the full training data again and predicting on the test data.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/exp4_268154cb7393a23fc4a425c8ab880040">
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lrn_xgboost_tuned</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.xgboost"</span><span class="op">)</span></span>
<span><span class="va">lrn_xgboost_tuned</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span></span>
<span>  .values <span class="op">=</span> <span class="va">instance</span><span class="op">$</span><span class="va">result_learner_param_vals</span><span class="op">)</span></span>
<span><span class="va">generalization</span> <span class="op">=</span> <span class="va">lrn_xgboost_tuned</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_moons_train</span><span class="op">)</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span><span class="va">tsk_moons_test</span><span class="op">)</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can compare these three values:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-6_63954bd97584deb54875397696c3bb11">
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>generalization <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">generalization</span><span class="op">)</span>,</span>
<span>  insample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">insample</span><span class="op">)</span>,</span>
<span>  outsample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="va">outsample</span><span class="op">)</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>generalization       insample      outsample 
          0.31           0.06           0.20 </code></pre>
</div>
</div>
<p>We find that the insample performance overestimates the model performance, which indicates meta-overfitting to the optimal hyperparameters. The out-of-sample performance from nested resampling provides a much better estimate of the generalization performance, despite the nested resampling only accessing 100 data points and not all 1,000,000.</p>
</section></section><section id="sec-defining-search-spaces" class="level2" data-number="4.4"><h2 data-number="4.4" class="anchored" data-anchor-id="sec-defining-search-spaces">
<span class="header-section-number">4.4</span> More Advanced Search Spaces</h2>
<p>Up until now we have only considered tuning overly simplistic search spaces limited to numeric hyperparameters. In this section we will first look at how to tune different scalar parameter classes with <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a>, and then how to define your own search space with <a href="https://paradox.mlr-org.com/reference/ParamSet.html" class="refcode"><code>ParamSet</code></a> to create more advanced search spaces that may include tuning over vectors, transformations, and handling parameter dependencies. Finally, we will consider how to access a database of standardized search spaces from the literature.</p>
<section id="scalar-parameter-tuning" class="level3" data-number="4.4.1"><h3 data-number="4.4.1" class="anchored" data-anchor-id="scalar-parameter-tuning">
<span class="header-section-number">4.4.1</span> Scalar Parameter Tuning</h3>
<p>The <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a> function can be used to tune parameters of any class, whether they are scalar or vectors. To best understand this function, we will consider what is happening behind the scenes. When <code>to_tune()</code> is used in a learner, implicitly a <a href="https://paradox.mlr-org.com/reference/ParamSet.html" class="refcode"><code>ParamSet</code></a> is created just for the tuning search space:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-039_5e695b446d2a90807af4bd68e2c1563d">
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"radial"</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
      id    class lower upper nlevels        default value
1:  cost ParamDbl   0.1 1e+05     Inf &lt;NoDefault[3]&gt;      
2: gamma ParamDbl   0.1 1e+00     Inf &lt;NoDefault[3]&gt;      </code></pre>
</div>
</div>
<p>Recall from <a href="#sec-param-set"><span class="quarto-unresolved-ref">sec-param-set</span></a>, that the <code>class</code> field corresponds to the hyperparameter class as defined in <a href="https://paradox.mlr-org.com"><code>paradox</code></a>. In this example, we can see that <code>gamma</code> hyperparameter has class <a href="https://paradox.mlr-org.com/reference/ParamDbl.html" class="refcode"><code>ParamDbl</code></a>, with <code>lower = 0.1</code> and <code>upper = 1</code>, which was automatically created by <code>to_tune()</code> as we passed two numeric values to this function. If we wanted to tune over a non-numeric hyperparameter, we can still use <code>to_tune()</code>, which will ‘guess’ the correct class to construct in the resulting parameter set. For example, say we wanted to tune the numeric <code>cost</code>, factor <code>kernel</code>, and logical <code>scale</code> hyperparameter in our SVM:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-7_12e070eb6e4c2823bc13fc0c686bea5e">
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  cost  <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-1</span>, <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"radial"</span>, <span class="st">"linear"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  shrinking <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="op">)</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"C-classification"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
          id    class lower upper nlevels        default value
1:      cost ParamDbl   0.1 1e+05     Inf &lt;NoDefault[3]&gt;      
2:    kernel ParamFct    NA    NA       2 &lt;NoDefault[3]&gt;      
3: shrinking ParamLgl    NA    NA       2           TRUE      </code></pre>
</div>
</div>
<p>Here the <code>kernel</code> hyperparameter is a factor, so we simply pass in a vector corresponding to the levels we want to tune over. The <code>shrinking</code> hyperparameter is a logical, there are only two possible values this could take so we do not need to pass anything to <code>to_tune()</code>, it will automatically recognize this is a logical from <code>learner$param_set</code> and passes this detail to <code>learner$param_set$search_space()</code>. In fact, for factor parameters, we could also use <code>to_tune()</code> without any arguments if we want to tune over all possible values:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-8_2e535dca8340ba309b047ffb97c61ff1">
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>, kernel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"radial"</span>, <span class="st">"linear"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
       id    class lower upper nlevels        default value
1: kernel ParamFct    NA    NA       2 &lt;NoDefault[3]&gt;      </code></pre>
</div>
</div>
<p>Finally, we can only use <code>to_tune()</code> to treat numeric parameters as factors if we only want to discretize them over a small subset of possible values, for example if we wanted to find the optimal number of trees in a random forest we might only consider three scenarios: 100, 200, or 400 trees:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-9_d8d77bd403aaeaeed6db90f275254b2d">
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.ranger"</span>, num.trees <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">100</span>, <span class="fl">200</span>, <span class="fl">400</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
          id    class lower upper nlevels        default value
1: num.trees ParamFct    NA    NA       3 &lt;NoDefault[3]&gt;      
Trafo is set.</code></pre>
</div>
</div>
<p>Before we look at tuning over vectors, we must first learn how to create parameter sets from scratch.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>Treating an integer as a factor for tuning results in “unordered” hyperparameters. Therefore algorithms that make use of ordering information will perform worse when ordering is ignored. For these algorithms, it would make more sense to define a <a href="https://paradox.mlr-org.com/reference/ParamDbl.html" class="refcode"><code>ParamDbl</code></a> or <a href="https://paradox.mlr-org.com/reference/ParamInt.html" class="refcode"><code>ParamInt</code></a> (<a href="#sec-tune-ps"><span class="quarto-unresolved-ref">sec-tune-ps</span></a>) with a more fitting transformation (<a href="#sec-tune-trafo"><span class="quarto-unresolved-ref">sec-tune-trafo</span></a>).</p>
</div>
</div>
</section><section id="sec-tune-ps" class="level3" data-number="4.4.2"><h3 data-number="4.4.2" class="anchored" data-anchor-id="sec-tune-ps">
<span class="header-section-number">4.4.2</span> Defining Search Spaces with <code>ps</code>
</h3>
<p>As we have seen, <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a> is a helper function that creates a parameter set that will go on to be used by <a href="https://mlr3tuning.mlr-org.com/reference/tune.html" class="refcode"><code>tune()</code></a>/<a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a>/<a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html" class="refcode"><code>auto_tuner()</code></a> during the tuning process. However, there will be use-cases where you will need to create a parameter set manually using <a href="https://paradox.mlr-org.com/reference/ps.html" class="refcode"><code>paradox::ps()</code></a>. This function takes named arguments of class <a href="https://paradox.mlr-org.com/reference/Param.html" class="refcode"><code>Param</code></a>, which can be created using the sugar functions in <a href="#tbl-paradox-define">Table&nbsp;<span class="quarto-unresolved-ref">tbl-paradox-define</span></a>.</p>
<div id="tbl-paradox-define" class="anchored">
<table class="table">
<caption>Table&nbsp;4.3: <a href="https://paradox.mlr-org.com/reference/Domain.html" class="refcode"><code>Domain</code></a> Constructors and their resulting <a href="https://paradox.mlr-org.com/reference/Param.html" class="refcode"><code>Param</code></a>.</caption>
<thead><tr class="header">
<th>Constructor</th>
<th>Description</th>
<th>Underlying Class</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html" class="refcode"><code>p_dbl</code></a></td>
<td>Real valued parameter (“double”)</td>
<td><a href="https://paradox.mlr-org.com/reference/ParamDbl.html" class="refcode"><code>ParamDbl</code></a></td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html" class="refcode"><code>p_int</code></a></td>
<td>Integer parameter</td>
<td><a href="https://paradox.mlr-org.com/reference/ParamInt.html" class="refcode"><code>ParamInt</code></a></td>
</tr>
<tr class="odd">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html" class="refcode"><code>p_fct</code></a></td>
<td>Discrete valued parameter (“factor”)</td>
<td><a href="https://paradox.mlr-org.com/reference/ParamFct.html" class="refcode"><code>ParamFct</code></a></td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html" class="refcode"><code>p_lgl</code></a></td>
<td>Logical / Boolean parameter</td>
<td><a href="https://paradox.mlr-org.com/reference/ParamLgl.html" class="refcode"><code>ParamLgl</code></a></td>
</tr>
<tr class="odd">
<td><a href="https://paradox.mlr-org.com/reference/Domain.html" class="refcode"><code>p_uty</code></a></td>
<td>Untyped parameter</td>
<td><a href="https://paradox.mlr-org.com/reference/ParamUty.html" class="refcode"><code>ParamUty</code></a></td>
</tr>
</tbody>
</table>
</div>
<p>As a simple example, let us look at how to create a search space to tune <code>cost</code> and <code>gamma</code> again:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-10_70397561e480f221acd02939a39ab9eb">
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  cost  <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">1e-1</span>, upper <span class="op">=</span> <span class="fl">1e5</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"radial"</span>, <span class="st">"linear"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  shrinking <span class="op">=</span> <span class="fu">p_lgl</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This search space would then be passed to the <code>search_space</code> argument in <code><a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html">auto_tuner()</a></code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-11_1dff4b780cf10960cfe65a3e1535fa06">
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ti</span><span class="op">(</span><span class="va">tsk_sonar</span>, <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>, type <span class="op">=</span> <span class="st">"C-classification"</span><span class="op">)</span>, <span class="va">rsmp_cv3</span>,</span>
<span>  <span class="va">msr_ce</span>, <span class="fu">trm</span><span class="op">(</span><span class="st">"none"</span><span class="op">)</span>, search_space <span class="op">=</span> <span class="va">search_space</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;TuningInstanceSingleCrit&gt;
* State:  Not optimized
* Objective: &lt;ObjectiveTuning:classif.svm_on_sonar&gt;
* Search Space:
          id    class lower upper nlevels
1:      cost ParamDbl   0.1 1e+05     Inf
2:    kernel ParamFct    NA    NA       2
3: shrinking ParamLgl    NA    NA       2
* Terminator: &lt;TerminatorNone&gt;</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>When manually creating search spaces, make sure all numeric hyperparameters in your search space are bounded, e.g., if you are trying to tune a hyperparameter that could take any in value <span class="math inline">\((-\infty, \infty)\)</span> then the tuning process will throw an error if you do not pass lower and upper limits to <code>p_dbl()</code> or <code>p_int()</code>. You can use <code>$is_bounded</code> on the constructed <a href="https://paradox.mlr-org.com/reference/ParamSet.html" class="refcode"><code>ParamSet</code></a> if you are unsure:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-042_688c9ae0c249ccf78333b5bc21e367c2">
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">0.1</span>, upper <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">is_bounded</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">0.1</span>, upper <span class="op">=</span> <span class="cn">Inf</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">is_bounded</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
</div>
</div>
</section><section id="sec-tune-trafo" class="level3" data-number="4.4.3"><h3 data-number="4.4.3" class="anchored" data-anchor-id="sec-tune-trafo">
<span class="header-section-number">4.4.3</span> Transformations and Tuning Over Vectors</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>In <a href="#sec-logarithmic-transformations"><span class="quarto-unresolved-ref">sec-logarithmic-transformations</span></a> we saw how to quickly apply log transformations with <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a>. As you now know, <code>to_tune</code> is just a wrapper that creates <a href="https://paradox.mlr-org.com/reference/ParamSet.html" class="refcode"><code>ParamSet</code></a> objects, so let us look at what is actually taking place when we set <code>logscale = TRUE</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-12_8146f41809226bfe2fea9670ee08b8ab">
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>, cost <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, logscale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
     id    class  lower upper nlevels        default value
1: cost ParamDbl -11.51 11.51     Inf &lt;NoDefault[3]&gt;      
Trafo is set.</code></pre>
</div>
</div>
<p>Notice that now the <code>lower</code> and <code>upper</code> fields correspond to the transformed bounds, i.e.&nbsp;<span class="math inline">\([log(1e-5), log(1e5)]\)</span>. To manually create the same transformation, we can pass the transformation to the <code>trafo</code> argument in <code>p_dbl()</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-045_945c4886f1a8d736cd36743bbddd1f56">
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">search_space</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
     id    class lower upper nlevels        default value
1: cost ParamDbl 1e-05 1e+05     Inf &lt;NoDefault[3]&gt;      
Trafo is set.</code></pre>
</div>
</div>
<p>In this case we do not see the transformation in the <code>lower</code> and <code>upper</code> fields, however we can confirm it is correctly set by making use of the <code>$trafo()</code> method, which takes a named list and applies the specified transformations</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-13_c594b50928aa13294eda986526e58d18">
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 2.718</code></pre>
</div>
</div>
<p>Where transformations become the most powerful is in the ability to pass arbitrary functions that can act on single parameters of the entire parameter set. As an example, consider a simple transformation to add ‘2’ to our range:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-14_3e3a0621c76aa2033a94491d10a6cfd0">
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span>cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span> <span class="op">+</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 3</code></pre>
</div>
</div>
<p>Simple transformations such as this can even be added directly to a learner by passing a <code>Param</code> object to <code>to_tune()</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-15_693b5c3ccf1c25e2f56ed3e4dd500b06">
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>, cost <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu">p_dbl</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span> <span class="op">+</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;LearnerClassifSVM:classif.svm&gt;
* Model: -
* Parameters: cost=&lt;ObjectTuneToken&gt;
* Packages: mlr3, mlr3learners, e1071
* Predict Types:  [response], prob
* Feature Types: logical, integer, numeric
* Properties: multiclass, twoclass</code></pre>
</div>
</div>
<p>More complex transformations that require multiple arguments require the <code>.extra_trafo</code> argument in <code>ps()</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-16_6a8e15a98bfec719821e77cf41668bdb">
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  cost <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  .extra_trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">param_set</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">x</span><span class="op">$</span><span class="va">kernel</span> <span class="op">==</span> <span class="st">"polynomial"</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">x</span><span class="op">$</span><span class="va">cost</span> <span class="op">=</span> <span class="va">x</span><span class="op">$</span><span class="va">cost</span> <span class="op">+</span> <span class="fl">2</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">x</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span>
<span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span>, kernel <span class="op">=</span> <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 2.718

$kernel
[1] "radial"</code></pre>
</div>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>cost <span class="op">=</span> <span class="fl">1</span>, kernel <span class="op">=</span> <span class="st">"polynomial"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$cost
[1] 4.718

$kernel
[1] "polynomial"</code></pre>
</div>
</div>
<p>In this transformation we first exponentiate the value of <code>cost</code> and then add ‘2’ if the <code>kernel</code> is <code>"polynomial"</code>. Note that <code>.extra_trafo</code> takes a function with parameters <code>x</code> and <code>param_set</code>. During tuning, <code>x</code> will be a list containing the configuration being tested, and <code>param_set</code> is the whole parameter set.</p>
<section id="vector-transformations" class="level4 unnumbered unlisted"><h4 class="unnumbered unlisted anchored" data-anchor-id="vector-transformations">Vector transformations</h4>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Any function can be passed to <code>trafo</code> and <code>.extra_trafo</code>, which enables tuning of ‘untyped’ parameters of class <a href="https://paradox.mlr-org.com/reference/ParamUty.html" class="refcode"><code>ParamUty</code></a> that could be vectors, functions, or any non-atomic class. By example, consider the <code>class.weights</code> parameter of the SVM, which takes a named vector of class weights with one entry for each target class. To tune this parameter we could tune a scalar and then transform this to a vector:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-049_2c9cacd5fdc92ad9132bb66fde5ce270">
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  class.weights <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">0.1</span>, upper <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>    trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>M <span class="op">=</span> <span class="va">x</span>, R <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In other cases, we may need to tune two or more ‘pseudoparameters’ that do not exist in our learner’s parameter set, but are required to tune a vector parameter. For example, say we want to tune the architecture of a neural network, in which we need to decide the number of layers and the number of nodes in each layer, this is the case in the <code>num_nodes</code> hyperparameter in the <code>lrn("surv.coxtime")</code> learner. In this case the learner expects a vector where each element corresponds to the number of nodes and the length corresponds to the number of layers. We could then tune this as follows:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-17_2b38d647be394a0db2589d548d6008ef">
<div class="sourceCode" id="cb86"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span> <span class="op">=</span> <span class="fu">ps</span><span class="op">(</span></span>
<span>  num_layers <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span>lower <span class="op">=</span> <span class="fl">1</span>, upper <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>,</span>
<span>  num_nodes_per_layer <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span><span class="fl">4</span>, <span class="fl">64</span><span class="op">)</span>,</span>
<span>  .extra_trafo <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">param_set</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">x</span><span class="op">$</span><span class="va">num_nodes</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="va">x</span><span class="op">$</span><span class="va">num_nodes_per_layer</span>, <span class="va">x</span><span class="op">$</span><span class="va">num_layers</span><span class="op">)</span></span>
<span>    <span class="va">x</span><span class="op">$</span><span class="va">num_layers</span> <span class="op">=</span> <span class="cn">NULL</span></span>
<span>    <span class="va">x</span><span class="op">$</span><span class="va">num_nodes_per_layer</span> <span class="op">=</span> <span class="cn">NULL</span></span>
<span>    <span class="va">x</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here we are tuning the pseudo-parameter <code>num_layers</code> between 1 and 20, then tuning the pseudo-parameter <code>num_nodes_per_layer</code> between 4 and 64, then we are combining these into a vector called <code>num_nodes</code> (the real hyperparameter) and removing the pseudo-parameters.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-18_1ab7d0526faa3c955a1809318d8b8e6b">
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">search_space</span><span class="op">$</span><span class="fu">trafo</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>num_layers <span class="op">=</span> <span class="fl">4</span>, num_nodes_per_layer <span class="op">=</span> <span class="fl">12</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$num_nodes
[1] 12 12 12 12</code></pre>
</div>
</div>
<p>Once again, we could pass this straight to the learner using <code>to_tune()</code> but this time passing the whole <code>ParamSet</code> object:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-19_f5ff795c3fe35631a98850ee50dd45ff">
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"surv.coxtime"</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span>num_nodes <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="va">search_space</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
                    id    class lower upper nlevels        default
1:          num_layers ParamInt     1    20      20 &lt;NoDefault[3]&gt;
2: num_nodes_per_layer ParamInt     4    64      61 &lt;NoDefault[3]&gt;
1 variable not shown: [value]
Trafo is set.</code></pre>
</div>
</div>
<p>However note that in this case the transformation would only have access to the pseudo-hyperparameters and not the rest of the parameters in the learner’s parameter set.</p>
</section></section><section id="sec-optimization-depends" class="level3" data-number="4.4.4"><h3 data-number="4.4.4" class="anchored" data-anchor-id="sec-optimization-depends">
<span class="header-section-number">4.4.4</span> Hyperparameter Dependencies</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Hyperparameter dependencies occur when a hyperparameter should only be set if another hyperparameter has a particular value. For example, the <code>degree</code> parameter in SVM is only valid when <code>kernel</code> is “polynomial”. In the <a href="https://paradox.mlr-org.com/reference/ps.html" class="refcode"><code>ps()</code></a> function, we specify this using the <code>depends</code> argument, which takes a named argument of the form <code>&lt;param&gt; == value</code> or <code>&lt;param&gt; %in% &lt;vector&gt;</code>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-20_b46a3db48cafb9fa99719a3cc7e950dc">
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">ps</span><span class="op">(</span></span>
<span>  kernel <span class="op">=</span> <span class="fu">p_fct</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  degree <span class="op">=</span> <span class="fu">p_int</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, depends <span class="op">=</span> <span class="op">(</span><span class="va">kernel</span> <span class="op">==</span> <span class="st">"polynomial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  gamma <span class="op">=</span> <span class="fu">p_dbl</span><span class="op">(</span><span class="fl">1e-5</span>, <span class="fl">1e5</span>, depends <span class="op">=</span> <span class="op">(</span><span class="va">kernel</span> <span class="op"><a href="https://rdrr.io/r/base/match.html">%in%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
       id    class lower upper nlevels        default parents value
1: degree ParamInt 1e+00 3e+00       3 &lt;NoDefault[3]&gt;  kernel      
2:  gamma ParamDbl 1e-05 1e+05     Inf &lt;NoDefault[3]&gt;  kernel      
3: kernel ParamFct    NA    NA       2 &lt;NoDefault[3]&gt;              </code></pre>
</div>
</div>
<p>Above we have said that <code>degree</code> should only be set if <code>kernel</code> is (<code>==</code>) <code>"polynomial"</code>, and <code>gamma</code> should only be set if <code>kernel</code> is one of (<code>%in%</code>) <code>"polynomial"</code>, <code>"radial"</code>, or <code>"sigmoid"</code>. In practice, some underlying implementations ignore unused parameters and others throw errors, either way this is problematic during tuning if, for example, we were wasting time trying to tune <code>degree</code> when the kernel was not polynomial. Hence setting the dependency tells the tuning process to tune <code>degree</code> iff <code>kernel</code> is <code>"polynomial"</code> and to ignore it otherwise.</p>
<p>Dependencies can also be passed straight into a learner using <a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>to_tune()</code></a>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/unnamed-chunk-21_c012112897a14113282b4ce0bc14cfc0">
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.svm"</span>,</span>
<span>  kernel <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"polynomial"</span>, <span class="st">"radial"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  degree <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fu">p_int</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, depends <span class="op">=</span> <span class="op">(</span><span class="va">kernel</span> <span class="op">==</span> <span class="st">"polynomial"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">search_space</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
       id    class lower upper nlevels        default       parents
1: degree ParamInt     1     3       3 &lt;NoDefault[3]&gt; kernel,kernel
2: kernel ParamFct    NA    NA       2 &lt;NoDefault[3]&gt;              
1 variable not shown: [value]</code></pre>
</div>
</div>
</section><section id="sec-tuning-spaces" class="level3" data-number="4.4.5"><h3 data-number="4.4.5" class="anchored" data-anchor-id="sec-tuning-spaces">
<span class="header-section-number">4.4.5</span> Recommended Search Spaces with <code>mlr3tuningspaces</code>
</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Selected search spaces can require a lot of background knowledge or expertise. The package <a href="https://mlr3tuningspaces.mlr-org.com"><code>mlr3tuningspaces</code></a> tries to make HPO more accessible by providing implementations of published search spaces for many popular machine learning algorithms, the hope is that these search spaces are applicable to a wide range of datasets. The search spaces are stored in the dictionary <a href="https://mlr3tuningspaces.mlr-org.com/reference/mlr_tuning_spaces.html" class="refcode"><code>mlr_tuning_spaces</code></a>.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-056_b87438f6c1859705d66e2ed3157cb671">
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://mlr3tuningspaces.mlr-org.com">mlr3tuningspaces</a></span><span class="op">)</span></span>
<span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">mlr_tuning_spaces</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fu">.</span><span class="op">(</span><span class="va">key</span>, <span class="va">label</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                      key                             label
1: classif.glmnet.default   Classification GLM with Default
2:    classif.glmnet.rbv1 Classification GLM with RandomBot
3:    classif.glmnet.rbv2 Classification GLM with RandomBot</code></pre>
</div>
</div>
<p>The tuning spaces are named according to the scheme <code>{learner-id}.{tuning-space-id}</code>. The <code>default</code> tuning spaces are published in <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="#ref-hpo_practical" role="doc-biblioref">2023</a>)</span>, other tuning spaces are part of the random bot experiments <code>rbv1</code> and <code>rbv2</code> published in <span class="citation" data-cites="kuehn_2018">Kuehn et al. (<a href="#ref-kuehn_2018" role="doc-biblioref">2018</a>)</span> and <span class="citation" data-cites="binder2020">Binder, Pfisterer, and Bischl (<a href="#ref-binder2020" role="doc-biblioref">2020</a>)</span>. The sugar function <a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html" class="refcode"><code>lts()</code></a> is used to retrieve a <a href="https://mlr3tuningspaces.mlr-org.com/reference/TuningSpace.html" class="refcode"><code>TuningSpace</code></a>.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-057_5f3c3b8a7511c2ec3145a4d66156a2fd">
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lts_rpart</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html">lts</a></span><span class="op">(</span><span class="st">"classif.rpart.default"</span><span class="op">)</span></span>
<span><span class="va">lts_rpart</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;TuningSpace:classif.rpart.default&gt;: Classification Rpart with Default
          id lower upper levels logscale
1:  minsplit 2e+00 128.0            TRUE
2: minbucket 1e+00  64.0            TRUE
3:        cp 1e-04   0.1            TRUE</code></pre>
</div>
</div>
<p>A tuning space can be passed to <a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html" class="refcode"><code>auto_tuner()</code></a> as the <code>search_space</code>.</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-058_6e0dcc7ab11ca528eea6687b8c8a610b">
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">instance</span> <span class="op">=</span> <span class="fu"><a href="https://mlr3tuning.mlr-org.com/reference/ti.html">ti</a></span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="va">tsk_sonar</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>,</span>
<span>  measures <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span>,</span>
<span>  terminator <span class="op">=</span> <span class="fu"><a href="https://bbotk.mlr-org.com/reference/trm.html">trm</a></span><span class="op">(</span><span class="st">"evals"</span>, n_evals <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>,</span>
<span>  search_space <span class="op">=</span> <span class="va">lts_rpart</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Alternatively, as loaded search spaces are just a collection of tune tokens, we could also pass these straight to a learner:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-059_a6486af40eb1a4a53538b55634e8dc87">
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">vals</span> <span class="op">=</span> <span class="va">lts_rpart</span><span class="op">$</span><span class="va">values</span></span>
<span><span class="va">vals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$minsplit
Tuning over:
range [2, 128] (log scale)


$minbucket
Tuning over:
range [1, 64] (log scale)


$cp
Tuning over:
range [1e-04, 0.1] (log scale)</code></pre>
</div>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">learner</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span><span class="op">$</span><span class="fu">set_values</span><span class="op">(</span>.values <span class="op">=</span> <span class="va">vals</span><span class="op">)</span></span>
<span><span class="va">learner</span><span class="op">$</span><span class="va">param_set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ParamSet&gt;
                id    class lower upper nlevels        default
 1:             cp ParamDbl     0     1     Inf           0.01
 2:     keep_model ParamLgl    NA    NA       2          FALSE
 3:     maxcompete ParamInt     0   Inf     Inf              4
 4:       maxdepth ParamInt     1    30      30             30
 5:   maxsurrogate ParamInt     0   Inf     Inf              5
 6:      minbucket ParamInt     1   Inf     Inf &lt;NoDefault[3]&gt;
 7:       minsplit ParamInt     1   Inf     Inf             20
 8: surrogatestyle ParamInt     0     1       2              0
 9:   usesurrogate ParamInt     0     2       3              2
10:           xval ParamInt     0   Inf     Inf             10
1 variable not shown: [value]</code></pre>
</div>
</div>
<p>We could also apply the default search spaces from <span class="citation" data-cites="hpo_practical">Bischl et al. (<a href="#ref-hpo_practical" role="doc-biblioref">2023</a>)</span> by passing the learner to <a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html" class="refcode"><code>lts()</code></a>:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-060_cc11c6e9549d68079700ee4621826a8b">
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html">lts</a></span><span class="op">(</span><span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;LearnerClassifRpart:classif.rpart&gt;: Classification Tree
* Model: -
* Parameters: xval=0, minsplit=&lt;RangeTuneToken&gt;,
  minbucket=&lt;RangeTuneToken&gt;, cp=&lt;RangeTuneToken&gt;
* Packages: mlr3, rpart
* Predict Types:  [response], prob
* Feature Types: logical, integer, numeric, factor, ordered
* Properties: importance, missings, multiclass,
  selected_features, twoclass, weights</code></pre>
</div>
</div>
<p>Finally, it is possible to overwrite a predefined tuning space in construction, for example changing the range of the <code>maxdepth</code> hyperparameter in a decision tree:</p>
<div class="cell" data-hash="hyperparameter_optimization_cache/html/optimization-061_0e08071b7fbdf4dd27c4e9e2ab7e40b3">
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://mlr3tuningspaces.mlr-org.com/reference/lts.html">lts</a></span><span class="op">(</span><span class="st">"classif.rpart.rbv2"</span>, maxdepth <span class="op">=</span> <span class="fu">to_tune</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;TuningSpace:classif.rpart.rbv2&gt;: Classification Rpart with RandomBot
          id lower upper levels logscale
1:        cp 1e-04     1            TRUE
2:  maxdepth 1e+00    20           FALSE
3: minbucket 1e+00   100           FALSE
4:  minsplit 1e+00   100           FALSE</code></pre>
</div>
</div>
</section></section><section id="conclusion" class="level2 page-columns page-full" data-number="4.5"><h2 data-number="4.5" class="anchored" data-anchor-id="conclusion">
<span class="header-section-number">4.5</span> Conclusion</h2>
<p>In this chapter, we learned how to optimize a model using tuning instances, about different tuners and terminators, search spaces and transformations, how to make use of automated methods for quicker implementation in larger experiments, and the importance of nested resampling. The most important functions and classes we learned about are in <a href="#tbl-api-optimization">Table&nbsp;<span class="quarto-unresolved-ref">tbl-api-optimization</span></a> alongside their R6 classes.</p>
<div id="tbl-api-optimization" class="anchored">
<table class="table">
<caption>Table&nbsp;4.4: Core S3 ‘sugar’ functions for model optimization in <code>mlr3</code> with the underlying R6 class that are constructed when these functions are called (if applicable) and a summary of the purpose of the functions.</caption>
<thead><tr class="header">
<th>S3 function</th>
<th>R6 Class</th>
<th>Summary</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://mlr3tuning.mlr-org.com/reference/tnr.html" class="refcode"><code>tnr()</code></a></td>
<td><a href="https://mlr3tuning.mlr-org.com/reference/Tuner.html" class="refcode"><code>Tuner</code></a></td>
<td>Determines an optimization algorithm</td>
</tr>
<tr class="even">
<td><a href="https://bbotk.mlr-org.com/reference/trm.html" class="refcode"><code>trm()</code></a></td>
<td><a href="https://bbotk.mlr-org.com/reference/Terminator.html" class="refcode"><code>Terminator</code></a></td>
<td>Controls when to terminate the tuning algorithm</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3tuning.mlr-org.com/reference/ti.html" class="refcode"><code>ti()</code></a></td>
<td>
<a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceSingleCrit.html" class="refcode"><code>TuningInstanceSingleCrit</code></a> or <a href="https://mlr3tuning.mlr-org.com/reference/TuningInstanceMultiCrit.html" class="refcode"><code>TuningInstanceMultiCrit</code></a>
</td>
<td>Stores tuning settings and save results</td>
</tr>
<tr class="even">
<td><a href="https://paradox.mlr-org.com/reference/to_tune.html" class="refcode"><code>paradox::to_tune()</code></a></td>
<td><a href="https://paradox.mlr-org.com/reference/TuneToken.html" class="refcode"><code>paradox::TuneToken</code></a></td>
<td>Sets which parameters in a learner to tune and over what search space</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3tuning.mlr-org.com/reference/auto_tuner.html" class="refcode"><code>auto_tuner()</code></a></td>
<td><a href="https://mlr3tuning.mlr-org.com/reference/AutoTuner.html" class="refcode"><code>AutoTuner</code></a></td>
<td>Automates the tuning process</td>
</tr>
<tr class="even">
<td><a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_results.html" class="refcode"><code>extract_inner_tuning_results()</code></a></td>
<td>-</td>
<td>Extracts inner results from nested resampling</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3tuning.mlr-org.com/reference/extract_inner_tuning_archives.html" class="refcode"><code>extract_inner_tuning_archives()</code></a></td>
<td>-</td>
<td>Extracts inner archives from nested resampling</td>
</tr>
</tbody>
</table>
</div>
<p>We have a few practical examples of tuning that may be useful for more specific use-cases, including:</p>
<ul>
<li>Optimizing an rpart classification tree with only a <a href="https://mlr-org.com/gallery/2022-11-10-hyperparameter-optimization-on-the-palmer-penguins/">few lines of code</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</li>
<li>Tuning an XGBoost model with <a href="https://mlr-org.com/gallery/2022-11-04-early-stopping-with-xgboost/">early stopping</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</li>
<li>Loading and tuning search spaces with <a href="https://mlr-org.com/gallery/2021-07-06-introduction-to-mlr3tuningspaces/">mlr3tuningspaces</a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</li>
</ul><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;<a href="https://mlr-org.com/gallery/2022-11-10-hyperparameter-optimization-on-the-palmer-penguins/">https://mlr-org.com/gallery/2022-11-10-hyperparameter-optimization-on-the-palmer-penguins/</a></p></li><li id="fn2"><p><sup>2</sup>&nbsp;<a href="https://mlr-org.com/gallery/2022-11-04-early-stopping-with-xgboost/">https://mlr-org.com/gallery/2022-11-04-early-stopping-with-xgboost/</a></p></li><li id="fn3"><p><sup>3</sup>&nbsp;<a href="https://mlr-org.com/gallery/2021-07-06-introduction-to-mlr3tuningspaces/">https://mlr-org.com/gallery/2021-07-06-introduction-to-mlr3tuningspaces/</a></p></li></div></section><section id="exercises" class="level2" data-number="4.6"><h2 data-number="4.6" class="anchored" data-anchor-id="exercises">
<span class="header-section-number">4.6</span> Exercises</h2>
<ol type="1">
<li>Tune the <code>mtry</code>, <code>sample.fraction</code>, <code>num.trees</code> hyperparameters of a random forest model (<code>lrn("regr.ranger")</code>) on the <code>tsk("mtcars")</code> task. Use a simple random search with 50 evaluations and select a suitable batch size. Evaluate with a 3-fold CV and the root mean squared error.</li>
<li>Evaluate the performance of the model created in Question 1 with nested resampling. Use a holdout validation for the inner resampling and a 3-fold CV for the outer resampling. Print the unbiased performance estimate of the model.</li>
<li>Tune and benchmark an XGBoost model against a logistic regression and determine which has the best Brier score. Use mlr3tuningspaces and nested resampling.</li>
</ol></section><section id="citation" class="level2" data-number="4.7"><h2 data-number="4.7" class="anchored" data-anchor-id="citation">
<span class="header-section-number">4.7</span> Citation</h2>
<p>Please cite this chapter as:</p>
<p>Becker M, Schneider L, Fischer S. (2024). Hyperparameter Optimization. In Bischl B, Sonabend R, Kotthoff L, Lang M, (Eds.), <em>Applied Machine Learning Using mlr3 in R</em>. CRC Press. https://mlr3book.mlr-org.com/hyperparameter_optimization.html.</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-bergstra2012" class="csl-entry" role="listitem">
Bergstra, James, and Yoshua Bengio. 2012. <span>“Random Search for Hyper-Parameter Optimization.”</span> <em>Journal of Machine Learning Research</em> 13 (10): 281–305. <a href="http://jmlr.org/papers/v13/bergstra12a.html">http://jmlr.org/papers/v13/bergstra12a.html</a>.
</div>
<div id="ref-binder2020" class="csl-entry" role="listitem">
Binder, Martin, Florian Pfisterer, and Bernd Bischl. 2020. <span>“Collecting Empirical Data about Hyperparameters for Data Driven AutoML.”</span> In <em>AutoML Workshop at ICML 2020</em>. <a href="https://www.automl.org/wp-content/uploads/2020/07/AutoML_2020_paper_63.pdf">https://www.automl.org/wp-content/uploads/2020/07/AutoML_2020_paper_63.pdf</a>.
</div>
<div id="ref-hpo_practical" class="csl-entry" role="listitem">
Bischl, Bernd, Martin Binder, Michel Lang, Tobias Pielok, Jakob Richter, Stefan Coors, Janek Thomas, et al. 2023. <span>“Hyperparameter Optimization: Foundations, Algorithms, Best Practices, and Open Challenges.”</span> <em>Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery</em>, e1484.
</div>
<div id="ref-hpo_automl" class="csl-entry" role="listitem">
Feurer, Matthias, and Frank Hutter. 2019. <span>“Hyperparameter Optimization.”</span> In <em>Automated Machine Learning: Methods, Systems, Challenges</em>, edited by Frank Hutter, Lars Kotthoff, and Joaquin Vanschoren, 3–33. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-05318-5_1">https://doi.org/10.1007/978-3-030-05318-5_1</a>.
</div>
<div id="ref-hansen2011" class="csl-entry" role="listitem">
Hansen, Nikolaus, and Anne Auger. 2011. <span>“CMA-ES: Evolution Strategies and Covariance Matrix Adaptation.”</span> In <em>Proceedings of the 13th Annual Conference Companion on Genetic and Evolutionary Computation</em>, 991–1010.
</div>
<div id="ref-james2013introduction" class="csl-entry" role="listitem">
James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013. <em>An Introduction to Statistical Learning</em>. Vol. 112. Springer.
</div>
<div id="ref-kuehn_2018" class="csl-entry" role="listitem">
Kuehn, Daniel, Philipp Probst, Janek Thomas, and Bernd Bischl. 2018. <span>“Automatic Exploration of Machine Learning Experiments on OpenML.”</span> <a href="https://arxiv.org/abs/1806.10961">https://arxiv.org/abs/1806.10961</a>.
</div>
<div id="ref-lopez2016" class="csl-entry" role="listitem">
López-Ibáñez, Manuel, Jérémie Dubois-Lacoste, Leslie Pérez Cáceres, Mauro Birattari, and Thomas Stützle. 2016. <span>“The Irace Package: Iterated Racing for Automatic Algorithm Configuration.”</span> <em>Operations Research Perspectives</em> 3: 43–58.
</div>
<div id="ref-Simon2007" class="csl-entry" role="listitem">
Simon, Richard. 2007. <span>“Resampling Strategies for Model Assessment and Selection.”</span> In <em>Fundamentals of Data Mining in Genomics and Proteomics</em>, edited by Werner Dubitzky, Martin Granzow, and Daniel Berrar, 173–86. <span>Boston, MA</span>: <span>Springer US</span>. <a href="https://doi.org/10.1007/978-0-387-47509-7_8">https://doi.org/10.1007/978-0-387-47509-7_8</a>.
</div>
<div id="ref-Snoek2012" class="csl-entry" role="listitem">
Snoek, Jasper, Hugo Larochelle, and Ryan P Adams. 2012. <span>“Practical Bayesian Optimization of Machine Learning Algorithms.”</span> In <em>Advances in Neural Information Processing Systems</em>, edited by F. Pereira, C. J. Burges, L. Bottou, and K. Q. Weinberger. Vol. 25.
</div>
<div id="ref-tsallis1996" class="csl-entry" role="listitem">
Tsallis, Constantino, and Daniel A Stariolo. 1996. <span>“Generalized Simulated Annealing.”</span> <em>Physica A: Statistical Mechanics and Its Applications</em> 233 (1-2): 395–406.
</div>
<div id="ref-xiang2013" class="csl-entry" role="listitem">
Xiang, Yang, Sylvain Gubian, Brian Suomela, and Julia Hoeng. 2013. <span>“Generalized Simulated Annealing for Global Optimization: The GenSA Package.”</span> <em>R J.</em> 5 (1): 13.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb108" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Hyperparameter Optimization {#sec-optimization}</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_setup.qmd &gt;}}</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="in">`r chapter = "Hyperparameter Optimization"`</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="in">`r authors(chapter)`</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>Machine learning algorithms usually include <span class="in">`r index("parameters")`</span> and <span class="in">`r index("hyperparameters", aside = TRUE)`</span>.</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>Parameters are the model coefficients or weights or other information that are determined by the learning algorithm based on the training data.</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>In contrast, hyperparameters, are configured by the user and determine how the model will fit its parameters, i.e., how the model is built.</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>Examples include setting the number of trees in a random forest, penalty settings in support vector machines, or the learning rate in a neural network.</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>The goal of <span class="in">`r index("hyperparameter optimization", aside = TRUE)`</span> (HPO, see @sec-model-tuning) or model <span class="in">`r index("tuning")`</span> is to find the optimal configuration of hyperparameters of a machine learning algorithm for a given task.</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>There is no closed-form mathematical representation (nor analytic gradient information) for model agnostic HPO.</span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>Instead, we follow a black-box optimization approach: a machine learning algorithm is configured with values chosen for one or more hyperparameters, this algorithm is then evaluated (using a resampling method) and its performance is measured.</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>This process is repeated with multiple configurations and finally the configuration with the best performance is selected.</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>HPO closely relates to model evaluation (@sec-performance) as the objective is to find a hyperparameter configuration that optimizes the generalization performance.</span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>Broadly speaking, we could think of finding the optimal model configuration in the same way as selecting a model from a benchmark experiment, where in this case each model in the experiment is the same algorithm but with different hyperparameter configurations.</span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a>For example, we could benchmark three <span class="in">`r index("support vector machines")`</span> (SVMs) with three difference <span class="in">`cost`</span> values.</span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>However, human trial-and-error is time-consuming, subjective and often biased, error-prone, and computationally inefficient.</span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>Instead, many sophisticated hyperparameter optimization methods (@sec-tuner) (or '<span class="in">`r index('tuners')`</span>') have been developed over the past few decades for robust and efficient HPO.</span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>Besides simple approaches such as a <span class="in">`r index('random search')`</span> or <span class="in">`r index('grid search')`</span>, most hyperparameter optimization methods employ iterative techniques that propose different configurations over time, often exhibiting adaptive behavior guided towards potentially optimal hyperparameter configurations.</span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>These methods continually propose new configurations until a termination criterion is met, at which point the optimal configuration is returned.</span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>This iterative approach is depicted in a typical optimization loop as shown in Figure (@fig-optimization-loop).</span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>For more general details on HPO and more theoretical background, we recommend @hpo_practical and @hpo_automl.</span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- </span><span class="al">FIXME</span><span class="co">: The line from "Evaluate by Resampling" to a "Terminator" should be an arrow --&gt;</span></span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-003}</span></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-optimization-loop</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Representation of the hyperparameter optimization loop in mlr3tuning. Blue - Hyperparameter optimization loop. Purple - Objects of the tuning instance supplied by the user. Blue-Green - Internally created objects of the tuning instance. Green - Optimization Algorithm.</span></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Diagram showing 13 boxes representing model-agnostic HPO.  On the top are two boxes, one that says  "Search Space" and the other "Tuner", these are connected by a line to "Propose Hyperparameter Configurations". That box has an arrow pointing towards another box "Evaluate by Resampling", which has four blue boxes pointing towards it  "Task", "Learner", "Resampling", and "Measure". "Evaluate by Resampling" has one line below it connected to "Objective", and an arrow to the right connected to "Terminator". This "Terminator" box has an arrow pointing down to "Optimal Hyperparameter Configuration" and right to "Update Tuner". Finally the "Update Tuner" box has a line below it connecting to "Archive" and an arrow above it connecting back to "Propose Hyperparameter Configurations".</span></span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb108-33"><a href="#cb108-33" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"Figures/mlr3book_figures-9.svg"</span>, <span class="st">"Figures/mlr3book_figures-9.png"</span>)</span>
<span id="cb108-34"><a href="#cb108-34" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-35"><a href="#cb108-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-36"><a href="#cb108-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model Tuning {#sec-model-tuning}</span></span>
<span id="cb108-37"><a href="#cb108-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-38"><a href="#cb108-38" aria-hidden="true" tabindex="-1"></a><span class="in">`r mlr3tuning`</span>\index{mlr3tuning} is the hyperparameter optimization package of the <span class="in">`mlr3`</span> ecosystem.</span>
<span id="cb108-39"><a href="#cb108-39" aria-hidden="true" tabindex="-1"></a>At the heart of the package are the R6 classes</span>
<span id="cb108-40"><a href="#cb108-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-41"><a href="#cb108-41" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r ref("TuningInstanceSingleCrit")`</span>, which is used to construct a tuning 'instance', describe the optimization problem, and store the results; and</span>
<span id="cb108-42"><a href="#cb108-42" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r ref("Tuner")`</span> which is used to configure and run optimization algorithms.</span>
<span id="cb108-43"><a href="#cb108-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-44"><a href="#cb108-44" aria-hidden="true" tabindex="-1"></a>In this section, we will cover these classes as well as other supporting functions and classes.</span>
<span id="cb108-45"><a href="#cb108-45" aria-hidden="true" tabindex="-1"></a>Throughout this section, we will look at optimizing an SVM classifier from <span class="in">`r ref_pkg("e1071")`</span> on the <span class="in">`sonar`</span> dataset as a running example.</span>
<span id="cb108-46"><a href="#cb108-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-47"><a href="#cb108-47" aria-hidden="true" tabindex="-1"></a><span class="fu">### Learner and Search Space {#sec-learner-search-space}</span></span>
<span id="cb108-48"><a href="#cb108-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-49"><a href="#cb108-49" aria-hidden="true" tabindex="-1"></a>The tuning process begins by deciding which hyperparameters to tune and what range to tune them over.</span>
<span id="cb108-50"><a href="#cb108-50" aria-hidden="true" tabindex="-1"></a>The first place to start is therefore picking a learner and looking at the possible hyperparameters to tune with <span class="in">`$param_set`</span>:</span>
<span id="cb108-51"><a href="#cb108-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-52"><a href="#cb108-52" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-004}</span></span>
<span id="cb108-53"><a href="#cb108-53" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(<span class="fu">lrn</span>(<span class="st">"classif.svm"</span>)<span class="sc">$</span>param_set)[, .(id, class, lower, upper, nlevels)]</span>
<span id="cb108-54"><a href="#cb108-54" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-55"><a href="#cb108-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-56"><a href="#cb108-56" aria-hidden="true" tabindex="-1"></a>Given infinite resources, we could tune all hyperparameters jointly, but in reality that is not possible, so usually only a subset of hyperparameters can be tuned.</span>
<span id="cb108-57"><a href="#cb108-57" aria-hidden="true" tabindex="-1"></a>This subset is referred to as the <span class="in">`r index("search space", aside = TRUE)`</span> or <span class="in">`r index("tuning space")`</span>.</span>
<span id="cb108-58"><a href="#cb108-58" aria-hidden="true" tabindex="-1"></a>In this example we will tune the numeric regularization and kernel width hyperparameters, <span class="in">`cost`</span> and <span class="in">`gamma`</span>; see the help page for <span class="in">`r ref("e1071::svm()")`</span> for full details on the model implementation including hyperparameters.</span>
<span id="cb108-59"><a href="#cb108-59" aria-hidden="true" tabindex="-1"></a>In practice, search spaces are usually more complex and can require expert knowledge to define them.</span>
<span id="cb108-60"><a href="#cb108-60" aria-hidden="true" tabindex="-1"></a>@sec-defining-search-spaces provides more detailed insight into the creation of tuning spaces, including using <span class="in">`r mlr3tuningspaces`</span> to load search spaces that have been established in published scientific articles.</span>
<span id="cb108-61"><a href="#cb108-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-62"><a href="#cb108-62" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb108-63"><a href="#cb108-63" aria-hidden="true" tabindex="-1"></a>In rare cases parameter sets may include hyperparameters that cannot be tuned.</span>
<span id="cb108-64"><a href="#cb108-64" aria-hidden="true" tabindex="-1"></a>These will usually be 'technical' (or 'control') parameters that provide information about *how* the model is being fit but do not control the training process itself, for example the <span class="in">`verbose`</span> hyperparameter in <span class="in">`lrn("classif.ranger")`</span> controls how much information is displayed to the user during training.</span>
<span id="cb108-65"><a href="#cb108-65" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb108-66"><a href="#cb108-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-67"><a href="#cb108-67" aria-hidden="true" tabindex="-1"></a>For numeric hyperparameters (we will explore others later) one must specify the bounds to tune over.</span>
<span id="cb108-68"><a href="#cb108-68" aria-hidden="true" tabindex="-1"></a>We do this by constructing a learner and using <span class="in">`r ref("to_tune()")`</span> to set the lower and upper limits for the parameters we want to tune.</span>
<span id="cb108-69"><a href="#cb108-69" aria-hidden="true" tabindex="-1"></a>This function allows us to mark the hyperparameter for subsequent tuning in the specified range.</span>
<span id="cb108-70"><a href="#cb108-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-71"><a href="#cb108-71" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-006}</span></span>
<span id="cb108-72"><a href="#cb108-72" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-73"><a href="#cb108-73" aria-hidden="true" tabindex="-1"></a>  <span class="at">type  =</span> <span class="st">"C-classification"</span>,</span>
<span id="cb108-74"><a href="#cb108-74" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb108-75"><a href="#cb108-75" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb108-76"><a href="#cb108-76" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>)</span>
<span id="cb108-77"><a href="#cb108-77" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-78"><a href="#cb108-78" aria-hidden="true" tabindex="-1"></a>learner</span>
<span id="cb108-79"><a href="#cb108-79" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-80"><a href="#cb108-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-81"><a href="#cb108-81" aria-hidden="true" tabindex="-1"></a>Here we have constructed a classification SVM, <span class="in">`lrn("classif.svm")`</span>, selected the type of model as <span class="in">`"C-classification"`</span>, set the kernel to <span class="in">`"radial"`</span>, and specified that we plan to tune the <span class="in">`cost`</span> and <span class="in">`gamma`</span> parameters over the range $<span class="co">[</span><span class="ot">0.1,100000</span><span class="co">]</span>$ and $<span class="co">[</span><span class="ot">0.1,1</span><span class="co">]</span>$ respectively (though these are usually tuned on a log scale, see @sec-logarithmic-transformations).</span>
<span id="cb108-82"><a href="#cb108-82" aria-hidden="true" tabindex="-1"></a>Note that calling <span class="in">`$train()`</span> on a learner with a tune token (e.g., <span class="in">`cost=&lt;RangeTuneToken&gt;`</span>) will throw an error.</span>
<span id="cb108-83"><a href="#cb108-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-84"><a href="#cb108-84" aria-hidden="true" tabindex="-1"></a>Now we have decided which hyperparameters to tune, we must now specify when to stop the tuning process.</span>
<span id="cb108-85"><a href="#cb108-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-86"><a href="#cb108-86" aria-hidden="true" tabindex="-1"></a><span class="fu">### Terminator {#sec-terminator}</span></span>
<span id="cb108-87"><a href="#cb108-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-88"><a href="#cb108-88" aria-hidden="true" tabindex="-1"></a><span class="in">`mlr3tuning`</span> includes many methods to specify when to terminate an algorithm (@tbl-terms), which are implemented in <span class="in">`r ref("Terminator", aside = TRUE)`</span> classes.</span>
<span id="cb108-89"><a href="#cb108-89" aria-hidden="true" tabindex="-1"></a>Terminators are stored in the <span class="in">`r ref('mlr_terminators')`</span> dictionary and are constructed with the sugar function <span class="in">`r ref('trm()', aside = TRUE)`</span>.</span>
<span id="cb108-90"><a href="#cb108-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-91"><a href="#cb108-91" aria-hidden="true" tabindex="-1"></a>| Terminator            | Function call and default parameters                                    |</span>
<span id="cb108-92"><a href="#cb108-92" aria-hidden="true" tabindex="-1"></a>|-----------------------|-------------------------------------------------------------------------|</span>
<span id="cb108-93"><a href="#cb108-93" aria-hidden="true" tabindex="-1"></a>| Clock Time            | <span class="in">`trm("clock_time", stop_time = "2022-11-06 08:42:53 CET")`</span>              |</span>
<span id="cb108-94"><a href="#cb108-94" aria-hidden="true" tabindex="-1"></a>| Combo                 | <span class="in">`trm("combo", terminators = list(run_time_100, evals_200, any = TRUE))`</span> |</span>
<span id="cb108-95"><a href="#cb108-95" aria-hidden="true" tabindex="-1"></a>| None                  | <span class="in">`trm("none")`</span>                                                           |</span>
<span id="cb108-96"><a href="#cb108-96" aria-hidden="true" tabindex="-1"></a>| Number of Evaluations | <span class="in">`trm("evals", n_evals = 500)`</span>                                           |</span>
<span id="cb108-97"><a href="#cb108-97" aria-hidden="true" tabindex="-1"></a>| Performance Level     | <span class="in">`trm("perf_reached", level = 0.1)`</span>                                      |</span>
<span id="cb108-98"><a href="#cb108-98" aria-hidden="true" tabindex="-1"></a>| Run Time              | <span class="in">`trm("run_time", secs = 100)`</span>                                           |</span>
<span id="cb108-99"><a href="#cb108-99" aria-hidden="true" tabindex="-1"></a>| Stagnation            | <span class="in">`trm("stagnation", iters = 5, threshold = 1e-5)`</span>                        |</span>
<span id="cb108-100"><a href="#cb108-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-101"><a href="#cb108-101" aria-hidden="true" tabindex="-1"></a>: Terminators available in <span class="in">`mlr3tuning`</span>, their function call and default parameters. A complete and up-to-date list can be found at <span class="in">`r link("https://mlr-org.com/terminators.html")`</span>. {#tbl-terms}</span>
<span id="cb108-102"><a href="#cb108-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-103"><a href="#cb108-103" aria-hidden="true" tabindex="-1"></a>The most commonly used terminators are those that stop the tuning after a certain time  (<span class="in">`trm("run_time")`</span>) or the number of evaluations (<span class="in">`trm("evals")`</span>).</span>
<span id="cb108-104"><a href="#cb108-104" aria-hidden="true" tabindex="-1"></a>Choosing a runtime is often based on practical considerations and intuition.</span>
<span id="cb108-105"><a href="#cb108-105" aria-hidden="true" tabindex="-1"></a>Using a time limit can be important on compute clusters where a maximum runtime for a compute job may need to be specified.</span>
<span id="cb108-106"><a href="#cb108-106" aria-hidden="true" tabindex="-1"></a>The <span class="in">`trm("perf_reached")`</span> terminator stops the tuning when a certain performance level is reached, which can be helpful if a certain performance is seen as sufficient for the practical use of the model, however if this is set too optimistically the tuning may never terminate.</span>
<span id="cb108-107"><a href="#cb108-107" aria-hidden="true" tabindex="-1"></a>The <span class="in">`trm("stagnation")`</span> terminator stops when no progress is made for a number of iterations.</span>
<span id="cb108-108"><a href="#cb108-108" aria-hidden="true" tabindex="-1"></a>The minimum progress is specified by the <span class="in">`threshold`</span> argument, note this can be difficult to select as the optimization could stop too soon for complex search spaces despite room for (possibly significant) improvement.</span>
<span id="cb108-109"><a href="#cb108-109" aria-hidden="true" tabindex="-1"></a><span class="in">`trm("none")`</span> is used for tuners that control termination themselves.</span>
<span id="cb108-110"><a href="#cb108-110" aria-hidden="true" tabindex="-1"></a>Finally, any of these terminators can be freely combined with the <span class="in">`trm("combo")`</span> terminator, which can be used to specify if HPO finishes when any (<span class="in">`any = TRUE`</span>) terminator is triggered or when all (<span class="in">`any = FALSE`</span>) are triggered.</span>
<span id="cb108-111"><a href="#cb108-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-112"><a href="#cb108-112" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Instance with `ti` {#sec-tuning-instance}</span></span>
<span id="cb108-113"><a href="#cb108-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-114"><a href="#cb108-114" aria-hidden="true" tabindex="-1"></a>The tuning instance collects together the tuner-agnostic information required to optimize a model, i.e., all information about the tuning process, except for the tuning algorithm itself.</span>
<span id="cb108-115"><a href="#cb108-115" aria-hidden="true" tabindex="-1"></a>This includes the task to tune over, the learner to tune, the resampling method and measure used to analytically compare hyperparameter optimization configurations, and the terminator to determine when the measure has been optimized 'enough'.</span>
<span id="cb108-116"><a href="#cb108-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-117"><a href="#cb108-117" aria-hidden="true" tabindex="-1"></a>A <span class="in">`r index("tuning instance", aside = TRUE)`</span> can be constructed manually with the <span class="in">`r ref("ti()")`</span> function, or automated (@sec-simplified-tuning) with the <span class="in">`r ref("tune()")`</span> function.</span>
<span id="cb108-118"><a href="#cb108-118" aria-hidden="true" tabindex="-1"></a>We cover the manual approach first as this allows finer control of tuning and a more nuanced discussion about the design and use of <span class="in">`mlr3tuning`</span>.</span>
<span id="cb108-119"><a href="#cb108-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-120"><a href="#cb108-120" aria-hidden="true" tabindex="-1"></a>Continuing our example, we will construct a <span class="in">`r index("single-objective")`</span> tuning problem (i.e., tuning over *one* measure) by using the <span class="in">`ti()`</span> function to create a <span class="in">`r ref("TuningInstanceSingleCrit")`</span>, we will return to <span class="in">`r index('multi-objective')`</span> tuning in @sec-multi-metrics-tuning.</span>
<span id="cb108-121"><a href="#cb108-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-122"><a href="#cb108-122" aria-hidden="true" tabindex="-1"></a>For this example we will use three-fold CV and optimize the classification error measure.</span>
<span id="cb108-123"><a href="#cb108-123" aria-hidden="true" tabindex="-1"></a>Note that in the next section we will continue our example with a grid search tuner, so we select <span class="in">`trm("none")`</span>.</span>
<span id="cb108-124"><a href="#cb108-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-125"><a href="#cb108-125" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-007}</span></span>
<span id="cb108-126"><a href="#cb108-126" aria-hidden="true" tabindex="-1"></a>tsk_sonar <span class="ot">=</span> <span class="fu">tsk</span>(<span class="st">"sonar"</span>)</span>
<span id="cb108-127"><a href="#cb108-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-128"><a href="#cb108-128" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-129"><a href="#cb108-129" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb108-130"><a href="#cb108-130" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb108-131"><a href="#cb108-131" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb108-132"><a href="#cb108-132" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb108-133"><a href="#cb108-133" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-134"><a href="#cb108-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-135"><a href="#cb108-135" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">ti</span>(</span>
<span id="cb108-136"><a href="#cb108-136" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb108-137"><a href="#cb108-137" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> learner,</span>
<span id="cb108-138"><a href="#cb108-138" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>),</span>
<span id="cb108-139"><a href="#cb108-139" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb108-140"><a href="#cb108-140" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"none"</span>)</span>
<span id="cb108-141"><a href="#cb108-141" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-142"><a href="#cb108-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-143"><a href="#cb108-143" aria-hidden="true" tabindex="-1"></a>instance</span>
<span id="cb108-144"><a href="#cb108-144" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-145"><a href="#cb108-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-146"><a href="#cb108-146" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuner {#sec-tuner}</span></span>
<span id="cb108-147"><a href="#cb108-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-148"><a href="#cb108-148" aria-hidden="true" tabindex="-1"></a>With all the pieces of our tuning problem assembled, we can now decide *how* to tune our model.</span>
<span id="cb108-149"><a href="#cb108-149" aria-hidden="true" tabindex="-1"></a>There are multiple <span class="in">`r ref("Tuner", aside = TRUE)`</span> classes in <span class="in">`mlr3tuning`</span>, which implement different HPO (or more generally speaking <span class="in">`r index('black-box optimization')`</span>) algorithms (@tbl-tuners).</span>
<span id="cb108-150"><a href="#cb108-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-151"><a href="#cb108-151" aria-hidden="true" tabindex="-1"></a>| Tuner                           | Function call          | Package               |</span>
<span id="cb108-152"><a href="#cb108-152" aria-hidden="true" tabindex="-1"></a>|---------------------------------|------------------------|-----------------------|</span>
<span id="cb108-153"><a href="#cb108-153" aria-hidden="true" tabindex="-1"></a>| Random Search                   | <span class="in">`tnr("random_search")`</span> | <span class="in">`r mlr3tuning`</span>        |</span>
<span id="cb108-154"><a href="#cb108-154" aria-hidden="true" tabindex="-1"></a>| Grid Search                     | <span class="in">`tnr("grid_search")`</span>   | <span class="in">`r mlr3tuning`</span>        |</span>
<span id="cb108-155"><a href="#cb108-155" aria-hidden="true" tabindex="-1"></a>| Bayesian Optimization           | <span class="in">`tnr("mbo")`</span>           | <span class="in">`r mlr3mbo`</span>           |</span>
<span id="cb108-156"><a href="#cb108-156" aria-hidden="true" tabindex="-1"></a>| CMA-ES                          | <span class="in">`tnr("cmaes")`</span>         | <span class="in">`r ref_pkg("adagio")`</span> |</span>
<span id="cb108-157"><a href="#cb108-157" aria-hidden="true" tabindex="-1"></a>| Iterative Racing                | <span class="in">`tnr("irace")`</span>         | <span class="in">`r ref_pkg("irace")`</span>  |</span>
<span id="cb108-158"><a href="#cb108-158" aria-hidden="true" tabindex="-1"></a>| Hyperband                       | <span class="in">`tnr("hyperband")`</span>     | <span class="in">`r mlr3hyperband`</span>     |</span>
<span id="cb108-159"><a href="#cb108-159" aria-hidden="true" tabindex="-1"></a>| Generalized Simulated Annealing | <span class="in">`tnr("gensa")`</span>         | <span class="in">`r ref_pkg("GenSA")`</span>  |</span>
<span id="cb108-160"><a href="#cb108-160" aria-hidden="true" tabindex="-1"></a>| Nonlinear Optimization          | <span class="in">`tnr("nloptr")`</span>        | <span class="in">`r ref_pkg("nloptr")`</span> |</span>
<span id="cb108-161"><a href="#cb108-161" aria-hidden="true" tabindex="-1"></a>: Tuning algorithms available in <span class="in">`mlr3tuning`</span>, their function call and the package in which the algorithm is implemented. A complete and up-to-date list can be found at <span class="in">`r link("https://mlr-org.com/tuners.html")`</span>. {#tbl-tuners}</span>
<span id="cb108-162"><a href="#cb108-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-163"><a href="#cb108-163" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Search strategies {.unnumbered .unlisted}</span></span>
<span id="cb108-164"><a href="#cb108-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-165"><a href="#cb108-165" aria-hidden="true" tabindex="-1"></a>Grid search and random search <span class="co">[</span><span class="ot">@bergstra2012</span><span class="co">]</span> are the most basic algorithms and are often selected first in initial experiments.</span>
<span id="cb108-166"><a href="#cb108-166" aria-hidden="true" tabindex="-1"></a>The idea of grid search is to exhaustively evaluate every possible combination of given hyperparameter values.</span>
<span id="cb108-167"><a href="#cb108-167" aria-hidden="true" tabindex="-1"></a>Categorical hyperparameters are usually evaluated over all possible values they can take while values to consider for numeric hyperparameters are determined by a given resolution, which is the number of distinct values to try per hyperparameter.</span>
<span id="cb108-168"><a href="#cb108-168" aria-hidden="true" tabindex="-1"></a>Numeric and integer hyperparameters are spaced equidistantly in their box constraints (upper and lower bounds), and categorical hyperparameters usually have all possible values considered.</span>
<span id="cb108-169"><a href="#cb108-169" aria-hidden="true" tabindex="-1"></a>Random search involves randomly selecting values for each hyperparameter independently from a pre-specified distribution, usually uniform.</span>
<span id="cb108-170"><a href="#cb108-170" aria-hidden="true" tabindex="-1"></a>Both methods are non-adaptive, which means each proposed configuration ignores the performance of previous configurations.</span>
<span id="cb108-171"><a href="#cb108-171" aria-hidden="true" tabindex="-1"></a>Due to their simplicity, both grid search and random search can handle mixed search spaces (i.e., hyperparameters can be numeric, integer, or categorical) as well as hierarchical search spaces (@sec-defining-search-spaces).</span>
<span id="cb108-172"><a href="#cb108-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-173"><a href="#cb108-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-174"><a href="#cb108-174" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Adaptive algorithms {.unnumbered .unlisted}</span></span>
<span id="cb108-175"><a href="#cb108-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-176"><a href="#cb108-176" aria-hidden="true" tabindex="-1"></a>Adaptive algorithms learn from previously evaluated configurations to find good configurations more quickly, examples in <span class="in">`r mlr3`</span> include Bayesian optimization (also called model-based optimization), Covariance Matrix Adaptation Evolution Strategy (CMA-ES), Iterative Racing, and Hyperband.</span>
<span id="cb108-177"><a href="#cb108-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-178"><a href="#cb108-178" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- </span><span class="al">FIXME</span><span class="co"> - It might make sense to shorten this once I've read MBO if there's a lot of duplication --&gt;</span></span>
<span id="cb108-179"><a href="#cb108-179" aria-hidden="true" tabindex="-1"></a>Bayesian optimization (@sec-bayesian-optimization) <span class="co">[</span><span class="ot">e.g., @Snoek2012</span><span class="co">]</span> describes a family of iterative optimization algorithms that use a surrogate model to approximate the unknown function that is to be optimized -- in HPO the mapping from a hyperparameter configuration to the estimated generalization performance.</span>
<span id="cb108-180"><a href="#cb108-180" aria-hidden="true" tabindex="-1"></a>Any Bayesian optimization algorithm starts by observing an initial design of observations and then trains the surrogate model on all data points and performance values observed so far.</span>
<span id="cb108-181"><a href="#cb108-181" aria-hidden="true" tabindex="-1"></a>The algorithm then uses an acquisition function that usually relies on both the mean and variance prediction of the surrogate model to determine which points of the search space are promising candidates that should be evaluated next.</span>
<span id="cb108-182"><a href="#cb108-182" aria-hidden="true" tabindex="-1"></a>By optimizing the acquisition function itself, the next candidate point is chosen for evaluation, evaluated and the process repeats itself by re-fitting or updating the surrogate model on the updated set of observed data points.</span>
<span id="cb108-183"><a href="#cb108-183" aria-hidden="true" tabindex="-1"></a>Bayesian optimization is very flexible (e.g. mixed and hierarchical search spaces can easily be handled by choosing a suitable surrogate model), and highly sample efficient, i.e., compared to other algorithms, much less function evaluations are needed to find good configurations.</span>
<span id="cb108-184"><a href="#cb108-184" aria-hidden="true" tabindex="-1"></a>On the downside, the optimization overhead of Bayesian optimization is comparably large (e.g., in each iteration, training of the surrogate model and optimizing the acquisition function) and therefore really shines in the context of very costly function evaluations and tight optimization budget.</span>
<span id="cb108-185"><a href="#cb108-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-186"><a href="#cb108-186" aria-hidden="true" tabindex="-1"></a>CMA-ES <span class="co">[</span><span class="ot">@hansen2011</span><span class="co">]</span> is an evolutionary strategy that maintains a probability distribution over candidate points, with the distribution represented by a mean vector and covariance matrix.</span>
<span id="cb108-187"><a href="#cb108-187" aria-hidden="true" tabindex="-1"></a>A new set of candidate points is generated by sampling from this distribution, with the probability of each candidate being proportional to its performance.</span>
<span id="cb108-188"><a href="#cb108-188" aria-hidden="true" tabindex="-1"></a>The covariance matrix is adapted over time to reflect the performance landscape.</span>
<span id="cb108-189"><a href="#cb108-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-190"><a href="#cb108-190" aria-hidden="true" tabindex="-1"></a>Racing algorithms work by iteratively discarding configurations that show poor performance, as determined by statistical tests.</span>
<span id="cb108-191"><a href="#cb108-191" aria-hidden="true" tabindex="-1"></a>Iterative Racing <span class="co">[</span><span class="ot">@lopez2016</span><span class="co">]</span> starts by 'racing' down an initial population of randomly sampled configurations from a parameterized density and then uses the surviving configurations of the race to stochastically update the density of the subsequent race to focus on promising regions of the search space, and so on.</span>
<span id="cb108-192"><a href="#cb108-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-193"><a href="#cb108-193" aria-hidden="true" tabindex="-1"></a>Multi-fidelity HPO is an adaptive method that leverages the predictive power of computationally cheap lower fidelity evaluations (i.e., poorer quality predictions such as those arising from neural networks with a small number of epochs) to improve the overall optimization efficiency.</span>
<span id="cb108-194"><a href="#cb108-194" aria-hidden="true" tabindex="-1"></a>This concept is used in Hyperband (@sec-hyperband), a popular multi-fidelity hyperparameter optimization algorithm that dynamically allocates increasingly more resources to promising configurations and terminates low-performing ones.</span>
<span id="cb108-195"><a href="#cb108-195" aria-hidden="true" tabindex="-1"></a>Hyperband tends to outperform random search as the optimization budget is used much more efficiently.</span>
<span id="cb108-196"><a href="#cb108-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-197"><a href="#cb108-197" aria-hidden="true" tabindex="-1"></a>Other implemented algorithms for numeric search spaces are Generalized Simulated Annealing <span class="co">[</span><span class="ot">@xiang2013; @tsallis1996</span><span class="co">]</span> and various nonlinear optimization algorithms.</span>
<span id="cb108-198"><a href="#cb108-198" aria-hidden="true" tabindex="-1"></a>These can be useful if evaluations are rather cheap as they require more function evaluations and are therefore less sample efficient than other sophisticated methods (e.g., bayesian optimization) but are more commonly used for general, numeric black-box optimization.</span>
<span id="cb108-199"><a href="#cb108-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-200"><a href="#cb108-200" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Choosing strategies {.unnumbered .unlisted}</span></span>
<span id="cb108-201"><a href="#cb108-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-202"><a href="#cb108-202" aria-hidden="true" tabindex="-1"></a>As a rule of thumb, if the search space is small and consists of categorical hyperparameters, a grid search may be able to exhaustively evaluate the entire search space in a reasonable time.</span>
<span id="cb108-203"><a href="#cb108-203" aria-hidden="true" tabindex="-1"></a>However, grid search is generally not recommended due to the curse of dimensionality -- the grid size 'blows up' very quickly as number of parameters to tune increases -- and insufficient coverage of numeric search spaces.</span>
<span id="cb108-204"><a href="#cb108-204" aria-hidden="true" tabindex="-1"></a>Grid search by construction also cannot evaluate a large number of unique values per hyperparameter, which is suboptimal when some hyperparameters have minimal impact on performance while others do.</span>
<span id="cb108-205"><a href="#cb108-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-206"><a href="#cb108-206" aria-hidden="true" tabindex="-1"></a>In such scenarios, a random search is often a better choice as it considers more unique values per hyperparameter compared to grid search.</span>
<span id="cb108-207"><a href="#cb108-207" aria-hidden="true" tabindex="-1"></a>Random search is also suitable for small optimization budgets and quick concept experiments.</span>
<span id="cb108-208"><a href="#cb108-208" aria-hidden="true" tabindex="-1"></a>However, with larger optimization budgets, more guided optimization algorithms such as evolutionary strategies or Bayesian optimization tend to perform better and are more likely to result in peak performance.</span>
<span id="cb108-209"><a href="#cb108-209" aria-hidden="true" tabindex="-1"></a>Evolutionary strategies are available in <span class="in">`mlr3`</span> via the <span class="in">`r ref_pkg("miesmuschel")`</span> package, however these will not be covered in this book.</span>
<span id="cb108-210"><a href="#cb108-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-211"><a href="#cb108-211" aria-hidden="true" tabindex="-1"></a>When choosing between evolutionary strategies and Bayesian optimization, the cost of function evaluation is highly relevant.</span>
<span id="cb108-212"><a href="#cb108-212" aria-hidden="true" tabindex="-1"></a>If hyperparameter configurations can be evaluated quickly, evolutionary strategies often find good configurations within a reasonable time frame.</span>
<span id="cb108-213"><a href="#cb108-213" aria-hidden="true" tabindex="-1"></a>On the other hand, if model evaluations are time-consuming and the optimization budget is limited, Bayesian optimization is usually preferred, this will be covered in @sec-bayesian-optimization.</span>
<span id="cb108-214"><a href="#cb108-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-215"><a href="#cb108-215" aria-hidden="true" tabindex="-1"></a>Finally, in cases where the hyperparameter optimization problem involves a meaningful fidelity parameter (e.g., number of epochs, number of trees, number of boosting rounds) and optimization budget needs to be spent efficiently, multi-fidelity hyperparameter optimization algorithms like Hyperband may be worth considering.</span>
<span id="cb108-216"><a href="#cb108-216" aria-hidden="true" tabindex="-1"></a>For further details on different tuners and practical recommendations, we refer to @hpo_practical.</span>
<span id="cb108-217"><a href="#cb108-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-218"><a href="#cb108-218" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb108-219"><a href="#cb108-219" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$param_classes`</span> and <span class="in">`$properties`</span> fields of a <span class="in">`Tuner`</span> respectively provide information about which classes of hyperparameters can be handled and what properties the tuner can handle (e.g., hyperparameter dependencies (@sec-defining-search-spaces)):</span>
<span id="cb108-220"><a href="#cb108-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-223"><a href="#cb108-223" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-224"><a href="#cb108-224" aria-hidden="true" tabindex="-1"></a><span class="fu">tnr</span>(<span class="st">"random_search"</span>)<span class="sc">$</span>param_classes</span>
<span id="cb108-225"><a href="#cb108-225" aria-hidden="true" tabindex="-1"></a><span class="fu">tnr</span>(<span class="st">"random_search"</span>)<span class="sc">$</span>properties</span>
<span id="cb108-226"><a href="#cb108-226" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-227"><a href="#cb108-227" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb108-228"><a href="#cb108-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-229"><a href="#cb108-229" aria-hidden="true" tabindex="-1"></a>For our SVM example, we will use a grid search with a resolution of 5 for efficiency reasons here (in practice a larger resolution would be preferred).</span>
<span id="cb108-230"><a href="#cb108-230" aria-hidden="true" tabindex="-1"></a>Recall that the resolution is the number of distinct values to try *per hyperparameter*, which means in our example the tuner will construct a 5x5 grid of 25 configurations of equally spaced points between the specified upper and lower bounds.</span>
<span id="cb108-231"><a href="#cb108-231" aria-hidden="true" tabindex="-1"></a>All configurations will be tried by the tuner (in random order) until either all configurations are evaluated or the terminator (@sec-terminator) signals that the budget is exhausted.</span>
<span id="cb108-232"><a href="#cb108-232" aria-hidden="true" tabindex="-1"></a>For grid and random search tuners, the <span class="in">`batch_size`</span> parameter controls how many configurations are evaluated at the same time (see @sec-parallelization) and also determines how many configurations should be applied before the terminator should check if the termination criterion has been reached.</span>
<span id="cb108-233"><a href="#cb108-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-234"><a href="#cb108-234" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-008}</span></span>
<span id="cb108-235"><a href="#cb108-235" aria-hidden="true" tabindex="-1"></a>tuner <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"grid_search"</span>, <span class="at">resolution =</span> <span class="dv">5</span>, <span class="at">batch_size =</span> <span class="dv">10</span>)</span>
<span id="cb108-236"><a href="#cb108-236" aria-hidden="true" tabindex="-1"></a>tuner</span>
<span id="cb108-237"><a href="#cb108-237" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-238"><a href="#cb108-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-239"><a href="#cb108-239" aria-hidden="true" tabindex="-1"></a>The <span class="in">`resolution`</span> and <span class="in">`batch_size`</span> parameters are termed <span class="in">`r index("control parameters", aside = TRUE)`</span>, and other tuners will have other parameters that can be set, as with learners these are accessible with <span class="in">`$param_set`</span>.</span>
<span id="cb108-240"><a href="#cb108-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-241"><a href="#cb108-241" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-009}</span></span>
<span id="cb108-242"><a href="#cb108-242" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span>param_set</span>
<span id="cb108-243"><a href="#cb108-243" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-244"><a href="#cb108-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-245"><a href="#cb108-245" aria-hidden="true" tabindex="-1"></a>Whilst changing the control parameters of the tuner can improve optimal performance, it is likely the default settings will fit most needs.</span>
<span id="cb108-246"><a href="#cb108-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-247"><a href="#cb108-247" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Triggering the tuning process {.unnumbered .unlisted}</span></span>
<span id="cb108-248"><a href="#cb108-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-249"><a href="#cb108-249" aria-hidden="true" tabindex="-1"></a>Now that we have all our components, we can start the tuning process.</span>
<span id="cb108-250"><a href="#cb108-250" aria-hidden="true" tabindex="-1"></a>To do this we simply pass the constructed <span class="in">`r ref("TuningInstanceSingleCrit")`</span> to the <span class="in">`$optimize()`</span> method of the initialized <span class="in">`r ref("Tuner")`</span>, which triggers the hyperparameter optimization loop (@fig-optimization-loop).</span>
<span id="cb108-251"><a href="#cb108-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-252"><a href="#cb108-252" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-010}</span></span>
<span id="cb108-253"><a href="#cb108-253" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb108-254"><a href="#cb108-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-255"><a href="#cb108-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-256"><a href="#cb108-256" aria-hidden="true" tabindex="-1"></a>The optimizer returns the best hyperparameter configuration and the corresponding performance, this information is also stored in <span class="in">`instance$result`</span>.</span>
<span id="cb108-257"><a href="#cb108-257" aria-hidden="true" tabindex="-1"></a>The first columns (here <span class="in">`cost`</span> and <span class="in">`gamma`</span>) will be named after the tuned hyperparameters and show the optimal values from the searched tuning spaces.</span>
<span id="cb108-258"><a href="#cb108-258" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$learner_param_vals`</span> field lists the optimal hyperparameters from tuning, as well as the values of any other hyperparameters that were manually changed from the defaults, this is useful for onward model use (@sec-analyzing-result).</span>
<span id="cb108-259"><a href="#cb108-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-262"><a href="#cb108-262" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-263"><a href="#cb108-263" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result<span class="sc">$</span>learner_param_vals</span>
<span id="cb108-264"><a href="#cb108-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-265"><a href="#cb108-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-266"><a href="#cb108-266" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$x_domain`</span> field contains the optimal values of the tuned hyperparameters, which is most useful in the context of hyperparameter transformations, which we will briefly turn to next.</span>
<span id="cb108-267"><a href="#cb108-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-268"><a href="#cb108-268" aria-hidden="true" tabindex="-1"></a>:::{.callout-warning}</span>
<span id="cb108-269"><a href="#cb108-269" aria-hidden="true" tabindex="-1"></a>A common mistake when tuning is to report the performance estimated on the resampling sets on which the tuning was performed (<span class="in">`instance$result$classif.ce`</span>) as an estimate of the model's performance.</span>
<span id="cb108-270"><a href="#cb108-270" aria-hidden="true" tabindex="-1"></a>The correct method is to test the model on more unseen data, which can be efficiently performed with nested resampling, we will discuss this in @sec-resample-overfitting.</span>
<span id="cb108-271"><a href="#cb108-271" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb108-272"><a href="#cb108-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-273"><a href="#cb108-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-274"><a href="#cb108-274" aria-hidden="true" tabindex="-1"></a><span class="fu">### Logarithmic Transformations {#sec-logarithmic-transformations}</span></span>
<span id="cb108-275"><a href="#cb108-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-276"><a href="#cb108-276" aria-hidden="true" tabindex="-1"></a>For many hyperparameters that have infinite (or very large) bounds, tuning on a logarithmic scale is more efficient than tuning on a linear scale.</span>
<span id="cb108-277"><a href="#cb108-277" aria-hidden="true" tabindex="-1"></a>By example, consider sampling uniformly in the interval $<span class="co">[</span><span class="ot">log(1e-5), log(1e5)</span><span class="co">]</span>$ and then exponentiating the outcome:</span>
<span id="cb108-278"><a href="#cb108-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-279"><a href="#cb108-279" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-011}</span></span>
<span id="cb108-280"><a href="#cb108-280" aria-hidden="true" tabindex="-1"></a>cost <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1000</span>, <span class="fu">log</span>(<span class="fl">1e-5</span>), <span class="fu">log</span>(<span class="fl">1e5</span>))</span>
<span id="cb108-281"><a href="#cb108-281" aria-hidden="true" tabindex="-1"></a>exp_cost <span class="ot">=</span> <span class="fu">exp</span>(cost)</span>
<span id="cb108-282"><a href="#cb108-282" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-283"><a href="#cb108-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-284"><a href="#cb108-284" aria-hidden="true" tabindex="-1"></a>The histograms below show how we are initially sampling within a narrow range ($<span class="co">[</span><span class="ot">-11.5, 11.5</span><span class="co">]</span>$) then exponentiating results in the majority of points being relatively small but a few being very large.</span>
<span id="cb108-285"><a href="#cb108-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-286"><a href="#cb108-286" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-012}</span></span>
<span id="cb108-287"><a href="#cb108-287" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb108-288"><a href="#cb108-288" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-logscale</span></span>
<span id="cb108-289"><a href="#cb108-289" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Histogram of uniformly sampled values from the interval $[log(1e-5), log(1e5)]$.</span></span>
<span id="cb108-290"><a href="#cb108-290" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb108-291"><a href="#cb108-291" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Values on the linear scale sampled by the tuner."</span></span>
<span id="cb108-292"><a href="#cb108-292" aria-hidden="true" tabindex="-1"></a><span class="co">#|   - "Transformed values on the logarithmic scale as seen by the learner."</span></span>
<span id="cb108-293"><a href="#cb108-293" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Histogram showing the distribution of uniformly sampled values from the interval [log(1e-5), log(1e5)]. The left plot shows the values on the linear scale sampled by the tuner between [-11.5,11.5] and the right plot shows the transformed values on the logarithmic scale between [1e-5, 1e5].</span></span>
<span id="cb108-294"><a href="#cb108-294" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb108-295"><a href="#cb108-295" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb108-296"><a href="#cb108-296" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(viridisLite)</span>
<span id="cb108-297"><a href="#cb108-297" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">cost =</span> cost)</span>
<span id="cb108-298"><a href="#cb108-298" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(data, <span class="fu">aes</span>(<span class="at">x =</span> cost)) <span class="sc">+</span></span>
<span id="cb108-299"><a href="#cb108-299" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(</span>
<span id="cb108-300"><a href="#cb108-300" aria-hidden="true" tabindex="-1"></a>    <span class="at">bins =</span> <span class="dv">15</span>,</span>
<span id="cb108-301"><a href="#cb108-301" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="fu">viridis</span>(<span class="dv">1</span>, <span class="at">begin =</span> <span class="fl">0.5</span>),</span>
<span id="cb108-302"><a href="#cb108-302" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="fl">0.8</span>,</span>
<span id="cb108-303"><a href="#cb108-303" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb108-304"><a href="#cb108-304" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span>
<span id="cb108-305"><a href="#cb108-305" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">cost =</span> exp_cost)</span>
<span id="cb108-306"><a href="#cb108-306" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(data, <span class="fu">aes</span>(<span class="at">x =</span> cost)) <span class="sc">+</span></span>
<span id="cb108-307"><a href="#cb108-307" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(</span>
<span id="cb108-308"><a href="#cb108-308" aria-hidden="true" tabindex="-1"></a>    <span class="at">bins =</span> <span class="dv">15</span>,</span>
<span id="cb108-309"><a href="#cb108-309" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="fu">viridis</span>(<span class="dv">1</span>, <span class="at">begin =</span> <span class="fl">0.5</span>),</span>
<span id="cb108-310"><a href="#cb108-310" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="fl">0.8</span>,</span>
<span id="cb108-311"><a href="#cb108-311" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb108-312"><a href="#cb108-312" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span>
<span id="cb108-313"><a href="#cb108-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-314"><a href="#cb108-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-315"><a href="#cb108-315" aria-hidden="true" tabindex="-1"></a>To add this transformation to a hyperparameter we simply pass <span class="in">`logscale = TRUE`</span> to <span class="in">`r ref("to_tune()")`</span>.</span>
<span id="cb108-316"><a href="#cb108-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-317"><a href="#cb108-317" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-013}</span></span>
<span id="cb108-318"><a href="#cb108-318" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-319"><a href="#cb108-319" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-320"><a href="#cb108-320" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-321"><a href="#cb108-321" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb108-322"><a href="#cb108-322" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb108-323"><a href="#cb108-323" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-324"><a href="#cb108-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-325"><a href="#cb108-325" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">ti</span>(</span>
<span id="cb108-326"><a href="#cb108-326" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb108-327"><a href="#cb108-327" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> learner,</span>
<span id="cb108-328"><a href="#cb108-328" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>),</span>
<span id="cb108-329"><a href="#cb108-329" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb108-330"><a href="#cb108-330" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"none"</span>)</span>
<span id="cb108-331"><a href="#cb108-331" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-332"><a href="#cb108-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-333"><a href="#cb108-333" aria-hidden="true" tabindex="-1"></a>tuner<span class="sc">$</span><span class="fu">optimize</span>(instance)</span>
<span id="cb108-334"><a href="#cb108-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-335"><a href="#cb108-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-336"><a href="#cb108-336" aria-hidden="true" tabindex="-1"></a>We can see from this example that using the log transformation improved our model training as <span class="in">`classif.ce`</span> is smaller.</span>
<span id="cb108-337"><a href="#cb108-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-338"><a href="#cb108-338" aria-hidden="true" tabindex="-1"></a>Note that the fields <span class="in">`cost`</span> and <span class="in">`gamma`</span> show the optimal values *before* transformation, whereas `x_domain` and `learner_param_vals` contain optimal values *after* transformation, it is these latter fields you would take forward for future model use.</span>
<span id="cb108-339"><a href="#cb108-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-340"><a href="#cb108-340" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-014}</span></span>
<span id="cb108-341"><a href="#cb108-341" aria-hidden="true" tabindex="-1"></a>instance<span class="sc">$</span>result<span class="sc">$</span>x_domain</span>
<span id="cb108-342"><a href="#cb108-342" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-343"><a href="#cb108-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-344"><a href="#cb108-344" aria-hidden="true" tabindex="-1"></a>In @sec-search-space-scratch we will look at how to implement more complex, custom transformations to any hyperparameter or combination of hyperparameters.</span>
<span id="cb108-345"><a href="#cb108-345" aria-hidden="true" tabindex="-1"></a>Now we will look at how to put everything into practice so we can make use of the tuned model (and the transformed hyperparameters).</span>
<span id="cb108-346"><a href="#cb108-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-347"><a href="#cb108-347" aria-hidden="true" tabindex="-1"></a><span class="fu">### Analyzing and Using the Result {#sec-analyzing-result}</span></span>
<span id="cb108-348"><a href="#cb108-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-349"><a href="#cb108-349" aria-hidden="true" tabindex="-1"></a>Independently of whether you use <span class="in">`r ref("ti()")`</span> or <span class="in">`r ref("tune()")`</span>, or if you include transformations or not, the output is the same and the instance's <span class="in">`r index("archive")`</span> lists all evaluated hyperparameter configurations:</span>
<span id="cb108-350"><a href="#cb108-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-351"><a href="#cb108-351" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-016}</span></span>
<span id="cb108-352"><a href="#cb108-352" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)[, .(cost, gamma, classif.ce)]</span>
<span id="cb108-353"><a href="#cb108-353" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-354"><a href="#cb108-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-355"><a href="#cb108-355" aria-hidden="true" tabindex="-1"></a>Each row of the archive is a different evaluated configuration.</span>
<span id="cb108-356"><a href="#cb108-356" aria-hidden="true" tabindex="-1"></a>The columns here show the tested configurations (before transformation) and the chosen performance measure.</span>
<span id="cb108-357"><a href="#cb108-357" aria-hidden="true" tabindex="-1"></a>We can also manually inspect the archive to determine other important features such as time of evaluation, model runtime, and any errors or warnings that occurred during tuning.</span>
<span id="cb108-358"><a href="#cb108-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-359"><a href="#cb108-359" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-017}</span></span>
<span id="cb108-360"><a href="#cb108-360" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb108-361"><a href="#cb108-361" aria-hidden="true" tabindex="-1"></a>  .(timestamp, runtime_learners, errors, warnings)]</span>
<span id="cb108-362"><a href="#cb108-362" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-363"><a href="#cb108-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-364"><a href="#cb108-364" aria-hidden="true" tabindex="-1"></a>Another powerful feature of the instance is that we can score the internal <span class="in">`r ref("ResampleResult")`</span>s on a different performance measure, for example looking at false negative rate and false positive rate as well as classification error:</span>
<span id="cb108-365"><a href="#cb108-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-366"><a href="#cb108-366" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-018}</span></span>
<span id="cb108-367"><a href="#cb108-367" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(instance<span class="sc">$</span>archive,</span>
<span id="cb108-368"><a href="#cb108-368" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msrs</span>(<span class="fu">c</span>(<span class="st">"classif.fpr"</span>, <span class="st">"classif.fnr"</span>)))[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span> ,</span>
<span id="cb108-369"><a href="#cb108-369" aria-hidden="true" tabindex="-1"></a>  .(cost, gamma, classif.ce, classif.fpr, classif.fnr)]</span>
<span id="cb108-370"><a href="#cb108-370" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-371"><a href="#cb108-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-372"><a href="#cb108-372" aria-hidden="true" tabindex="-1"></a>You can access all the resamplings in a <span class="in">`r ref("BenchmarkResult")`</span> object with <span class="in">`instance$archive$benchmark_result`</span>.</span>
<span id="cb108-373"><a href="#cb108-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-374"><a href="#cb108-374" aria-hidden="true" tabindex="-1"></a>Finally, to visualize the results, you can use the <span class="in">`autoplot`</span> implemented in <span class="in">`r mlr3viz`</span> (@fig-surface).</span>
<span id="cb108-375"><a href="#cb108-375" aria-hidden="true" tabindex="-1"></a>In this example we can observe one of the flaws (by design) in grid search, despite testing 25 configurations, we only saw 5 unique values for each hyperparameter.</span>
<span id="cb108-376"><a href="#cb108-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-377"><a href="#cb108-377" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-019}</span></span>
<span id="cb108-378"><a href="#cb108-378" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-surface</span></span>
<span id="cb108-379"><a href="#cb108-379" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Model performance with different configurations for `cost` and `gamma`. Bright yellow regions represent the model performing worse and dark blue performing better. We can see that high `cost` values and low `gamma` values achieve the best performance. Note that we should not directly infer the performance of new unseen values from the heatmap since it is only an interpolation based on a surrogate model (`regr.ranger`). However, we can see the general interaction between the hyperparameters.</span></span>
<span id="cb108-380"><a href="#cb108-380" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: Heatmap showing model performance during HPO. y-axis is 'gamma' parameter between (-10,10) and x-axis is 'cost' parameter between (-10,10). The heatmap shows squares covering all points on the plot and circular points indicating configurations tried in our optimization. The top-left quadrant is all yellow indicating poor performance when gamma is high and cost is low. The bottom-right is dark blue indicating good performance when cost is high and gamma is low.</span></span>
<span id="cb108-381"><a href="#cb108-381" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(instance, <span class="at">type =</span> <span class="st">"surface"</span>)</span>
<span id="cb108-382"><a href="#cb108-382" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-383"><a href="#cb108-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-384"><a href="#cb108-384" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Training an optimized model {.unnumbered .unlisted}</span></span>
<span id="cb108-385"><a href="#cb108-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-386"><a href="#cb108-386" aria-hidden="true" tabindex="-1"></a>Once the learner has been tuned we can start to use it like any other model in the <span class="in">`mlr3`</span> universe.</span>
<span id="cb108-387"><a href="#cb108-387" aria-hidden="true" tabindex="-1"></a>To do this we simply construct a new learner with the same underlying algorithm and set the learner hyperparameters to the optimal configuration:</span>
<span id="cb108-388"><a href="#cb108-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-389"><a href="#cb108-389" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-020}</span></span>
<span id="cb108-390"><a href="#cb108-390" aria-hidden="true" tabindex="-1"></a>lrn_svm_tuned <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>)</span>
<span id="cb108-391"><a href="#cb108-391" aria-hidden="true" tabindex="-1"></a>lrn_svm_tuned<span class="sc">$</span>param_set<span class="sc">$</span>values <span class="ot">=</span> instance<span class="sc">$</span>result_learner_param_vals</span>
<span id="cb108-392"><a href="#cb108-392" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-393"><a href="#cb108-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-394"><a href="#cb108-394" aria-hidden="true" tabindex="-1"></a>Now we can train the learner on the full dataset and we are ready to make predictions.</span>
<span id="cb108-395"><a href="#cb108-395" aria-hidden="true" tabindex="-1"></a>The trained model can then be used to predict new, external data:</span>
<span id="cb108-396"><a href="#cb108-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-397"><a href="#cb108-397" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-021}</span></span>
<span id="cb108-398"><a href="#cb108-398" aria-hidden="true" tabindex="-1"></a>lrn_svm_tuned<span class="sc">$</span><span class="fu">train</span>(tsk_sonar)<span class="sc">$</span>model</span>
<span id="cb108-399"><a href="#cb108-399" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-400"><a href="#cb108-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-401"><a href="#cb108-401" aria-hidden="true" tabindex="-1"></a><span class="fu">## Automating with `tune` and `auto_tuner` {#sec-autotuner}</span></span>
<span id="cb108-402"><a href="#cb108-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-403"><a href="#cb108-403" aria-hidden="true" tabindex="-1"></a>In the previous section, we looked at constructing and manually putting together the components of HPO by creating a tuning instance using <span class="in">`r ref("ti()")`</span>, passing this to the tuner, and then calling <span class="in">`$optimize()`</span> to start the tuning process.</span>
<span id="cb108-404"><a href="#cb108-404" aria-hidden="true" tabindex="-1"></a><span class="in">`mlr3tuning`</span> includes two helper methods to simplify this process further.</span>
<span id="cb108-405"><a href="#cb108-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-406"><a href="#cb108-406" aria-hidden="true" tabindex="-1"></a>The first helper function is <span class="in">`r ref("tune()")`</span>, which creates the tuning instance and calls <span class="in">`$optimize()`</span> for you.</span>
<span id="cb108-407"><a href="#cb108-407" aria-hidden="true" tabindex="-1"></a>You may prefer the manual method with <span class="in">`ti()`</span> if you want to view and make changes to the instance before tuning.</span>
<span id="cb108-408"><a href="#cb108-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-409"><a href="#cb108-409" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-015}</span></span>
<span id="cb108-410"><a href="#cb108-410" aria-hidden="true" tabindex="-1"></a>tnr_grid_search <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"grid_search"</span>, <span class="at">resolution =</span> <span class="dv">5</span>, <span class="at">batch_size =</span> <span class="dv">5</span>)</span>
<span id="cb108-411"><a href="#cb108-411" aria-hidden="true" tabindex="-1"></a>lrn_svm <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-412"><a href="#cb108-412" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-413"><a href="#cb108-413" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-414"><a href="#cb108-414" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb108-415"><a href="#cb108-415" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb108-416"><a href="#cb108-416" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-417"><a href="#cb108-417" aria-hidden="true" tabindex="-1"></a>rsmp_cv3 <span class="ot">=</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>)</span>
<span id="cb108-418"><a href="#cb108-418" aria-hidden="true" tabindex="-1"></a>msr_ce <span class="ot">=</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>)</span>
<span id="cb108-419"><a href="#cb108-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-420"><a href="#cb108-420" aria-hidden="true" tabindex="-1"></a><span class="fu">tune</span>(</span>
<span id="cb108-421"><a href="#cb108-421" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_grid_search,</span>
<span id="cb108-422"><a href="#cb108-422" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb108-423"><a href="#cb108-423" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_svm,</span>
<span id="cb108-424"><a href="#cb108-424" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_cv3,</span>
<span id="cb108-425"><a href="#cb108-425" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> msr_ce</span>
<span id="cb108-426"><a href="#cb108-426" aria-hidden="true" tabindex="-1"></a>)<span class="sc">$</span>result</span>
<span id="cb108-427"><a href="#cb108-427" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-428"><a href="#cb108-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-429"><a href="#cb108-429" aria-hidden="true" tabindex="-1"></a>The other helper function is <span class="in">`r ref("auto_tuner")`</span>, which creates an object of class <span class="in">`r ref("AutoTuner")`</span>.</span>
<span id="cb108-430"><a href="#cb108-430" aria-hidden="true" tabindex="-1"></a>The <span class="in">`AutoTuner`</span> inherits from the <span class="in">`r ref("Learner")`</span> class and wraps all the information needed for tuning, which means you can treat a learner waiting to be optimized just like any other learner.</span>
<span id="cb108-431"><a href="#cb108-431" aria-hidden="true" tabindex="-1"></a>Under the hood, the <span class="in">`AutoTuner`</span> essentially runs <span class="in">`tune()`</span> on the data that is passed to the model when <span class="in">`$train()`</span> is called and then sets the learner parameters with the optimal configurations.</span>
<span id="cb108-432"><a href="#cb108-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-433"><a href="#cb108-433" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-022}</span></span>
<span id="cb108-434"><a href="#cb108-434" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_tuner</span>(</span>
<span id="cb108-435"><a href="#cb108-435" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_grid_search,</span>
<span id="cb108-436"><a href="#cb108-436" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_svm,</span>
<span id="cb108-437"><a href="#cb108-437" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_cv3,</span>
<span id="cb108-438"><a href="#cb108-438" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> msr_ce</span>
<span id="cb108-439"><a href="#cb108-439" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-440"><a href="#cb108-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-441"><a href="#cb108-441" aria-hidden="true" tabindex="-1"></a>at</span>
<span id="cb108-442"><a href="#cb108-442" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-443"><a href="#cb108-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-444"><a href="#cb108-444" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-028, echo=FALSE}</span></span>
<span id="cb108-445"><a href="#cb108-445" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-auto-tuner</span></span>
<span id="cb108-446"><a href="#cb108-446" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustration of an auto tuner."</span></span>
<span id="cb108-447"><a href="#cb108-447" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: "center"</span></span>
<span id="cb108-448"><a href="#cb108-448" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: "The figure shows the auto tuner."</span></span>
<span id="cb108-449"><a href="#cb108-449" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"Figures/mlr3book_figures-12.svg"</span>, <span class="st">"Figures/mlr3book_figures-12.png"</span>)</span>
<span id="cb108-450"><a href="#cb108-450" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-451"><a href="#cb108-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-452"><a href="#cb108-452" aria-hidden="true" tabindex="-1"></a>And we can now call <span class="in">`$train()`</span>, which will first tune the hyperparameters in the search space listed above before fitting the optimal model.</span>
<span id="cb108-453"><a href="#cb108-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-454"><a href="#cb108-454" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-023}</span></span>
<span id="cb108-455"><a href="#cb108-455" aria-hidden="true" tabindex="-1"></a>split <span class="ot">=</span> <span class="fu">partition</span>(tsk_sonar)</span>
<span id="cb108-456"><a href="#cb108-456" aria-hidden="true" tabindex="-1"></a>at<span class="sc">$</span><span class="fu">train</span>(tsk_sonar, <span class="at">row_ids =</span> split<span class="sc">$</span>train)</span>
<span id="cb108-457"><a href="#cb108-457" aria-hidden="true" tabindex="-1"></a>at<span class="sc">$</span><span class="fu">predict</span>(tsk_sonar, <span class="at">row_ids =</span> split<span class="sc">$</span>test)<span class="sc">$</span><span class="fu">score</span>()</span>
<span id="cb108-458"><a href="#cb108-458" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-459"><a href="#cb108-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-460"><a href="#cb108-460" aria-hidden="true" tabindex="-1"></a>The <span class="in">`AutoTuner`</span> contains a tuning instance that can be analyzed like any other instance.</span>
<span id="cb108-461"><a href="#cb108-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-464"><a href="#cb108-464" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-465"><a href="#cb108-465" aria-hidden="true" tabindex="-1"></a>at<span class="sc">$</span>tuning_instance<span class="sc">$</span>result</span>
<span id="cb108-466"><a href="#cb108-466" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-467"><a href="#cb108-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-468"><a href="#cb108-468" aria-hidden="true" tabindex="-1"></a>We could also pass the <span class="in">`AutoTuner`</span> to <span class="in">`r ref("resample()")`</span> and <span class="in">`r ref("benchmark()")`</span>, which would result in a nested resampling, discussed next.</span>
<span id="cb108-469"><a href="#cb108-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-470"><a href="#cb108-470" aria-hidden="true" tabindex="-1"></a><span class="fu">## Nested Resampling {#sec-nested-resampling}</span></span>
<span id="cb108-471"><a href="#cb108-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-472"><a href="#cb108-472" aria-hidden="true" tabindex="-1"></a>HPO requires additional resampling to reduce bias when estimating performance of the model.</span>
<span id="cb108-473"><a href="#cb108-473" aria-hidden="true" tabindex="-1"></a>If the same data is used for determining the optimal configuration and the evaluation of the resulting model itself, the actual performance estimate of the model might be severely biased <span class="co">[</span><span class="ot">@Simon2007</span><span class="co">]</span>.</span>
<span id="cb108-474"><a href="#cb108-474" aria-hidden="true" tabindex="-1"></a>This is analogous to <span class="in">`r index("optimism of the training error")`</span> described in @james2013introduction, which occurs when training error is taken as an estimate of out-of-sample performance.</span>
<span id="cb108-475"><a href="#cb108-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-476"><a href="#cb108-476" aria-hidden="true" tabindex="-1"></a><span class="in">`r index("Nested resampling", aside = TRUE)`</span> separates model optimization from the process of estimating the performance of the tuned model by adding an additional resampling, i.e., while model performance is estimated using a resampling method in the 'usual way', tuning is then performed by resampling the resampled data (@fig-nested-resampling).</span>
<span id="cb108-477"><a href="#cb108-477" aria-hidden="true" tabindex="-1"></a>For more details and a formal introduction to nested resampling the reader is referred to @hpo_practical and @Simon2007.</span>
<span id="cb108-478"><a href="#cb108-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-479"><a href="#cb108-479" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-024}</span></span>
<span id="cb108-480"><a href="#cb108-480" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-nested-resampling</span></span>
<span id="cb108-481"><a href="#cb108-481" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: An illustration of nested resampling. The large blocks represent 3-fold CV for the outer resampling for model evaluation and the small blocks represent 4-fold CV for the inner resampling for HPO. The light blue blocks are the training sets and the dark blue blocks are the test sets.</span></span>
<span id="cb108-482"><a href="#cb108-482" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-alt: The image shows three rows of large blocks representing three-fold CV for the outer resampling. Below the blocks are four further rows of small blocks representing four-fold CV for the inner resampling. The training sets are represented in light blue and the test sets in dark blue.</span></span>
<span id="cb108-483"><a href="#cb108-483" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb108-484"><a href="#cb108-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-485"><a href="#cb108-485" aria-hidden="true" tabindex="-1"></a><span class="fu">include_multi_graphics</span>(<span class="st">"Figures/mlr3book_figures-11.svg"</span>, <span class="st">"Figures/mlr3book_figures-11.png"</span>)</span>
<span id="cb108-486"><a href="#cb108-486" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-487"><a href="#cb108-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-488"><a href="#cb108-488" aria-hidden="true" tabindex="-1"></a>@fig-nested-resampling represents the following example of nested resampling:</span>
<span id="cb108-489"><a href="#cb108-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-490"><a href="#cb108-490" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span><span class="in">`r index("Outer resampling")`</span> -- Instantiate 3-fold CV to create different testing and training datasets.</span>
<span id="cb108-491"><a href="#cb108-491" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span><span class="in">`r index("Inner resampling")`</span> -- Within the outer training data instantiate 4-fold CV to create different inner testing and training datasets.</span>
<span id="cb108-492"><a href="#cb108-492" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>HPO -- Tune the hyperparameters on the outer training set (large, light blue blocks) using the inner data splits.</span>
<span id="cb108-493"><a href="#cb108-493" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Training -- Fit the learner on the outer training dataset using the optimal hyperparameter configuration obtained from the inner resampling (small blocks).</span>
<span id="cb108-494"><a href="#cb108-494" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Evaluation -- Evaluate the performance of the learner on the outer testing data (large, dark blue block).</span>
<span id="cb108-495"><a href="#cb108-495" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>Cross-validation -- Repeat (2)-(5) for each of the three folds.</span>
<span id="cb108-496"><a href="#cb108-496" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>Aggregation -- Take the sample mean of the three performance values for an unbiased performance estimate.</span>
<span id="cb108-497"><a href="#cb108-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-498"><a href="#cb108-498" aria-hidden="true" tabindex="-1"></a>The inner resampling produces generalization performance estimates for each configuration and selects the optimal configuration to be evaluated on the outer resampling.</span>
<span id="cb108-499"><a href="#cb108-499" aria-hidden="true" tabindex="-1"></a>The outer resampling then produces generalization estimates for these optimal configurations.</span>
<span id="cb108-500"><a href="#cb108-500" aria-hidden="true" tabindex="-1"></a>The result from the outer resampling can be used for comparison to other models trained and tested on the same outer folds.</span>
<span id="cb108-501"><a href="#cb108-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-502"><a href="#cb108-502" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb108-503"><a href="#cb108-503" aria-hidden="true" tabindex="-1"></a>Nested resampling is computationally expensive, three outer folds and four inner folds with a grid search of resolution 5 used to tune 2 parameters, results in <span class="in">`3*4*5*5 = 300`</span> iterations of model training/testing.</span>
<span id="cb108-504"><a href="#cb108-504" aria-hidden="true" tabindex="-1"></a>If you have the resources we recommend utilizing parallelization when tuning (@sec-parallelization).</span>
<span id="cb108-505"><a href="#cb108-505" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb108-506"><a href="#cb108-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-507"><a href="#cb108-507" aria-hidden="true" tabindex="-1"></a>A common mistake is to try and use nested resampling as a method to select optimal model configurations.</span>
<span id="cb108-508"><a href="#cb108-508" aria-hidden="true" tabindex="-1"></a>Nested resampling is a method to compare models and to estimate the generalization performance of a tuned model, however, this is the performance based on multiple different configurations (one from each outer fold) and not performance based on a *single* configuration (@sec-resample-overfitting).</span>
<span id="cb108-509"><a href="#cb108-509" aria-hidden="true" tabindex="-1"></a>If you are interested in identifying optimal configurations, then  use <span class="in">`r ref("tune()")`</span>/<span class="in">`r ref("ti()")`</span> or <span class="in">`r ref("auto_tuner()")`</span> with <span class="in">`$train()`</span>.</span>
<span id="cb108-510"><a href="#cb108-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-511"><a href="#cb108-511" aria-hidden="true" tabindex="-1"></a><span class="fu">### Resampling an `AutoTuner`</span></span>
<span id="cb108-512"><a href="#cb108-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-513"><a href="#cb108-513" aria-hidden="true" tabindex="-1"></a>Whilst the theory of nested resampling may seem complicated, it is all automated in <span class="in">`mlr3tuning`</span> by simply passing an <span class="in">`r ref("AutoTuner")`</span> to <span class="in">`r ref("resample()")`</span> or <span class="in">`r ref("benchmark()")`</span>.</span>
<span id="cb108-514"><a href="#cb108-514" aria-hidden="true" tabindex="-1"></a>Continuing with our previous example, we will use the auto-tuner to resample a support vector classifier with 3-fold CV in the outer-resampling and 4-fold CV in the inner resampling.</span>
<span id="cb108-515"><a href="#cb108-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-516"><a href="#cb108-516" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-025}</span></span>
<span id="cb108-517"><a href="#cb108-517" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_tuner</span>(</span>
<span id="cb108-518"><a href="#cb108-518" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_grid_search,</span>
<span id="cb108-519"><a href="#cb108-519" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_svm,</span>
<span id="cb108-520"><a href="#cb108-520" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">4</span>),</span>
<span id="cb108-521"><a href="#cb108-521" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> msr_ce,</span>
<span id="cb108-522"><a href="#cb108-522" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-523"><a href="#cb108-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-524"><a href="#cb108-524" aria-hidden="true" tabindex="-1"></a>rr <span class="ot">=</span> <span class="fu">resample</span>(tsk_sonar, at, rsmp_cv3, <span class="at">store_models =</span> <span class="cn">TRUE</span>)</span>
<span id="cb108-525"><a href="#cb108-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-526"><a href="#cb108-526" aria-hidden="true" tabindex="-1"></a>rr</span>
<span id="cb108-527"><a href="#cb108-527" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-528"><a href="#cb108-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-529"><a href="#cb108-529" aria-hidden="true" tabindex="-1"></a>Note that we set <span class="in">`store_models = TRUE`</span> so that the <span class="in">`AutoTuner`</span> models (fitted on the outer training data) are stored, which also enables investigation of the inner tuning instances.</span>
<span id="cb108-530"><a href="#cb108-530" aria-hidden="true" tabindex="-1"></a>Whilst we used K-fold CV for both the inner and outer resampling strategy, you could use different resampling strategies (@sec-resampling) and also different parallelization methods (@sec-nested-resampling-parallelization).</span>
<span id="cb108-531"><a href="#cb108-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-532"><a href="#cb108-532" aria-hidden="true" tabindex="-1"></a>The estimated performance of a tuned model is reported as the aggregated performance of all outer resampling iterations, which is an unbiased estimate of future model performance.</span>
<span id="cb108-533"><a href="#cb108-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-534"><a href="#cb108-534" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-028}</span></span>
<span id="cb108-535"><a href="#cb108-535" aria-hidden="true" tabindex="-1"></a>rr<span class="sc">$</span><span class="fu">aggregate</span>()</span>
<span id="cb108-536"><a href="#cb108-536" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-537"><a href="#cb108-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-538"><a href="#cb108-538" aria-hidden="true" tabindex="-1"></a>In addition to the methods described in @sec-resampling, <span class="in">`r ref("extract_inner_tuning_results()")`</span> and <span class="in">`r ref("extract_inner_tuning_archives()")`</span> return the optimal configurations (across all outer folds) and full tuning archives, respectively.</span>
<span id="cb108-539"><a href="#cb108-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-540"><a href="#cb108-540" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-026}</span></span>
<span id="cb108-541"><a href="#cb108-541" aria-hidden="true" tabindex="-1"></a><span class="fu">extract_inner_tuning_results</span>(rr)[,</span>
<span id="cb108-542"><a href="#cb108-542" aria-hidden="true" tabindex="-1"></a>  .(iteration, cost, gamma, classif.ce)]</span>
<span id="cb108-543"><a href="#cb108-543" aria-hidden="true" tabindex="-1"></a><span class="fu">extract_inner_tuning_archives</span>(rr)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb108-544"><a href="#cb108-544" aria-hidden="true" tabindex="-1"></a>  .(iteration, cost, gamma, classif.ce)]</span>
<span id="cb108-545"><a href="#cb108-545" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-546"><a href="#cb108-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-547"><a href="#cb108-547" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Right (and Wrong) Way to Estimate Generalization Performance {#sec-resample-overfitting}</span></span>
<span id="cb108-548"><a href="#cb108-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-549"><a href="#cb108-549" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb108-550"><a href="#cb108-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-551"><a href="#cb108-551" aria-hidden="true" tabindex="-1"></a>In this short section we will demonstrate with a brief example that only nested resampling with the <span class="in">`$aggregate()`</span> method provides a reliable estimate of the model's generalization performance.</span>
<span id="cb108-552"><a href="#cb108-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-553"><a href="#cb108-553" aria-hidden="true" tabindex="-1"></a>We will do this by tuning and (un-nested) resampling a learner on training data and evaluating the in-sample performance, which is the performance of the best performing hyperparameter.</span>
<span id="cb108-554"><a href="#cb108-554" aria-hidden="true" tabindex="-1"></a>Then we will compute the out-of-sample, generalization, performance, which is the performance of the tuned learner trained on the full dataset and evaluated on a test dataset.</span>
<span id="cb108-555"><a href="#cb108-555" aria-hidden="true" tabindex="-1"></a>Finally, we will show how using nested resampling returns a good estimate of the generalization performance, even when only the training data is used.</span>
<span id="cb108-556"><a href="#cb108-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-557"><a href="#cb108-557" aria-hidden="true" tabindex="-1"></a>In this experiment we tune several parameters from <span class="in">`lrn("classif.xgboost")`</span>, in doing so we can simultaneously show that nested resampling returns the best estimate of the generalization performance *and* that the insample performance will be overly-optimistic if hyperparameters are 'meta'-overfitting the data (we use the term 'meta-overfitting' as they are overfitting to a subset of the training data during resampling as opposed to the full training data).</span>
<span id="cb108-558"><a href="#cb108-558" aria-hidden="true" tabindex="-1"></a>To best estimate the generalization performance we make use of the <span class="in">`"moons"`</span> <span class="in">`r ref("TaskGenerator", aside = TRUE)`</span>.</span>
<span id="cb108-559"><a href="#cb108-559" aria-hidden="true" tabindex="-1"></a>The <span class="in">`TaskGenerator`</span> class is used when you want to simulate data for use in experiments, these are very useful in cases such as this experiment when you need access to an infinite number of datapoints to estimate quantities such as the generalization error.</span>
<span id="cb108-560"><a href="#cb108-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-561"><a href="#cb108-561" aria-hidden="true" tabindex="-1"></a>We begin by loading our learner, task generator, and generating 100 training data points and 1,000,000 testing data points.</span>
<span id="cb108-562"><a href="#cb108-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-563"><a href="#cb108-563" aria-hidden="true" tabindex="-1"></a><span class="in">```{r exp1}</span></span>
<span id="cb108-564"><a href="#cb108-564" aria-hidden="true" tabindex="-1"></a>lrn_xgboost <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.xgboost"</span>,</span>
<span id="cb108-565"><a href="#cb108-565" aria-hidden="true" tabindex="-1"></a>  <span class="at">eta               =</span> <span class="fu">to_tune</span>(<span class="fl">1e-4</span>, <span class="dv">1</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-566"><a href="#cb108-566" aria-hidden="true" tabindex="-1"></a>  <span class="at">max_depth         =</span> <span class="fu">to_tune</span>(<span class="dv">1</span>, <span class="dv">20</span>),</span>
<span id="cb108-567"><a href="#cb108-567" aria-hidden="true" tabindex="-1"></a>  <span class="at">colsample_bytree  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb108-568"><a href="#cb108-568" aria-hidden="true" tabindex="-1"></a>  <span class="at">colsample_bylevel =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb108-569"><a href="#cb108-569" aria-hidden="true" tabindex="-1"></a>  <span class="at">lambda            =</span> <span class="fu">to_tune</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-570"><a href="#cb108-570" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha             =</span> <span class="fu">to_tune</span>(<span class="fl">1e-3</span>, <span class="fl">1e3</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>),</span>
<span id="cb108-571"><a href="#cb108-571" aria-hidden="true" tabindex="-1"></a>  <span class="at">subsample         =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>)</span>
<span id="cb108-572"><a href="#cb108-572" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-573"><a href="#cb108-573" aria-hidden="true" tabindex="-1"></a>tsk_moons <span class="ot">=</span> <span class="fu">tgen</span>(<span class="st">"moons"</span>)</span>
<span id="cb108-574"><a href="#cb108-574" aria-hidden="true" tabindex="-1"></a>tsk_moons_train <span class="ot">=</span> tsk_moons<span class="sc">$</span><span class="fu">generate</span>(<span class="dv">100</span>)</span>
<span id="cb108-575"><a href="#cb108-575" aria-hidden="true" tabindex="-1"></a>tsk_moons_test <span class="ot">=</span> tsk_moons<span class="sc">$</span><span class="fu">generate</span>(<span class="dv">1000000</span>)</span>
<span id="cb108-576"><a href="#cb108-576" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-577"><a href="#cb108-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-578"><a href="#cb108-578" aria-hidden="true" tabindex="-1"></a>Now we will tune the learner with respect to the classification error and use holdout resampling and random search with 700 evaluations, we compute the in-sample performance as the performance for the optimal hyperparameter configuration.</span>
<span id="cb108-579"><a href="#cb108-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-580"><a href="#cb108-580" aria-hidden="true" tabindex="-1"></a><span class="in">```{r exp2}</span></span>
<span id="cb108-581"><a href="#cb108-581" aria-hidden="true" tabindex="-1"></a>tnr_random <span class="ot">=</span> <span class="fu">tnr</span>(<span class="st">"random_search"</span>)</span>
<span id="cb108-582"><a href="#cb108-582" aria-hidden="true" tabindex="-1"></a>rsmp_holdout <span class="ot">=</span> <span class="fu">rsmp</span>(<span class="st">"holdout"</span>)</span>
<span id="cb108-583"><a href="#cb108-583" aria-hidden="true" tabindex="-1"></a>trm_evals700 <span class="ot">=</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">700</span>)</span>
<span id="cb108-584"><a href="#cb108-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-585"><a href="#cb108-585" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">tune</span>(</span>
<span id="cb108-586"><a href="#cb108-586" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_random,</span>
<span id="cb108-587"><a href="#cb108-587" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_moons_train,</span>
<span id="cb108-588"><a href="#cb108-588" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_xgboost,</span>
<span id="cb108-589"><a href="#cb108-589" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_holdout,</span>
<span id="cb108-590"><a href="#cb108-590" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> msr_ce,</span>
<span id="cb108-591"><a href="#cb108-591" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> trm_evals700</span>
<span id="cb108-592"><a href="#cb108-592" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-593"><a href="#cb108-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-594"><a href="#cb108-594" aria-hidden="true" tabindex="-1"></a>insample <span class="ot">=</span> instance<span class="sc">$</span>result_y</span>
<span id="cb108-595"><a href="#cb108-595" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-596"><a href="#cb108-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-597"><a href="#cb108-597" aria-hidden="true" tabindex="-1"></a>Next we compute the out-of-sample performance, which is the aggregate of scores over the outer resampling method (below we use 5-fold CV) using an <span class="in">`AutoTuner`</span>:</span>
<span id="cb108-598"><a href="#cb108-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-599"><a href="#cb108-599" aria-hidden="true" tabindex="-1"></a><span class="in">```{r exp3}</span></span>
<span id="cb108-600"><a href="#cb108-600" aria-hidden="true" tabindex="-1"></a><span class="co"># same setup as above</span></span>
<span id="cb108-601"><a href="#cb108-601" aria-hidden="true" tabindex="-1"></a>at <span class="ot">=</span> <span class="fu">auto_tuner</span>(</span>
<span id="cb108-602"><a href="#cb108-602" aria-hidden="true" tabindex="-1"></a>  <span class="at">tuner =</span> tnr_random,</span>
<span id="cb108-603"><a href="#cb108-603" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> lrn_xgboost,</span>
<span id="cb108-604"><a href="#cb108-604" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> rsmp_holdout,</span>
<span id="cb108-605"><a href="#cb108-605" aria-hidden="true" tabindex="-1"></a>  <span class="at">measure =</span> msr_ce,</span>
<span id="cb108-606"><a href="#cb108-606" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> trm_evals700</span>
<span id="cb108-607"><a href="#cb108-607" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-608"><a href="#cb108-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-609"><a href="#cb108-609" aria-hidden="true" tabindex="-1"></a>outsample <span class="ot">=</span> <span class="fu">resample</span>(tsk_moons_train, at, <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">5</span>))<span class="sc">$</span><span class="fu">aggregate</span>()</span>
<span id="cb108-610"><a href="#cb108-610" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-611"><a href="#cb108-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-612"><a href="#cb108-612" aria-hidden="true" tabindex="-1"></a>And finally we estimate the generalization error by training the tuned learner (i.e., using the values from the <span class="in">`instance`</span> above) on the full training data again and predicting on the test data.</span>
<span id="cb108-613"><a href="#cb108-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-614"><a href="#cb108-614" aria-hidden="true" tabindex="-1"></a><span class="in">```{r exp4}</span></span>
<span id="cb108-615"><a href="#cb108-615" aria-hidden="true" tabindex="-1"></a>lrn_xgboost_tuned <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.xgboost"</span>)</span>
<span id="cb108-616"><a href="#cb108-616" aria-hidden="true" tabindex="-1"></a>lrn_xgboost_tuned<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(</span>
<span id="cb108-617"><a href="#cb108-617" aria-hidden="true" tabindex="-1"></a>  <span class="at">.values =</span> instance<span class="sc">$</span>result_learner_param_vals)</span>
<span id="cb108-618"><a href="#cb108-618" aria-hidden="true" tabindex="-1"></a>generalization <span class="ot">=</span> lrn_xgboost_tuned<span class="sc">$</span><span class="fu">train</span>(tsk_moons_train)<span class="sc">$</span><span class="fu">predict</span>(tsk_moons_test)<span class="sc">$</span><span class="fu">score</span>()</span>
<span id="cb108-619"><a href="#cb108-619" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-620"><a href="#cb108-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-621"><a href="#cb108-621" aria-hidden="true" tabindex="-1"></a>Now we can compare these three values:</span>
<span id="cb108-622"><a href="#cb108-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-625"><a href="#cb108-625" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-626"><a href="#cb108-626" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">c</span>(<span class="at">generalization =</span> <span class="fu">as.numeric</span>(generalization),</span>
<span id="cb108-627"><a href="#cb108-627" aria-hidden="true" tabindex="-1"></a>  <span class="at">insample =</span> <span class="fu">as.numeric</span>(insample),</span>
<span id="cb108-628"><a href="#cb108-628" aria-hidden="true" tabindex="-1"></a>  <span class="at">outsample =</span> <span class="fu">as.numeric</span>(outsample)), <span class="dv">2</span>)</span>
<span id="cb108-629"><a href="#cb108-629" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-630"><a href="#cb108-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-631"><a href="#cb108-631" aria-hidden="true" tabindex="-1"></a>We find that the insample performance overestimates the model performance, which indicates meta-overfitting to the optimal hyperparameters.</span>
<span id="cb108-632"><a href="#cb108-632" aria-hidden="true" tabindex="-1"></a>The out-of-sample performance from nested resampling provides a much better estimate of the generalization performance, despite the nested resampling only accessing 100 data points and not all 1,000,000.</span>
<span id="cb108-633"><a href="#cb108-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-634"><a href="#cb108-634" aria-hidden="true" tabindex="-1"></a><span class="fu">## More Advanced Search Spaces {#sec-defining-search-spaces}</span></span>
<span id="cb108-635"><a href="#cb108-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-636"><a href="#cb108-636" aria-hidden="true" tabindex="-1"></a>Up until now we have only considered tuning overly simplistic search spaces limited to numeric hyperparameters.</span>
<span id="cb108-637"><a href="#cb108-637" aria-hidden="true" tabindex="-1"></a>In this section we will first look at how to tune different scalar parameter classes with <span class="in">`r ref("to_tune()")`</span>, and then how to define your own search space with <span class="in">`r ref("ParamSet")`</span> to create more advanced search spaces that may include tuning over vectors, transformations, and handling parameter dependencies.</span>
<span id="cb108-638"><a href="#cb108-638" aria-hidden="true" tabindex="-1"></a>Finally, we will consider how to access a database of standardized search spaces from the literature.</span>
<span id="cb108-639"><a href="#cb108-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-640"><a href="#cb108-640" aria-hidden="true" tabindex="-1"></a><span class="fu">### Scalar Parameter Tuning</span></span>
<span id="cb108-641"><a href="#cb108-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-642"><a href="#cb108-642" aria-hidden="true" tabindex="-1"></a>The <span class="in">`r ref("to_tune()")`</span> function can be used to tune parameters of any class, whether they are scalar or vectors.</span>
<span id="cb108-643"><a href="#cb108-643" aria-hidden="true" tabindex="-1"></a>To best understand this function, we will consider what is happening behind the scenes.</span>
<span id="cb108-644"><a href="#cb108-644" aria-hidden="true" tabindex="-1"></a>When <span class="in">`to_tune()`</span> is used in a learner, implicitly a <span class="in">`r ref("ParamSet")`</span> is created just for the tuning search space:</span>
<span id="cb108-645"><a href="#cb108-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-646"><a href="#cb108-646" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-039}</span></span>
<span id="cb108-647"><a href="#cb108-647" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-648"><a href="#cb108-648" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb108-649"><a href="#cb108-649" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="dv">1</span>),</span>
<span id="cb108-650"><a href="#cb108-650" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="st">"radial"</span>,</span>
<span id="cb108-651"><a href="#cb108-651" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb108-652"><a href="#cb108-652" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-653"><a href="#cb108-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-654"><a href="#cb108-654" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-655"><a href="#cb108-655" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-656"><a href="#cb108-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-657"><a href="#cb108-657" aria-hidden="true" tabindex="-1"></a>Recall from @sec-param-set, that the <span class="in">`class`</span> field corresponds to the hyperparameter class as defined in <span class="in">`r ref_pkg("paradox")`</span>.</span>
<span id="cb108-658"><a href="#cb108-658" aria-hidden="true" tabindex="-1"></a>In this example, we can see that <span class="in">`gamma`</span> hyperparameter has class <span class="in">`r ref("ParamDbl")`</span>, with <span class="in">`lower = 0.1`</span> and <span class="in">`upper = 1`</span>, which was automatically created by <span class="in">`to_tune()`</span> as we passed two numeric values to this function.</span>
<span id="cb108-659"><a href="#cb108-659" aria-hidden="true" tabindex="-1"></a>If we wanted to tune over a non-numeric hyperparameter, we can still use <span class="in">`to_tune()`</span>, which will 'guess' the correct class to construct in the resulting parameter set.</span>
<span id="cb108-660"><a href="#cb108-660" aria-hidden="true" tabindex="-1"></a>For example, say we wanted to tune the numeric <span class="in">`cost`</span>, factor <span class="in">`kernel`</span>, and logical <span class="in">`scale`</span> hyperparameter in our SVM:</span>
<span id="cb108-661"><a href="#cb108-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-664"><a href="#cb108-664" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-665"><a href="#cb108-665" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-666"><a href="#cb108-666" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">to_tune</span>(<span class="fl">1e-1</span>, <span class="fl">1e5</span>),</span>
<span id="cb108-667"><a href="#cb108-667" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="st">"radial"</span>, <span class="st">"linear"</span>)),</span>
<span id="cb108-668"><a href="#cb108-668" aria-hidden="true" tabindex="-1"></a>  <span class="at">shrinking =</span> <span class="fu">to_tune</span>(),</span>
<span id="cb108-669"><a href="#cb108-669" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"C-classification"</span></span>
<span id="cb108-670"><a href="#cb108-670" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-671"><a href="#cb108-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-672"><a href="#cb108-672" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-673"><a href="#cb108-673" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-674"><a href="#cb108-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-675"><a href="#cb108-675" aria-hidden="true" tabindex="-1"></a>Here the <span class="in">`kernel`</span> hyperparameter is a factor, so we simply pass in a vector corresponding to the levels we want to tune over.</span>
<span id="cb108-676"><a href="#cb108-676" aria-hidden="true" tabindex="-1"></a>The <span class="in">`shrinking`</span> hyperparameter is a logical, there are only two possible values this could take so we do not need to pass anything to <span class="in">`to_tune()`</span>, it will automatically recognize this is a logical from <span class="in">`learner$param_set`</span> and passes this detail to <span class="in">`learner$param_set$search_space()`</span>.</span>
<span id="cb108-677"><a href="#cb108-677" aria-hidden="true" tabindex="-1"></a>In fact, for factor parameters, we could also use <span class="in">`to_tune()`</span> without any arguments if we want to tune over all possible values:</span>
<span id="cb108-678"><a href="#cb108-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-681"><a href="#cb108-681" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-682"><a href="#cb108-682" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">kernel =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="st">"radial"</span>, <span class="st">"linear"</span>)))<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-683"><a href="#cb108-683" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-684"><a href="#cb108-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-685"><a href="#cb108-685" aria-hidden="true" tabindex="-1"></a>Finally, we can only use <span class="in">`to_tune()`</span> to treat numeric parameters as factors if we only want to discretize them over a small subset of possible values, for example if we wanted to find the optimal number of trees in a random forest we might only consider three scenarios: 100, 200, or 400 trees:</span>
<span id="cb108-686"><a href="#cb108-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-689"><a href="#cb108-689" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-690"><a href="#cb108-690" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.ranger"</span>, <span class="at">num.trees =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">400</span>)))<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-691"><a href="#cb108-691" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-692"><a href="#cb108-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-693"><a href="#cb108-693" aria-hidden="true" tabindex="-1"></a>Before we look at tuning over vectors, we must first learn how to create parameter sets from scratch.</span>
<span id="cb108-694"><a href="#cb108-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-695"><a href="#cb108-695" aria-hidden="true" tabindex="-1"></a>:::{.callout-warning}</span>
<span id="cb108-696"><a href="#cb108-696" aria-hidden="true" tabindex="-1"></a>Treating an integer as a factor for tuning results in “unordered” hyperparameters.</span>
<span id="cb108-697"><a href="#cb108-697" aria-hidden="true" tabindex="-1"></a>Therefore algorithms that make use of ordering information will perform worse when ordering is ignored.</span>
<span id="cb108-698"><a href="#cb108-698" aria-hidden="true" tabindex="-1"></a>For these algorithms, it would make more sense to define a <span class="in">`r ref("ParamDbl")`</span> or <span class="in">`r ref("ParamInt")`</span> (@sec-tune-ps) with a more fitting transformation (@sec-tune-trafo).</span>
<span id="cb108-699"><a href="#cb108-699" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb108-700"><a href="#cb108-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-701"><a href="#cb108-701" aria-hidden="true" tabindex="-1"></a><span class="fu">### Defining Search Spaces with `ps` {#sec-tune-ps}</span></span>
<span id="cb108-702"><a href="#cb108-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-703"><a href="#cb108-703" aria-hidden="true" tabindex="-1"></a>As we have seen, <span class="in">`r ref("to_tune()")`</span> is a helper function that creates a parameter set that will go on to be used by <span class="in">`r ref("tune()")`</span>/<span class="in">`r ref("ti()")`</span>/<span class="in">`r ref("auto_tuner()")`</span> during the tuning process.</span>
<span id="cb108-704"><a href="#cb108-704" aria-hidden="true" tabindex="-1"></a>However, there will be use-cases where you will need to create a parameter set manually using <span class="in">`r ref("paradox::ps()")`</span>.</span>
<span id="cb108-705"><a href="#cb108-705" aria-hidden="true" tabindex="-1"></a>This function takes named arguments of class <span class="in">`r ref("Param")`</span>, which can be created using the sugar functions in @tbl-paradox-define.</span>
<span id="cb108-706"><a href="#cb108-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-707"><a href="#cb108-707" aria-hidden="true" tabindex="-1"></a>| Constructor      | Description                          | Underlying Class    |</span>
<span id="cb108-708"><a href="#cb108-708" aria-hidden="true" tabindex="-1"></a>|------------------|--------------------------------------|---------------------|</span>
<span id="cb108-709"><a href="#cb108-709" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("p_dbl")`</span> | Real valued parameter ("double")     | <span class="in">`r ref("ParamDbl")`</span> |</span>
<span id="cb108-710"><a href="#cb108-710" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("p_int")`</span> | Integer parameter                    | <span class="in">`r ref("ParamInt")`</span> |</span>
<span id="cb108-711"><a href="#cb108-711" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("p_fct")`</span> | Discrete valued parameter ("factor") | <span class="in">`r ref("ParamFct")`</span> |</span>
<span id="cb108-712"><a href="#cb108-712" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("p_lgl")`</span> | Logical / Boolean parameter          | <span class="in">`r ref("ParamLgl")`</span> |</span>
<span id="cb108-713"><a href="#cb108-713" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("p_uty")`</span> | Untyped parameter                    | <span class="in">`r ref("ParamUty")`</span> |</span>
<span id="cb108-714"><a href="#cb108-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-715"><a href="#cb108-715" aria-hidden="true" tabindex="-1"></a>: <span class="in">`r ref("Domain")`</span> Constructors and their resulting <span class="in">`r ref("Param")`</span>. {#tbl-paradox-define}</span>
<span id="cb108-716"><a href="#cb108-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-717"><a href="#cb108-717" aria-hidden="true" tabindex="-1"></a>As a simple example, let us look at how to create a search space to tune <span class="in">`cost`</span> and <span class="in">`gamma`</span> again:</span>
<span id="cb108-718"><a href="#cb108-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-721"><a href="#cb108-721" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-722"><a href="#cb108-722" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb108-723"><a href="#cb108-723" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost  =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">1e-1</span>, <span class="at">upper =</span> <span class="fl">1e5</span>),</span>
<span id="cb108-724"><a href="#cb108-724" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">p_fct</span>(<span class="fu">c</span>(<span class="st">"radial"</span>, <span class="st">"linear"</span>)),</span>
<span id="cb108-725"><a href="#cb108-725" aria-hidden="true" tabindex="-1"></a>  <span class="at">shrinking =</span> <span class="fu">p_lgl</span>()</span>
<span id="cb108-726"><a href="#cb108-726" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-727"><a href="#cb108-727" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-728"><a href="#cb108-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-729"><a href="#cb108-729" aria-hidden="true" tabindex="-1"></a>This search space would then be passed to the <span class="in">`search_space`</span> argument in <span class="in">`auto_tuner()`</span>:</span>
<span id="cb108-730"><a href="#cb108-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-733"><a href="#cb108-733" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-734"><a href="#cb108-734" aria-hidden="true" tabindex="-1"></a><span class="fu">ti</span>(tsk_sonar, <span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">type =</span> <span class="st">"C-classification"</span>), rsmp_cv3,</span>
<span id="cb108-735"><a href="#cb108-735" aria-hidden="true" tabindex="-1"></a>  msr_ce, <span class="fu">trm</span>(<span class="st">"none"</span>), <span class="at">search_space =</span> search_space)</span>
<span id="cb108-736"><a href="#cb108-736" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-737"><a href="#cb108-737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-738"><a href="#cb108-738" aria-hidden="true" tabindex="-1"></a>:::{.callout-warning}</span>
<span id="cb108-739"><a href="#cb108-739" aria-hidden="true" tabindex="-1"></a>When manually creating search spaces, make sure all numeric hyperparameters in your search space are bounded, e.g., if you are trying to tune a hyperparameter that could take any in value $(-\infty, \infty)$ then the tuning process will throw an error if you do not pass lower and upper limits to <span class="in">`p_dbl()`</span> or <span class="in">`p_int()`</span>.</span>
<span id="cb108-740"><a href="#cb108-740" aria-hidden="true" tabindex="-1"></a>You can use <span class="in">`$is_bounded`</span> on the constructed <span class="in">`r ref("ParamSet")`</span> if you are unsure:</span>
<span id="cb108-741"><a href="#cb108-741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-742"><a href="#cb108-742" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-042}</span></span>
<span id="cb108-743"><a href="#cb108-743" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">0.1</span>, <span class="at">upper =</span> <span class="dv">1</span>))<span class="sc">$</span>is_bounded</span>
<span id="cb108-744"><a href="#cb108-744" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">0.1</span>, <span class="at">upper =</span> <span class="cn">Inf</span>))<span class="sc">$</span>is_bounded</span>
<span id="cb108-745"><a href="#cb108-745" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-746"><a href="#cb108-746" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb108-747"><a href="#cb108-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-748"><a href="#cb108-748" aria-hidden="true" tabindex="-1"></a><span class="fu">### Transformations and Tuning Over Vectors {#sec-tune-trafo}</span></span>
<span id="cb108-749"><a href="#cb108-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-750"><a href="#cb108-750" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb108-751"><a href="#cb108-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-752"><a href="#cb108-752" aria-hidden="true" tabindex="-1"></a>In @sec-logarithmic-transformations we saw how to quickly apply log transformations with <span class="in">`r ref("to_tune()")`</span>.</span>
<span id="cb108-753"><a href="#cb108-753" aria-hidden="true" tabindex="-1"></a>As you now know, <span class="in">`to_tune`</span> is just a wrapper that creates <span class="in">`r ref("ParamSet")`</span> objects, so let us look at what is actually taking place when we set <span class="in">`logscale = TRUE`</span>:</span>
<span id="cb108-754"><a href="#cb108-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-757"><a href="#cb108-757" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-758"><a href="#cb108-758" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">cost =</span> <span class="fu">to_tune</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">logscale =</span> <span class="cn">TRUE</span>))<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-759"><a href="#cb108-759" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-760"><a href="#cb108-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-761"><a href="#cb108-761" aria-hidden="true" tabindex="-1"></a>Notice that now the <span class="in">`lower`</span> and <span class="in">`upper`</span> fields correspond to the transformed bounds, i.e. $<span class="co">[</span><span class="ot">log(1e-5), log(1e5)</span><span class="co">]</span>$.</span>
<span id="cb108-762"><a href="#cb108-762" aria-hidden="true" tabindex="-1"></a>To manually create the same transformation, we can pass the transformation to the <span class="in">`trafo`</span> argument in <span class="in">`p_dbl()`</span>:</span>
<span id="cb108-763"><a href="#cb108-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-764"><a href="#cb108-764" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-045}</span></span>
<span id="cb108-765"><a href="#cb108-765" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) <span class="fu">exp</span>(x)))</span>
<span id="cb108-766"><a href="#cb108-766" aria-hidden="true" tabindex="-1"></a>search_space</span>
<span id="cb108-767"><a href="#cb108-767" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-768"><a href="#cb108-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-769"><a href="#cb108-769" aria-hidden="true" tabindex="-1"></a>In this case we do not see the transformation in the <span class="in">`lower`</span> and <span class="in">`upper`</span> fields, however we can confirm it is correctly set by making use of the <span class="in">`$trafo()`</span> method, which takes a named list and applies the specified transformations</span>
<span id="cb108-770"><a href="#cb108-770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-773"><a href="#cb108-773" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-774"><a href="#cb108-774" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>))</span>
<span id="cb108-775"><a href="#cb108-775" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-776"><a href="#cb108-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-777"><a href="#cb108-777" aria-hidden="true" tabindex="-1"></a>Where transformations become the most powerful is in the ability to pass arbitrary functions that can act on single parameters of the entire parameter set.</span>
<span id="cb108-778"><a href="#cb108-778" aria-hidden="true" tabindex="-1"></a>As an example, consider a simple transformation to add '2' to our range:</span>
<span id="cb108-779"><a href="#cb108-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-782"><a href="#cb108-782" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-783"><a href="#cb108-783" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(<span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) x <span class="sc">+</span> <span class="dv">2</span>))</span>
<span id="cb108-784"><a href="#cb108-784" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>))</span>
<span id="cb108-785"><a href="#cb108-785" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-786"><a href="#cb108-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-787"><a href="#cb108-787" aria-hidden="true" tabindex="-1"></a>Simple transformations such as this can even be added directly to a learner by passing a <span class="in">`Param`</span> object to <span class="in">`to_tune()`</span>:</span>
<span id="cb108-788"><a href="#cb108-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-791"><a href="#cb108-791" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-792"><a href="#cb108-792" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>, <span class="at">cost =</span> <span class="fu">to_tune</span>(<span class="fu">p_dbl</span>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) x <span class="sc">+</span> <span class="dv">2</span>)))</span>
<span id="cb108-793"><a href="#cb108-793" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-794"><a href="#cb108-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-795"><a href="#cb108-795" aria-hidden="true" tabindex="-1"></a>More complex transformations that require multiple arguments require the <span class="in">`.extra_trafo`</span> argument in <span class="in">`ps()`</span>:</span>
<span id="cb108-796"><a href="#cb108-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-799"><a href="#cb108-799" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-800"><a href="#cb108-800" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb108-801"><a href="#cb108-801" aria-hidden="true" tabindex="-1"></a>  <span class="at">cost =</span> <span class="fu">p_dbl</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="at">trafo =</span> <span class="cf">function</span>(x) <span class="fu">exp</span>(x)),</span>
<span id="cb108-802"><a href="#cb108-802" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">p_fct</span>(<span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)),</span>
<span id="cb108-803"><a href="#cb108-803" aria-hidden="true" tabindex="-1"></a>  <span class="at">.extra_trafo =</span> <span class="cf">function</span>(x, param_set) {</span>
<span id="cb108-804"><a href="#cb108-804" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (x<span class="sc">$</span>kernel <span class="sc">==</span> <span class="st">"polynomial"</span>) {</span>
<span id="cb108-805"><a href="#cb108-805" aria-hidden="true" tabindex="-1"></a>      x<span class="sc">$</span>cost <span class="ot">=</span> x<span class="sc">$</span>cost <span class="sc">+</span> <span class="dv">2</span></span>
<span id="cb108-806"><a href="#cb108-806" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb108-807"><a href="#cb108-807" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb108-808"><a href="#cb108-808" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb108-809"><a href="#cb108-809" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-810"><a href="#cb108-810" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>, <span class="at">kernel =</span> <span class="st">"radial"</span>))</span>
<span id="cb108-811"><a href="#cb108-811" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">cost =</span> <span class="dv">1</span>, <span class="at">kernel =</span> <span class="st">"polynomial"</span>))</span>
<span id="cb108-812"><a href="#cb108-812" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-813"><a href="#cb108-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-814"><a href="#cb108-814" aria-hidden="true" tabindex="-1"></a>In this transformation we first exponentiate the value of <span class="in">`cost`</span> and then add '2' if the <span class="in">`kernel`</span> is <span class="in">`"polynomial"`</span>. Note that <span class="in">`.extra_trafo`</span> takes a function with parameters <span class="in">`x`</span> and <span class="in">`param_set`</span>.</span>
<span id="cb108-815"><a href="#cb108-815" aria-hidden="true" tabindex="-1"></a>During tuning, <span class="in">`x`</span> will be a list containing the configuration being tested, and <span class="in">`param_set`</span> is the whole parameter set.</span>
<span id="cb108-816"><a href="#cb108-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-817"><a href="#cb108-817" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Vector transformations {.unnumbered .unlisted}</span></span>
<span id="cb108-818"><a href="#cb108-818" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-819"><a href="#cb108-819" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb108-820"><a href="#cb108-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-821"><a href="#cb108-821" aria-hidden="true" tabindex="-1"></a>Any function can be passed to <span class="in">`trafo`</span> and <span class="in">`.extra_trafo`</span>, which enables tuning of 'untyped' parameters of class <span class="in">`r ref("ParamUty")`</span> that could be vectors, functions, or any non-atomic class.</span>
<span id="cb108-822"><a href="#cb108-822" aria-hidden="true" tabindex="-1"></a>By example, consider the <span class="in">`class.weights`</span> parameter of the SVM, which takes a named vector of class weights with one entry for each target class.</span>
<span id="cb108-823"><a href="#cb108-823" aria-hidden="true" tabindex="-1"></a>To tune this parameter we could tune a scalar and then transform this to a vector:</span>
<span id="cb108-824"><a href="#cb108-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-825"><a href="#cb108-825" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-049}</span></span>
<span id="cb108-826"><a href="#cb108-826" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb108-827"><a href="#cb108-827" aria-hidden="true" tabindex="-1"></a>  <span class="at">class.weights =</span> <span class="fu">p_dbl</span>(<span class="at">lower =</span> <span class="fl">0.1</span>, <span class="at">upper =</span> <span class="fl">0.9</span>,</span>
<span id="cb108-828"><a href="#cb108-828" aria-hidden="true" tabindex="-1"></a>    <span class="at">trafo =</span> <span class="cf">function</span>(x) <span class="fu">c</span>(<span class="at">M =</span> x, <span class="at">R =</span> <span class="dv">1</span> <span class="sc">-</span> x))</span>
<span id="cb108-829"><a href="#cb108-829" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-830"><a href="#cb108-830" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-831"><a href="#cb108-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-832"><a href="#cb108-832" aria-hidden="true" tabindex="-1"></a>In other cases, we may need to tune two or more 'pseudoparameters' that do not exist in our learner's parameter set, but are required to tune a vector parameter.</span>
<span id="cb108-833"><a href="#cb108-833" aria-hidden="true" tabindex="-1"></a>For example, say we want to tune the architecture of a neural network, in which we need to decide the number of layers and the number of nodes in each layer, this is the case in the <span class="in">`num_nodes`</span> hyperparameter in the <span class="in">`lrn("surv.coxtime")`</span> learner.</span>
<span id="cb108-834"><a href="#cb108-834" aria-hidden="true" tabindex="-1"></a>In this case the learner expects a vector where each element corresponds to the number of nodes and the length corresponds to the number of layers.</span>
<span id="cb108-835"><a href="#cb108-835" aria-hidden="true" tabindex="-1"></a>We could then tune this as follows:</span>
<span id="cb108-836"><a href="#cb108-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-839"><a href="#cb108-839" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-840"><a href="#cb108-840" aria-hidden="true" tabindex="-1"></a>search_space <span class="ot">=</span> <span class="fu">ps</span>(</span>
<span id="cb108-841"><a href="#cb108-841" aria-hidden="true" tabindex="-1"></a>  <span class="at">num_layers =</span> <span class="fu">p_int</span>(<span class="at">lower =</span> <span class="dv">1</span>, <span class="at">upper =</span> <span class="dv">20</span>),</span>
<span id="cb108-842"><a href="#cb108-842" aria-hidden="true" tabindex="-1"></a>  <span class="at">num_nodes_per_layer =</span> <span class="fu">p_int</span>(<span class="dv">4</span>, <span class="dv">64</span>),</span>
<span id="cb108-843"><a href="#cb108-843" aria-hidden="true" tabindex="-1"></a>  <span class="at">.extra_trafo =</span> <span class="cf">function</span>(x, param_set) {</span>
<span id="cb108-844"><a href="#cb108-844" aria-hidden="true" tabindex="-1"></a>    x<span class="sc">$</span>num_nodes <span class="ot">=</span> <span class="fu">rep</span>(x<span class="sc">$</span>num_nodes_per_layer, x<span class="sc">$</span>num_layers)</span>
<span id="cb108-845"><a href="#cb108-845" aria-hidden="true" tabindex="-1"></a>    x<span class="sc">$</span>num_layers <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb108-846"><a href="#cb108-846" aria-hidden="true" tabindex="-1"></a>    x<span class="sc">$</span>num_nodes_per_layer <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb108-847"><a href="#cb108-847" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb108-848"><a href="#cb108-848" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb108-849"><a href="#cb108-849" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-850"><a href="#cb108-850" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-851"><a href="#cb108-851" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-852"><a href="#cb108-852" aria-hidden="true" tabindex="-1"></a>Here we are tuning the pseudo-parameter <span class="in">`num_layers`</span> between 1 and 20, then tuning the pseudo-parameter <span class="in">`num_nodes_per_layer`</span> between 4 and 64, then we are combining these into a vector called <span class="in">`num_nodes`</span> (the real hyperparameter) and removing the pseudo-parameters.</span>
<span id="cb108-853"><a href="#cb108-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-856"><a href="#cb108-856" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-857"><a href="#cb108-857" aria-hidden="true" tabindex="-1"></a>search_space<span class="sc">$</span><span class="fu">trafo</span>(<span class="fu">list</span>(<span class="at">num_layers =</span> <span class="dv">4</span>, <span class="at">num_nodes_per_layer =</span> <span class="dv">12</span>))</span>
<span id="cb108-858"><a href="#cb108-858" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-859"><a href="#cb108-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-860"><a href="#cb108-860" aria-hidden="true" tabindex="-1"></a>Once again, we could pass this straight to the learner using <span class="in">`to_tune()`</span> but this time passing the whole <span class="in">`ParamSet`</span> object:</span>
<span id="cb108-861"><a href="#cb108-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-864"><a href="#cb108-864" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-865"><a href="#cb108-865" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"surv.coxtime"</span>)</span>
<span id="cb108-866"><a href="#cb108-866" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(<span class="at">num_nodes =</span> <span class="fu">to_tune</span>(search_space))</span>
<span id="cb108-867"><a href="#cb108-867" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-868"><a href="#cb108-868" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-869"><a href="#cb108-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-870"><a href="#cb108-870" aria-hidden="true" tabindex="-1"></a>However note that in this case the transformation would only have access to the pseudo-hyperparameters and not the rest of the parameters in the learner's parameter set.</span>
<span id="cb108-871"><a href="#cb108-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-872"><a href="#cb108-872" aria-hidden="true" tabindex="-1"></a><span class="fu">### Hyperparameter Dependencies {#sec-optimization-depends}</span></span>
<span id="cb108-873"><a href="#cb108-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-874"><a href="#cb108-874" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb108-875"><a href="#cb108-875" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-876"><a href="#cb108-876" aria-hidden="true" tabindex="-1"></a>Hyperparameter dependencies occur when a hyperparameter should only be set if another hyperparameter has a particular value.</span>
<span id="cb108-877"><a href="#cb108-877" aria-hidden="true" tabindex="-1"></a>For example, the <span class="in">`degree`</span> parameter in SVM is only valid when <span class="in">`kernel`</span> is "polynomial".</span>
<span id="cb108-878"><a href="#cb108-878" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`r ref("ps()")`</span> function, we specify this using the <span class="in">`depends`</span> argument, which takes a named argument of the form <span class="in">`&lt;param&gt; == value`</span> or <span class="in">`&lt;param&gt; %in% &lt;vector&gt;`</span>:</span>
<span id="cb108-879"><a href="#cb108-879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-882"><a href="#cb108-882" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-883"><a href="#cb108-883" aria-hidden="true" tabindex="-1"></a><span class="fu">ps</span>(</span>
<span id="cb108-884"><a href="#cb108-884" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">p_fct</span>(<span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)),</span>
<span id="cb108-885"><a href="#cb108-885" aria-hidden="true" tabindex="-1"></a>  <span class="at">degree =</span> <span class="fu">p_int</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="at">depends =</span> (kernel <span class="sc">==</span> <span class="st">"polynomial"</span>)),</span>
<span id="cb108-886"><a href="#cb108-886" aria-hidden="true" tabindex="-1"></a>  <span class="at">gamma =</span> <span class="fu">p_dbl</span>(<span class="fl">1e-5</span>, <span class="fl">1e5</span>, <span class="at">depends =</span> (kernel <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)))</span>
<span id="cb108-887"><a href="#cb108-887" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-888"><a href="#cb108-888" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-889"><a href="#cb108-889" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-890"><a href="#cb108-890" aria-hidden="true" tabindex="-1"></a>Above we have said that <span class="in">`degree`</span> should only be set if <span class="in">`kernel`</span> is (<span class="in">`==`</span>) <span class="in">`"polynomial"`</span>, and <span class="in">`gamma`</span> should only be set if <span class="in">`kernel`</span> is one of (<span class="in">`%in%`</span>) <span class="in">`"polynomial"`</span>, <span class="in">`"radial"`</span>, or <span class="in">`"sigmoid"`</span>.</span>
<span id="cb108-891"><a href="#cb108-891" aria-hidden="true" tabindex="-1"></a>In practice, some underlying implementations ignore unused parameters and others throw errors, either way this is problematic during tuning if, for example, we were wasting time trying to tune <span class="in">`degree`</span> when the kernel was not polynomial.</span>
<span id="cb108-892"><a href="#cb108-892" aria-hidden="true" tabindex="-1"></a>Hence setting the dependency tells the tuning process to tune <span class="in">`degree`</span> iff <span class="in">`kernel`</span> is <span class="in">`"polynomial"`</span> and to ignore it otherwise.</span>
<span id="cb108-893"><a href="#cb108-893" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-894"><a href="#cb108-894" aria-hidden="true" tabindex="-1"></a>Dependencies can also be passed straight into a learner using <span class="in">`r ref("to_tune()")`</span>:</span>
<span id="cb108-895"><a href="#cb108-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-898"><a href="#cb108-898" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb108-899"><a href="#cb108-899" aria-hidden="true" tabindex="-1"></a><span class="fu">lrn</span>(<span class="st">"classif.svm"</span>,</span>
<span id="cb108-900"><a href="#cb108-900" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel =</span> <span class="fu">to_tune</span>(<span class="fu">c</span>(<span class="st">"polynomial"</span>, <span class="st">"radial"</span>)),</span>
<span id="cb108-901"><a href="#cb108-901" aria-hidden="true" tabindex="-1"></a>  <span class="at">degree =</span> <span class="fu">to_tune</span>(<span class="fu">p_int</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="at">depends =</span> (kernel <span class="sc">==</span> <span class="st">"polynomial"</span>)))</span>
<span id="cb108-902"><a href="#cb108-902" aria-hidden="true" tabindex="-1"></a>)<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">search_space</span>()</span>
<span id="cb108-903"><a href="#cb108-903" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-904"><a href="#cb108-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-905"><a href="#cb108-905" aria-hidden="true" tabindex="-1"></a><span class="fu">### Recommended Search Spaces with `mlr3tuningspaces` {#sec-tuning-spaces}</span></span>
<span id="cb108-906"><a href="#cb108-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-907"><a href="#cb108-907" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb108-908"><a href="#cb108-908" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-909"><a href="#cb108-909" aria-hidden="true" tabindex="-1"></a>Selected search spaces can require a lot of background knowledge or expertise.</span>
<span id="cb108-910"><a href="#cb108-910" aria-hidden="true" tabindex="-1"></a>The package <span class="in">`r ref_pkg("mlr3tuningspaces")`</span> tries to make HPO more accessible by providing implementations of published search spaces for many popular machine learning algorithms, the hope is that these search spaces are applicable to a wide range of datasets.</span>
<span id="cb108-911"><a href="#cb108-911" aria-hidden="true" tabindex="-1"></a>The search spaces are stored in the dictionary <span class="in">`r ref("mlr_tuning_spaces")`</span>.</span>
<span id="cb108-912"><a href="#cb108-912" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-913"><a href="#cb108-913" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-056,message=FALSE}</span></span>
<span id="cb108-914"><a href="#cb108-914" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mlr3tuningspaces)</span>
<span id="cb108-915"><a href="#cb108-915" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.table</span>(mlr_tuning_spaces)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, .(key, label)]</span>
<span id="cb108-916"><a href="#cb108-916" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-917"><a href="#cb108-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-918"><a href="#cb108-918" aria-hidden="true" tabindex="-1"></a>The tuning spaces are named according to the scheme <span class="in">`{learner-id}.{tuning-space-id}`</span>.</span>
<span id="cb108-919"><a href="#cb108-919" aria-hidden="true" tabindex="-1"></a>The <span class="in">`default`</span> tuning spaces are published in @hpo_practical, other tuning spaces are part of the random bot experiments <span class="in">`rbv1`</span> and <span class="in">`rbv2`</span> published in @kuehn_2018 and @binder2020.</span>
<span id="cb108-920"><a href="#cb108-920" aria-hidden="true" tabindex="-1"></a>The sugar function <span class="in">`r ref("lts()")`</span> is used to retrieve a <span class="in">`r ref("TuningSpace")`</span>.</span>
<span id="cb108-921"><a href="#cb108-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-922"><a href="#cb108-922" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-057}</span></span>
<span id="cb108-923"><a href="#cb108-923" aria-hidden="true" tabindex="-1"></a>lts_rpart <span class="ot">=</span> <span class="fu">lts</span>(<span class="st">"classif.rpart.default"</span>)</span>
<span id="cb108-924"><a href="#cb108-924" aria-hidden="true" tabindex="-1"></a>lts_rpart</span>
<span id="cb108-925"><a href="#cb108-925" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-926"><a href="#cb108-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-927"><a href="#cb108-927" aria-hidden="true" tabindex="-1"></a>A tuning space can be passed to <span class="in">`r ref("ti()")`</span> or <span class="in">`r ref("auto_tuner()")`</span> as the <span class="in">`search_space`</span>.</span>
<span id="cb108-928"><a href="#cb108-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-929"><a href="#cb108-929" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-058}</span></span>
<span id="cb108-930"><a href="#cb108-930" aria-hidden="true" tabindex="-1"></a>instance <span class="ot">=</span> <span class="fu">ti</span>(</span>
<span id="cb108-931"><a href="#cb108-931" aria-hidden="true" tabindex="-1"></a>  <span class="at">task =</span> tsk_sonar,</span>
<span id="cb108-932"><a href="#cb108-932" aria-hidden="true" tabindex="-1"></a>  <span class="at">learner =</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>),</span>
<span id="cb108-933"><a href="#cb108-933" aria-hidden="true" tabindex="-1"></a>  <span class="at">resampling =</span> <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">3</span>),</span>
<span id="cb108-934"><a href="#cb108-934" aria-hidden="true" tabindex="-1"></a>  <span class="at">measures =</span> <span class="fu">msr</span>(<span class="st">"classif.ce"</span>),</span>
<span id="cb108-935"><a href="#cb108-935" aria-hidden="true" tabindex="-1"></a>  <span class="at">terminator =</span> <span class="fu">trm</span>(<span class="st">"evals"</span>, <span class="at">n_evals =</span> <span class="dv">20</span>),</span>
<span id="cb108-936"><a href="#cb108-936" aria-hidden="true" tabindex="-1"></a>  <span class="at">search_space =</span> lts_rpart</span>
<span id="cb108-937"><a href="#cb108-937" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb108-938"><a href="#cb108-938" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-939"><a href="#cb108-939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-940"><a href="#cb108-940" aria-hidden="true" tabindex="-1"></a>Alternatively, as loaded search spaces are just a collection of tune tokens, we could also pass these straight to a learner:</span>
<span id="cb108-941"><a href="#cb108-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-942"><a href="#cb108-942" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-059}</span></span>
<span id="cb108-943"><a href="#cb108-943" aria-hidden="true" tabindex="-1"></a>vals <span class="ot">=</span> lts_rpart<span class="sc">$</span>values</span>
<span id="cb108-944"><a href="#cb108-944" aria-hidden="true" tabindex="-1"></a>vals</span>
<span id="cb108-945"><a href="#cb108-945" aria-hidden="true" tabindex="-1"></a>learner <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>)</span>
<span id="cb108-946"><a href="#cb108-946" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set<span class="sc">$</span><span class="fu">set_values</span>(<span class="at">.values =</span> vals)</span>
<span id="cb108-947"><a href="#cb108-947" aria-hidden="true" tabindex="-1"></a>learner<span class="sc">$</span>param_set</span>
<span id="cb108-948"><a href="#cb108-948" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-949"><a href="#cb108-949" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-950"><a href="#cb108-950" aria-hidden="true" tabindex="-1"></a>We could also apply the default search spaces from @hpo_practical by passing the learner to <span class="in">`r ref("lts()")`</span>:</span>
<span id="cb108-951"><a href="#cb108-951" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-952"><a href="#cb108-952" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-060}</span></span>
<span id="cb108-953"><a href="#cb108-953" aria-hidden="true" tabindex="-1"></a><span class="fu">lts</span>(<span class="fu">lrn</span>(<span class="st">"classif.rpart"</span>))</span>
<span id="cb108-954"><a href="#cb108-954" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-955"><a href="#cb108-955" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-956"><a href="#cb108-956" aria-hidden="true" tabindex="-1"></a>Finally, it is possible to overwrite a predefined tuning space in construction, for example changing the range of the <span class="in">`maxdepth`</span> hyperparameter in a decision tree:</span>
<span id="cb108-957"><a href="#cb108-957" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-958"><a href="#cb108-958" aria-hidden="true" tabindex="-1"></a><span class="in">```{r optimization-061}</span></span>
<span id="cb108-959"><a href="#cb108-959" aria-hidden="true" tabindex="-1"></a><span class="fu">lts</span>(<span class="st">"classif.rpart.rbv2"</span>, <span class="at">maxdepth =</span> <span class="fu">to_tune</span>(<span class="dv">1</span>, <span class="dv">20</span>))</span>
<span id="cb108-960"><a href="#cb108-960" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb108-961"><a href="#cb108-961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-962"><a href="#cb108-962" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb108-963"><a href="#cb108-963" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-964"><a href="#cb108-964" aria-hidden="true" tabindex="-1"></a>In this chapter, we learned how to optimize a model using tuning instances, about different tuners and terminators, search spaces and transformations, how to make use of automated methods for quicker implementation in larger experiments, and the importance of nested resampling.</span>
<span id="cb108-965"><a href="#cb108-965" aria-hidden="true" tabindex="-1"></a>The most important functions and classes we learned about are in @tbl-api-optimization alongside their R6 classes.</span>
<span id="cb108-966"><a href="#cb108-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-967"><a href="#cb108-967" aria-hidden="true" tabindex="-1"></a>| S3 function | R6 Class | Summary |</span>
<span id="cb108-968"><a href="#cb108-968" aria-hidden="true" tabindex="-1"></a>| ------------------- | -------- | -------------------- |</span>
<span id="cb108-969"><a href="#cb108-969" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("tnr()")`</span>   | <span class="in">`r ref("Tuner")`</span> | Determines an optimization algorithm |</span>
<span id="cb108-970"><a href="#cb108-970" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("trm()")`</span> | <span class="in">`r ref("Terminator")`</span> | Controls when to terminate the tuning algorithm |</span>
<span id="cb108-971"><a href="#cb108-971" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("ti()")`</span> | <span class="in">`r ref("TuningInstanceSingleCrit")`</span> or <span class="in">`r ref("TuningInstanceMultiCrit")`</span> | Stores tuning settings and save results |</span>
<span id="cb108-972"><a href="#cb108-972" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("paradox::to_tune()")`</span> | <span class="in">`r ref("paradox::TuneToken")`</span> | Sets which parameters in a learner to tune and over what search space |</span>
<span id="cb108-973"><a href="#cb108-973" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("auto_tuner()")`</span> | <span class="in">`r ref("AutoTuner")`</span> | Automates the tuning process |</span>
<span id="cb108-974"><a href="#cb108-974" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("extract_inner_tuning_results()")`</span>  | -                    | Extracts inner results from nested resampling |</span>
<span id="cb108-975"><a href="#cb108-975" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("extract_inner_tuning_archives()")`</span> | -                    | Extracts inner archives from nested resampling |</span>
<span id="cb108-976"><a href="#cb108-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-977"><a href="#cb108-977" aria-hidden="true" tabindex="-1"></a>:Core S3 'sugar' functions for model optimization in <span class="in">`mlr3`</span> with the underlying R6 class that are constructed when these functions are called (if applicable) and a summary of the purpose of the functions. {#tbl-api-optimization}</span>
<span id="cb108-978"><a href="#cb108-978" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-979"><a href="#cb108-979" aria-hidden="true" tabindex="-1"></a>We have a few practical examples of tuning that may be useful for more specific use-cases, including:</span>
<span id="cb108-980"><a href="#cb108-980" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-981"><a href="#cb108-981" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Optimizing an rpart classification tree with only a <span class="in">`r link("https://mlr-org.com/gallery/2022-11-10-hyperparameter-optimization-on-the-palmer-penguins/", "few lines of code")`</span>.</span>
<span id="cb108-982"><a href="#cb108-982" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Tuning an XGBoost model with <span class="in">`r link("https://mlr-org.com/gallery/2022-11-04-early-stopping-with-xgboost/", "early stopping")`</span>.</span>
<span id="cb108-983"><a href="#cb108-983" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Loading and tuning search spaces with <span class="in">`r link("https://mlr-org.com/gallery/2021-07-06-introduction-to-mlr3tuningspaces/", "mlr3tuningspaces")`</span>.</span>
<span id="cb108-984"><a href="#cb108-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-985"><a href="#cb108-985" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercises</span></span>
<span id="cb108-986"><a href="#cb108-986" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-987"><a href="#cb108-987" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Tune the <span class="in">`mtry`</span>, <span class="in">`sample.fraction`</span>, <span class="in">` num.trees`</span> hyperparameters of a random forest model (<span class="in">`lrn("regr.ranger")`</span>) on the <span class="in">`tsk("mtcars")`</span> task.</span>
<span id="cb108-988"><a href="#cb108-988" aria-hidden="true" tabindex="-1"></a>Use a simple random search with 50 evaluations and select a suitable batch size.</span>
<span id="cb108-989"><a href="#cb108-989" aria-hidden="true" tabindex="-1"></a>Evaluate with a 3-fold CV and the root mean squared error.</span>
<span id="cb108-990"><a href="#cb108-990" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Evaluate the performance of the model created in Question 1 with nested resampling.</span>
<span id="cb108-991"><a href="#cb108-991" aria-hidden="true" tabindex="-1"></a>Use a holdout validation for the inner resampling and a 3-fold CV for the outer resampling.</span>
<span id="cb108-992"><a href="#cb108-992" aria-hidden="true" tabindex="-1"></a>Print the unbiased performance estimate of the model.</span>
<span id="cb108-993"><a href="#cb108-993" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Tune and benchmark an XGBoost model against a logistic regression and determine which has the best Brier score.</span>
<span id="cb108-994"><a href="#cb108-994" aria-hidden="true" tabindex="-1"></a>Use mlr3tuningspaces and nested resampling.</span>
<span id="cb108-995"><a href="#cb108-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-996"><a href="#cb108-996" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb108-997"><a href="#cb108-997" aria-hidden="true" tabindex="-1"></a><span class="in">`r citeas(chapter)`</span></span>
<span id="cb108-998"><a href="#cb108-998" aria-hidden="true" tabindex="-1"></a>:::</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">All content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> <br> © Bernd Bischl, Raphael Sonabend, Lars Kotthoff, Michel Lang.</div>   
    <div class="nav-footer-center"><a href="https://mlr-org.com">Website</a> | <a href="https://github.com/mlr-org/mlr3book">GitHub</a> | <a href="https://mlr-org.com/gallery">Gallery</a> | <a href="https://lmmisld-lmu-stats-slds.srv.mwn.de/mlr_invite/">Mattermost</a></div>
    <div class="nav-footer-right">Built with <a href="https://quarto.org/">Quarto</a>.</div>
  </div>
</footer>


<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>