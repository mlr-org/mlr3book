# Introduction and Overview {#sec-introduction}

{{< include _setup.qmd >}}

`r authors("Introduction and Overview")`

Welcome to the **M**achine **L**earning in **R** universe (mlr3verse)!
Before we begin, make sure you have installed `r mlr3` if you want to follow along.
We recommend installing the complete `r mlr3verse`, which will install all of the important packages.

```{r C0 install mlr3verse, eval = FALSE}
install.packages("mlr3verse")
```

Or you can install just the base package:

```{r C0 install mlr3, eval = FALSE}
install.packages("mlr3")
```

In our first example, we will show you some of the most basic functionality -- training a model and making predictions.

```{r C0 egBasic}
library(mlr3)
task = tsk("penguins")
split = partition(task)
learner = lrn("classif.rpart")

learner$train(task, row_ids = split$train)
learner$model

predictions = learner$predict(task, row_ids = split$test)
predictions

predictions$score(msr("classif.acc"))
```

In this example, we trained a decision tree on a subset of the `penguins` dataset, made predictions on the rest of the data and then evaluated these with the accuracy measure. In @sec-basics we will break this down in more detail.

`r mlr3` makes training and predicting easy, but it also allows us to perform very complex operations in just a few lines of code:

```{r C0 egHard, output = FALSE}
library(mlr3verse)
library(mlr3pipelines)
library(mlr3benchmark)

tasks = tsks(c("breast_cancer", "sonar"))
tuned_rf = auto_tuner(
    tnr("grid_search", resolution = 5),
    lrn("classif.ranger", num.trees = to_tune(200, 500)),
    rsmp("holdout")
)
tuned_rf = pipeline_robustify(NULL, tuned_rf, TRUE) %>>%
    po("learner", tuned_rf)
stack_lrn = ppl(
    "stacking",
    base_learners = lrns(c("classif.rpart", "classif.kknn")),
    lrn("classif.log_reg"))
stack_lrn = pipeline_robustify(NULL, stack_lrn, TRUE) %>>%
    po("learner", stack_lrn)

learners = c(tuned_rf, stack_lrn)
bm = benchmark(benchmark_grid(tasks, learners, rsmp("holdout")))
```

```{r C0 egHardOut}
bma = bm$aggregate(msr("classif.acc"))[, c("task_id", "learner_id",
  "classif.acc")]
bma$learner_id = rep(c("RF", "Stack"), 2)
bma

as_benchmark_aggr(bm)$friedman_test()
```

In this (much more complex!) example we chose two tasks and two machine learning (ML) algorithms ("learners" in `r mlr3` terms).
We used automated tuning to optimize the number of trees in the random forest learner (@sec-optimization) and a ML pipeline that imputes missing data, collapses factor levels, and creates stacked models (@sec-pipelines).
We also showed basic features like loading learners (@sec-basics) and choosing resampling strategies for benchmarking (@sec-performance).
Finally, we compared the performance of the models using the mean accuracy on the test set, and applied a statistical test to see if the learners performed significantly different (they did not!).

You will learn how to do all this and more in this book.
We will walk through the functionality offered by `r mlr3` and the packages in the `r mlr3verse` step by step.
There are a few different ways you can use this book, which we will discuss next.

## Target audience and how to use this book {#howtouse}

The mlr3 ecosystem is the result of many years of methodological and applied research and improving the design and implementation of the packages over the years.
This book describes the resulting features of the `r mlr3verse` and discusses best practices for ML, technical implementation details, extension guidelines, and in-depth considerations for optimizing ML.
It is suitable for a wide range of readers and levels of ML expertise but we assume that users of `r mlr3` have taken an introductory machine learning course or have the equivalent expertise and some basic experience with R.
A background in computer science or statistics is beneficial for understanding the advanced functionality described in the later chapters of this book, but not required.
A comprehensive introduction for those new to machine learning can be found in [@james_introduction_2014], and [@Wickham2017R] gives a comprehensive introduction to data science in R.
This book may also be helpful for both **practitioners** who want to quickly apply machine learning algorithms and **researchers** who want to implement, benchmark, and compare their new methods in a structured environment.

@sec-introduction, @sec-basics, and @sec-performance cover the basics of mlr3.
These chapters are essential to understanding the core infrastrucure of ML in mlr3.
We recommend that all readers study these chapters to become familiar with basic mlr3 terminology, syntax, and style.
@sec-optimization, @sec-feature-selection, @sec-pipelines, and @sec-preprocessing contain more advanced implementation details and some ML theory.
@sec-special delves into detail on domain-specific methods that are implemented in our extension packages.
Readers may choose to selectively read sections in this chapter depending on your use cases (i.e., if you have domain-specific problems to tackle), or to use these as introductions to new domains to explore.
@sec-technical contains technical implementation details that are essential reading for advanced users who require parallelisation, custom error handling, and fine control over hyperparameters and large databases.
Finally, @sec-interpretation discusses packages that can be integrated with mlr3 to provide model-agnostic interpretability methods.

Of course, you can also read the book cover to cover from start to finish.
We have marked sections that are particularly complex, with respect to either technical or methodological detail, as 'optional'.

Each chapter includes tutorials, API references, explanations of methodologies, and exercises to test yourself on what you have learnt.
You can find the solutions to these exercises in @sec-solutions.

If you want to reproduce any of the results in this book, note that at the start of each chapter we run `set.seed(123)` and the `sessionInfo` at the time of publication is printed in @sec-session-info.

## Installation guidelines {#installguide}

All packages in the mlr3 ecosystem can be installed from GitHub and R-universe; the majority (but not all) packages can also be installed from CRAN.
We recommend adding the mlr-org R-universe[^runiverse] to your R options so that you can install all packages with `install.packages()` without having to worry which package repository it comes from.
To do this, install the `r ref_pkg("usethis")` package and run the following:

[^runiverse]: R-universe is an alternative package repository to CRAN. The bit of code below tells R to look at both R-universe and CRAN when trying to install packages. R will always install the latest version of a package.

```{r universe1, eval = FALSE}
usethis::edit_r_profile()
```

In the file that opens add or change the `repos` argument in `options` so it looks something like this (you might need to add the full code block below or just edit the existing `options` function).

```{r universe2, eval = FALSE}
options(repos = c(
  mlrorg = "https://mlr-org.r-universe.dev",
  CRAN = "https://cloud.r-project.org/"
))
```

Save the file, restart your R session, and you are ready to go!

```{r install verse, eval = FALSE}
install.packages("mlr3verse")
```

If you want the latest development version of any of our packages, run

```{r remotes, eval = FALSE}
remotes::install_github("mlr-org/{pkg}")
```

with `{pkg}` replaced with the name of the package you want to install (e.g., `remotes::install_github("mlr-org/mlr3tuning")`).
You can see an up-to-date list of all our extension packages at `r link("https://github.com/mlr-org/mlr3/wiki/Extension-Packages")`.

## Community links

The mlr community is open to all and we welcome everybody, from those completely new to ML and R to advanced coders and professional data scientists.
You can reach us on our `r link("https://lmmisld-lmu-stats-slds.srv.mwn.de/signup_email?id=6n7n67tdh7d4bnfxydqomjqspo", "Mattermost")`.

For case studies and how-to guides, check out the `r link("https://mlr-org.com/gallery.html", "mlr3gallery")` for extended practical blog posts.
For updates on mlr you might find `r link("https://mlr-org.com/blog.html", "our blog")` a useful point of reference.

We appreciate all contributions, whether they are bug reports, feature requests, or pull requests that fix bugs or extend functionality.
Each of our GitHub repositories includes issues and pull request templates to ensure we can help you as much as possible to get started.
Please make sure you read our `r link("https://github.com/mlr-org/mlr3/blob/main/.github/CODE_OF_CONDUCT.md", "code of conduct")` and `r link("https://github.com/mlr-org/mlr3/blob/main/CONTRIBUTING.md", "contribution guidelines")`.
With so many packages in our universe it may be hard to keep track of where to open issues.
As a general rule:

1. If you have a question about using any part of the mlr3 ecosystem, ask on [StackOverflow](https://stackoverflow.com/) and use the tag #mlr3 -- one of our team will answer you there.
Be sure to include a reproducible example (reprex) and if we think you found a bug then we will refer you to the relevant GitHub repository.
1. Bug reports or pull requests about core functionality (train, predict, etc.) should be opened in the [mlr3](https://github.com/mlr3) GitHub repository.
1. Bug reports or pull requests about learners should be opened in the [mlr3extralearners](https://github.com/mlr3extralearners) GitHub repository.
1. Bug reports or pull requests about measures should be opened in the [mlr3measures](https://github.com/mlr3measures) GitHub repository.
1. Bug reports or pull requests about domain specific functionality should be opened in the GitHub repository of the respective package (see @sec-introduction).

Do not worry about opening an issue in the wrong place, we will transfer it to the right one.

## mlr3book style guide {#styleguide}

Throughout this book we will use our own style guide that can be found in the `r link("https://github.com/mlr-org/mlr3/wiki/Style-Guide", "mlr3 wiki")`.
Below are the most important style choices relevant to the book.

1. We always use `=` instead of `<-` for assignment.
2. Class names are in `UpperCamelCase`
3. Function and method names are in `lower_snake_case`
4. When referencing functions, we will only include the package prefix (e.g., `pkg::function`) for functions outside the mlr3 universe or when there may be ambiguity about in which package the function lives. Note you can use `environment(function)` to see which namespace a function is loaded from.
5. We denote packages, fields, methods, and functions as follows:

    * `package` - With link (if online) to package CRAN, R-Universe, or GitHub page
    * `package::function()` (for functions _outside_ the mlr-org ecosystem)
    * `function()` (for functions _inside_ the mlr-org ecosystem)
    * `$field` for fields (data encapsulated in a R6 class)
    * `$method()` for methods (functions encapsulated in a R6 class)

## MLR: Machine Learning in R

The (**M**achine **L**earning in **R**) `r mlr3` [@mlr3] package and ecosystem provide a generic, `r index("object-oriented")`, and extensible framework for `r define("regression")` (@sec-tasks), `r define("classification")` (@sec-classif), and other machine learning `r define("tasks")` (@sec-special) for the R language [@R].
This unified interface provides functionality to extend and combine existing machine learning algorithms (`r define("Learners")` (@sec-learners)), intelligently select and tune the most appropriate technique for a given machine learning task (@sec-tasks), and perform large-scale comparisons that enable meta-learning.
Examples of this advanced functionality include hyperparameter tuning ([@sec-optimization]) and feature selection ([@sec-feature-selection]).
Parallelization of many operations is natively supported (@sec-parallelization).

`r mlr3` has similar overall aims to `r ref_pkg("caret")` and `r ref_pkg("tidymodels")` for R, `r link("https://scikit-learn.org/", "scikit-learn")` for Python, and `r link("https://alan-turing-institute.github.io/MLJ.jl/dev/", "MLJ")` for Julia.
In general `r mlr3` is designed to provide more flexibility than other machine learning frameworks while still offering easy ways to use advanced functionality.
While tidymodels in particular makes it very easy to perform simple machine learning tasks, `r mlr3` is more geared towards advanced machine learning.
To get a quick overview of how to do things in `r mlr3`, see the `r link("https://cheatsheets.mlr-org.com/", "mlr3 cheatsheets")`.

::: callout-note
`r mlr3` provides a unified interface to existing learners in R.
With few exceptions, we do not implement any learners ourselves, although we often augment the functionality provided by the underlying learners.
This includes, in particular, the definition of hyperparameter spaces for tuning.
:::

## From mlr to mlr3

The `r ref_pkg("mlr")` package [@mlr] was first released to `r link("https://cran.r-project.org", "CRAN")` in 2013, with the core design and architecture dating back much further.
Over time, the addition of many features has led to a considerably more complex design that made it harder to build, maintain, and extend than we had hoped for.
In hindsight, we saw that some design and architecture choices in `r ref_pkg("mlr")` made it difficult to support new features, in particular with respect to machine learning pipelines.
Furthermore, the R ecosystem and helpful packages such as `r ref_pkg("data.table")` have undergone major changes after the initial design of `r ref_pkg("mlr")`.

It would have been difficult to integrate all of these changes into the original design of `r ref_pkg("mlr")`.
Instead, we decided to start working on a reimplementation in 2018, which resulted in the first release of `r mlr3` on CRAN in July 2019.

The new design and the integration of further and newly-developed R packages (especially `r ref_pkg("R6")`, `r ref_pkg("future")`, and `r ref_pkg("data.table")`) makes `r mlr3` much easier to use, maintain, and in many regards more efficient than its predecessor `r ref_pkg("mlr")`.
The packages in the ecosystem are less tightly coupled, making them easier to maintain and easier to develop, especially very specialized packages.

## Design principles

{{< include _optional.qmd >}}

We follow these general design principles in the `r mlr3` package and `r mlr3verse` ecosystem.

*   **Object-oriented programming (OOP)**.
We embrace `r ref_pkg("R6")` for a clean, object-oriented design, object state-changes, and reference semantics.
This means that the state of common objects (e.g. tasks (@sec-tasks) and learners (@sec-learners)) is encapsulated within the object, for example to keep track of whether a model has been trained, without the user having to worry about this.
We also use inheritance to specialize objects, e.g. all learners are derived from a common base class that provides basic functionality.
*   **Tabular data**.
Embrace `r ref_pkg("data.table")` for its top-notch computation performance as well as tabular data as a structure that can be easily processed further.
*   **Unify input and output data formats.**
This considerably simplifies the API and allows easy selection and "split-apply-combine" (aggregation) operations.
We combine `data.table` and `R6` to place references to non-atomic and compound objects in tables and make heavy use of list columns.
*   **Defensive programming and type safety**.
All user input is checked with `r ref_pkg("checkmate")` [@checkmate].
We use data.table which documents return types unlike other mechanisms popular in base R which "simplify" the result unpredictably (e.g., `sapply()` or the `drop` argument for indexing data.frames).
And we have extensive unit tests!
*   **Light on dependencies**.
One of the main maintenance burdens for `r ref_pkg("mlr")` was to keep up with changing learner interfaces and behavior of the many packages it depended on.
We require far fewer packages in `r mlr3`, which makes installation and maintenance easier.
We still provide the same functionality, but it is split into more packages that have fewer dependencies individually.
One benefit of having the visualization functionality in a separate package, for example, is that the user can use mlr3 for ML operations without having to install graphical dependencies.
*   **Separation of computation and presentation**.
Most packages of the `r mlr3` ecosystem focus on processing and transforming data, applying machine learning algorithms, and computing results.
Our core packages do not provide visualizations because their dependencies would make installation unnecessarily complex, especially on headless servers (i.e. computers without a monitor where graphical libraries are not installed).
For the same reason, visualizations of data and results are provided in the extra package `r mlr3viz`, which avoids dependencies on `ggplot2`.

## Package ecosystem

`r mlr3` depends on the following popular and well-established packages that are not developed by core members of the `r mlr3` team:

*   `r ref_pkg("R6")`: The class system predominantly used in mlr3.
*   `r ref_pkg("data.table")`: High-performance extension of R's `data.frame`.
*   `r ref_pkg("digest")`: Cryptographic hash functions.
*   `r ref_pkg("uuid")`: Generation of universally unique identifiers.
*   `r ref_pkg("lgr")`: Highly configurable logging library.
*   `r ref_pkg("mlbench")` and `r ref_pkg("palmerpenguins")`: More machine learning data sets.
*   `r ref_pkg("evaluate")`: For capturing output, warnings, and exceptions (@sec-error-handling).
*   `r ref_pkg("future")` / `r ref_pkg("future.apply")` / `r ref_pkg("parallelly")`: For parallelization (@sec-parallelization).

The `r mlr3` package itself provides the base functionality that the rest of ecosystem (`mlr3verse`) relies on and the fundamental building blocks for machine learning.
@fig-mlr3verse shows the packages in the `mlr3verse` that extend `r mlr3` with capabilities for preprocessing, pipelining, visualizations, additional learners, additional task types, and more.

```{r intro-001, echo = FALSE, fig.align='center', out.width="98%", eval=knitr::is_html_output()}
#| label: fig-mlr3verse
#| fig-cap: Overview of the `mlr3` ecosystem, the `mlr3verse`.
#| fig-alt: Diagram showing the packages of the mlr3verse and their relationship.
knitr::include_graphics("https://raw.githubusercontent.com/mlr-org/mlr3/master/man/figures/mlr3verse.svg")
```

:::{.callout-tip}
Instead of loading multiple extension packages individually, it is often more convenient to load the `r mlr3verse` package instead.
It makes the functions from most `r mlr3` packages that are used for common machine learning and data science tasks available.
:::

::: callout-tip
A complete list with links to the repositories for the respective packages can be found on our `r link("https://mlr-org.com/ecosystem.html", "package overview page")`.
:::

We build on `r ref_pkg("R6")` for object orientation and `r ref_pkg("data.table")` to store and operate on tabular data.
Both are core to `r mlr3`; we briefly introduce both packages for beginners.
While in-depth expertise with these packages is not necessary, a basic understanding is required to work effectively with `r mlr3`.

## How R6 & data.table apply to `r mlr3`

### Quick R6 introduction for beginners {#sec-r6}

`r ref_pkg("R6")` is one of R's more recent paradigm for object-oriented programming (OOP).
It addresses shortcomings of earlier OO implementations in R, such as S3, which we used in `r ref_pkg("mlr")`.
If you have done any object-oriented programming before, R6 should feel familiar.
We focus on the parts of R6 that you need to know to use `r mlr3`.

Objects are created by calling the constructor of an `R6::R6Class()` object, specifically the initialization method `$new()`.
For example, `foo = Foo$new(bar = 1)` creates a new object of class `Foo`, setting the `bar` argument of the constructor to the value `1`.

Objects have mutable state that is encapsulated in their fields, which can be accessed through the dollar operator.
We can access the `bar` value in the `foo` variable from above through `foo$bar` and set its value by assigning the field, e.g. `foo$bar = 2`.

In addition to fields, objects expose methods that allow to inspect the object's state, retrieve information, or perform an action that changes the internal state of the object.
For example, the `$train()` method of a learner changes the internal state of the learner by building and storing a model, which can then be used to make predictions.

Objects can have public and private fields and methods.
The public fields and methods define the API to interact with the object.
Private methods are only relevant for you if you want to extend `r mlr3`, e.g. with new learners.

Technically, R6 objects are environments, and as such have reference semantics.
For example, `foo2 = foo` does not create a copy of `foo` in `foo2`, but another reference to the same actual object.
Setting `foo$bar = 3` will also change `foo2$bar` to `3` and vice versa.

To copy an object, use the `$clone()` method and the `deep = TRUE` argument for nested objects, for example, `foo2 = foo$clone(deep = TRUE)`.

::: callout-tip
For more details on R6, have a look at the excellent `r link("https://r6.r-lib.org/", "R6 vignettes")`, especially the `r link("https://r6.r-lib.org/articles/Introduction.html", "introduction")`. For comprehensive R6 information, we refer to the `r link("https://adv-r.hadley.nz/r6.html", "R6 chapter from Advanced R")`.
:::

### Quick `data.table` introduction for beginners {#sec-data.table}

The package `r ref_pkg("data.table")` implements a popular alternative to R's `data.frame()`, i.e. an object to store tabular data.
We decided to use `r ref_pkg("data.table")` because it is blazingly fast and scales well to bigger data.

::: callout-note
Many `r mlr3` functions return `data.table`s which can conveniently be subsetted or combined with other outputs.
If you do not like the syntax or are feeling more comfortable with other tools, base `data.frame`s or `r ref_pkg("tibble")`/`r ref_pkg("dplyr")`s are just a `as.data.frame()` or `as_tibble()` away.
:::

Data tables are constructed with the `data.table()` function (whose interface is similar to `data.frame()`) or by converting an object with `as.data.table()`.

```{r intro-002.table-001.table-002}
library("data.table")
dt = data.table(x = 1:6, y = rep(letters[1:3], each = 2))
dt
```

`data.table`s can be used much like `data.frame`s, but they do provide additional functionality that makes complex operations easier.
For example, data can be summarized by groups with the `[` operator:

```{r intro-004.table-003.table-004}
dt[, mean(x), by = "y"]
```

There is also extensive support for many kinds of database join operations (see e.g. `r link("https://rstudio-pubs-static.s3.amazonaws.com/52230_5ae0d25125b544caab32f75f0360e775.html", "this RPubs post by Ronald Stalder")`) that make it easy to combine multiple `data.table`s in different ways.

::: callout-tip
For an in-depth introduction, we refer the reader to the `r link("https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html", "excellent data.table introduction vignette")`.
:::

## Essential `r mlr3` utilities {#sec-mlr3-utilities}

### Helper Functions {.unnumbered .unlisted}

Most objects in `r mlr3` can be created through convenience functions called *helper functions* or *sugar functions*.
They provide shortcuts for common code idioms, reducing the amount of code a user has to write.
We heavily use helper functions throughout this book and give the equivalent "full form" for complete detail.
In most cases, the helper functions will achieve what you want to do, and you only have to consider using the full R6 code if you use custom objects or extensions.
For example `lrn("regr.rpart")` is the sugar version of `LearnerRegrRpart$new()`.

### Dictionaries {.unnumbered .unlisted}

`r mlr3` uses dictionaries to store objects like learners or tasks.
These are key-value stores that allow to associate a key with a value that can be an R6 object, much like paper dictionaries associate words with their definitions.
Values in dictionaries are often accessed through sugar functions (i.e. `lrn()`) that automatically use the applicable dictionary (i.e. `mlr_learners`); only the key to be retrieved needs to be specified.
Dictionaries are used to group relevant objects so that they can be listed and retrieved easily.
For example, the "featureless" classification learner can be retrieved through `lrn("classif.featureless")` or directly from the `mlr_learners` dictionary using the key `"classif.featureless"` (`mlr_learners$get("classif.featureless")`).
You can get an overview of all available learners by inspecting the dictionary, e.g. with `as.data.table(mlr_learners)`.

### `r mlr3viz` {.unnumbered .unlisted}

`r mlr3viz` is the package for all plotting functionality in the `r mlr3` ecosystem.
The package uses a common theme (`ggplot2::theme_minimal()`) so that all generated plots have a similar aesthetic.
Under the hood, `r mlr3viz` uses `ggplot2`.
`r mlr3viz` extends `fortify` and `autoplot` for use with common `r mlr3` outputs including Prediction, Learner, and Benchmark objects (these objects will be introduced and covered in the next chapters).
The most common use of `r mlr3viz` is the `autoplot()` function, where the type of the object passed determines the type of the plot.
Plot types are documented in the respective manual page that can be accessed through `?autoplot.X`.
For example, the documentation of plots for regression tasks can be found by running `?autoplot.TaskRegr`.
