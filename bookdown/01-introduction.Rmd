# Introduction {#introduction}

A typical machine-learning workflow looks like this:

```{r 02-building-blocks-1, echo = FALSE}
knitr::include_graphics("images/ml_abstraction.png")
```

We refer to "building blocks" in our guide as steps in the machine-learning workflow.
The ones shown above are the essential blocks.
Other building blocks can be added to the workflow to enhance certain parts of the essential blocks.

The `mlr3` package provides R6 class objects for the _building blocks_ [tasks](#tasks), [learners](#learners) and [measures](#measures).

Other _building blocks_ include:

- Ensemble learners (stacking of models)
- Feature selection
- Hyperparameter tuning
- Parallelization 
- Preprocessing of data
- Resampling methods

These additional blocks are provided by our extension packages such as `r gh_pkg("mlr-org/mlr3tuning")`, `r gh_pkg("mlr-org/mlr3pipelines")` or `r gh_pkg("mlr-org/mlr3featuresel")`.

## `mlr` -> `mlr3` transition guide

In case you have already worked with `mlr`, you may want quickstart with `mlr3` by looking up the specific equivalent of an element of `mlr` in the new version `mlr3`.
For this, you can use the following table.
This table is not complete but should give you an overview about how `mlr3` is organized.

### Tasks {#trans-tasks}

```{r trans-table-tasks, echo = FALSE}
tmlr = c(
  "Task",
  "`SurvTask`",
  "`ClusterTask`",
  "`MultilabelTask` / `CostSensTask`",
  "`SpatialTask`",
  "Example tasks (`iris.task`, `mtcars.task`)")
tmlr3 = c(
  "mlr_tasks / Task",
  paste0("`TaskSurv` from ", gh_pkg('mlr-org/mlr3survival')),
  "Not yet implemented",
  "Supported via `TaskClassif` and `TaskRegr`",
  "Not yet implemented",
  "`mlr_tasks$get('iris')`")
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Train/Predict/Resampling

```{r trans-table-exec, echo = FALSE}
tmlr = c(
  "`train()`, `predict()`",
  "`performance()`",
  "`makeResampleDesc()`",
  "`resample()`")
tmlr3 = c(
  "`Experiment$train()`, `Experiment$predict()`",
  "`Experiment$score()`",
  "Resampling, mlr_resamplings",
  "`resample()`")
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Benchmark

```{r trans-table-benchmark, echo = FALSE}
tmlr = c(
  "`benchmark()`",
  "`batchmark()` / `reduceBatchmarkResults()`",
  "`BenchmarkResult`",
  "`convertBMRToRankMatrix()`",
  "`convertMLBenchObjToTask()`",
  "`getBMRAggrPerformances()`",
  "`getBMRFeatSelResults()`",
  "`getBMRFilteredFeatures()`",
  "`getBMRLearners()` / `getBMRLearnerIds()` / `getBMRLearnerShortNames()`",
  "`getBMRMeasures()` / `getBMRMeasureIds()`",
  "`getBMRModels()`",
  "`getBMRPerformances()`",
  "`getBMRTaskDescriptions()` / `getBMRTaskDescs()` / `getBMRTaskIds()`",
  "`getBMRTuneResults()`",
  "`mergeBenchmarkResults()`",
  "`plotBMRBoxplots()`",
  "`plotBMRRanksAsBarChart()`",
  "`plotBMRSummary()`",
  "`plotResiduals()`")
tmlr3 = c(
  "`benchmark()`",
  "not used anymore",
  "`BenchmarkResult`",
  "not yet implemented",
  "not yet implemented",
  "`BenchmarkResult$aggregated()`",
  "not yet implemented -> _mlr3featsel_",
  "not yet implemented -> _mlr3featsel_",
  "`BenchmarkResult$learners`",
  "`BenchmarkResult$measures`",
  "not yet implemented",
  "`BenchmarkResult$data$performance` (convenience getter needed?)",
  "`BenchmarkResult$tasks`",
  "not yet implemented -> _mlr3tuning_",
  "`BenchmarkResult$combine()`",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_")
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Parameter Specification

```{r trans-table-params, echo = FALSE}
tmlr = c(
  "`ParamHelpers::makeNumericParam()` `ParamHelpers::makeIntegerParam()` `ParamHelpers::makeDiscreteParam()` `ParamHelpers::makeLogicalParam()`")
tmlr3 = c(
  "`paradox::ParamDbl$new()` `paradox::ParamInt$new()` `paradox::ParamFct$new()` `paradox::ParamLgl$new()`")
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Preprocessing {#trans-preproc}

```{r trans-table-preproc, echo = FALSE, eval = F}
tmlr = c()
tmlr3 = c()
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Parallelization {#trans-parallel}

```{r trans-table-parallel, echo = FALSE}
tmlr = c(
  "`ParallelMap::parallelStart*()`, `parallelMap::parallelStop()`")
tmlr3 = c(
  "`future::plan()` / `future` package")
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Plotting {#trans-viz}

```{r trans-table-viz, echo = FALSE}
tmlr = c(
  "`plotBMRBoxplots()`",
  "`plotBMRRanksAsBarChart()`",
  "`plotBMRSummary()`",
  "`plotCalibration()`",
  "`plotCritDifferences()`",
  "`plotFilterValues()`",
  "`plotHyperParsEffect()`",
  "`plotLearnerPrediction()`",
  "`plotLearningCurve()`",
  "`plotPartialDependence()`",
  "`plotResiduals()`",
  "`plotROCCurves()`",
  "`plotThreshVsPerf()`",
  "`plotTuneMultiCritResult()`")
tmlr3 = c(
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_",
  "not yet implemented -> _mlr3viz_")
knitr::kable(x = data.frame(tmlr, tmlr3), col.names = c("mlr", "mlr3"))
```

### Getters {#trans-get}



### Setters {#trans-set}
