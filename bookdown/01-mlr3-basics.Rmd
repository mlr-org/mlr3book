# mlr3 Basics {#basics}

## Introduction {#introduction}

A typical machine-learning workflow looks like this:

```{r 01-mlr3-basics-001, echo = FALSE}
knitr::include_graphics("images/ml_abstraction.png")
```

We refer to "building blocks" in our guide as steps in the machine-learning workflow.
The ones shown above are the essential blocks.
Other building blocks can be added to the workflow to enhance certain parts of the essential blocks.

The `mlr3` package provides R6 class objects for the _building blocks_ [tasks](#tasks), [learners](#learners) and [measures](#measures).

Other _building blocks_ include:

- Ensemble learners (stacking of models)
- Feature selection
- Hyperparameter tuning
- Parallelization
- Preprocessing of data
- Resampling methods

These additional blocks are provided by our extension packages such as `r gh_pkg("mlr-org/mlr3tuning")`, `r gh_pkg("mlr-org/mlr3pipelines")` or `r gh_pkg("mlr-org/mlr3featuresel")`.ing.

## Tasks & Learners

Tasks and learners are two essential building blocks that are required to execute any machine-learning experiment.

A **task** wraps the data and store additional information about it.

**Learners** store information about the algorithms that should be used in the experiment.

## Tasks {#tasks}

**Tasks** are objects that include the data set and additional meta information about a machine-learning problem.
This could be the name of the target variable for supervised problems or whether the data set belongs to a specific community of datasets (e.g. a _spatial_ or _survival_ dataset).
This information can be used at different points of the workflow to account for specific characteristics of these dataset types.

### Task Types

To create a task from a `r ref("data.frame()")` or `r ref("data.table()")` object, the task type needs to be selected:

* **Classification Task**: Target column is labels (stored as `character()`/`factor()`) with only few distinct values.
  <br>$\Rightarrow$ `r ref("mlr3::TaskClassif")`
* **Regression Task**: Target column is numeric (stored as `integer()`/`double()`).
  <br>$\Rightarrow$ `r ref("mlr3::TaskRegr")`
* **Survival Task**: Target is the (right-censored) time to event.
  <br>$\Rightarrow$ `r ref("mlr3survival::TaskSurv")` in add-on package `r mlr_pkg("mlr3surival")`
* **Ordinal Regression Task**: Target is ordinal.
  <br>$\Rightarrow$ `r ref("mlr3ordinal::TaskOrdinal")` in add-on package `r mlr_pkg("mlr3ordinal")`
* **Cluster Task**: You don't have a target but want to identify similarities in the feature space.
  <br>$\Rightarrow$ Not yet implemented
* **Spatial Task**: The observations come with spatio-temporal information (e.g. coordinates).
  <br>$\Rightarrow$ Not yet implemented in add-on package `r mlr_pkg("mlr3spatiotemporal")`

### Task Creation

Let's assume we want to create a simple regression task using the `mtcars` data set from the package `datasets` to predict the column `"mpg"` (miles per gallon).
For this showcase we only take the first two features to keep the output in the following examples compact.

```{r 01-mlr3-basics-002}
data("mtcars", package = "datasets")
data = mtcars[, 1:3]
str(data)
```

Next, we create the task by providing the following information:

1. `id`: Identifier for the task, used in plots and summaries.
2. `backend`: Here, we simply provide the dataset. It is internally converted to a `r ref("DataBackendDataTable")`.
   For more fine-grain control over how the data is stored internally, we could also construct a `r ref("DataBackend")` manually.
3. `target`: Column name of the target column for the regression problem.

```{r 01-mlr3-basics-003}
task_mtcars = TaskRegr$new(id = "cars", backend = data, target = "mpg")
print(task_mtcars)
```

The `print()` method gives a short summary of the task: It has `r task_mtcars$nrow` observations, `r task_mtcars$ncol` columns of which `r length(task_mtcars$feature_names)` columns are features.

We can also print the task using the `r mlr_pkg("mlr3viz")` package:
```{r 01-mlr3-basics-004}
library(mlr3viz)
autoplot(task_mtcars, type = "pairs")
```

### Predefined tasks

`mlr3` ships with some predefined machine-learning tasks.
These are stored in a R6 `r ref("Dictionary")`, which is a simple key-value storage named `mlr3::mlr_tasks`.
If we simply print it out, we see that is has `r length(mlr_tasks$keys())` entries:

```{r 01-mlr3-basics-005}
mlr_tasks
```

We can obtain a summarizing overview of all stored tasks by converting the dictionary to a `data.table()` object

```{r 01-mlr3-basics-006}
as.data.table(mlr_tasks)
```

To create a **task** from the dictionary (think of it as a book shelf), we use the `$get()` method from the `mlr_tasks` class and assign it to a new object.

For example, if we would like to use the [iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set) for classification:

```{r 01-mlr3-basics-007}
task_iris = mlr_tasks$get("iris")
print(task_iris)
```

### Task API

All **task** properties and characteristics can be queried using the task's public member values and methods (see `r ref("Task")`).

```{r 01-mlr3-basics-008}
task_iris = mlr_tasks$get("iris")
```

- Member values: Values stored in the object that can be queried by the user

```{r 01-mlr3-basics-009}
# public member values
task_iris$nrow
task_iris$ncol
```

- Member methods: Functions from the object that can accept arguments and return information stored in the object

```{r 01-mlr3-basics-010}
# public member methods
task_iris$head(n = 3)
```

#### Retrieve Data

In `mlr3`, each row (observation) has a unique identifier which can be either `integer` or `character`.
These can be used to select specific rows.

The _iris_ dataset uses integer `row_ids`:

```{r 01-mlr3-basics-011}
# iris uses integer row_ids
head(task_iris$row_ids)

# retrieve data for rows with ids 1, 51, and 101
task_iris$data(rows = c(1, 51, 101))
```

While the _mtcars_ dataset uses names for its `row_ids`, encoded as `character`:

```{r 01-mlr3-basics-012}
head(task_mtcars$row_ids)

# retrieve data for rows with id "Datsun 710"
task_mtcars$data(rows = "Datsun 710")
```

Note that the method `$data()` is only an accessor and does not modify the underlying data/task.

Analogously, each column has an identifier, which is often just called "column name".
These are stored in the public slots `feature_names` and `target_names`.
Here "target" refers to the response variable and "feature" to the predictor variables of the task.

```{r 01-mlr3-basics-013}
task_iris$feature_names
task_iris$target_names
```

The `row_id` names and the "column names" can be combined for subsetting:

```{r 01-mlr3-basics-014}
# retrieve data for rows 1, 51, and 101 and only select column "Species"
task_iris$data(rows = c(1, 51, 101), cols = "Species")
```

To extract the complete dataset from the task, we need to convert the task to a `data.table`:

```{r 01-mlr3-basics-015}
summary(as.data.table(task_iris))
```

#### Roles (Rows and Columns)

It is possible to assign a special meanings (aka "roles") to (subsets of) rows and columns.

For example, the previously constructed _mtcars_ task has the following column roles:

```{r 01-mlr3-basics-016}
print(task_mtcars$col_roles)
```

Now, we want the original `rownames()` of `mtcars` to be a regular feature column.
Thus, we first preprocess the `data.frame` and then re-create the task.

```{r 01-mlr3-basics-017}
library("data.table")
# with `keep.rownames`, data.table stores the row names in an extra column "rn"
data = as.data.table(mtcars[, 1:3], keep.rownames = TRUE)
task = TaskRegr$new(id = "cars", backend = data, target = "mpg")

# we now have integer row_ids
task$row_ids

# there is a new "feature" called "rn"
task$feature_names
```

The column "rn" is now a regular feature.
As this is a unique string column, most machine-learning algorithms will have problems to process this feature without some kind of preprocessing.
However, we still might want to carry `rn` around for different reasons.
For example, we can use the row names in plots or to associate outliers with the row names.
This being said, we need to change the role of the row names column `rn` and remove it from the set of active features.

```{r 01-mlr3-basics-018}
task$feature_names
task$set_col_role("rn", new_roles = "label")

# "rn" not listed as feature any more
task$feature_names

# also vanished from "data" and "head"
task$data(rows = 1:2)
task$head(2)
```

Note that no copies of the underlying data is inflicted by this operation.
By changing roles, only the view on the data is changed, not the data itself.

Just like columns, it is also possible to assign different roles to rows.
Rows can have two different roles:

1. Role `"use"`:
   Rows that are generally available for model fitting (although they may also be used as test set in resampling).
   This is the default role.
2. Role `"validation"`:
   Rows that are held back (see below).
   Rows which have missing values in the target column upon task creation are automatically moved to the validation set.

There are several reasons to hold some observations back or treat them differently:

1. It is often good practice to validate the final model on an external validation set to uncover possible overfitting.
1. Some observations may be unlabeled, e.g. in data mining cups or [Kaggle](https://www.kaggle.com/) competitions.
   These observations cannot be used for training a model, but you can still predict labels.

#### Task Mutators

Task methods `.$set_col_role()` and `.$set_row_role()` change the view on the data and can be used to subset the task.
For convenience, method `.$filter()` subsets the task based on row ids, and `.$select()` subsets the task based on feature names.
All these operations only change the view on the data, without creating a copy of it, but modify the task in-place.

```{r 01-mlr3-basics-019}
task = mlr_tasks$get("iris")
task$select(c("Sepal.Width", "Sepal.Length")) # keep only these features
task$filter(1:3) # keep only these rows
task$head()
```

Additionally, methods `.$rbind()` and `.$cbind()` allow to add extra rows and columns to a task, respectively.
Method `.$replace_features()` is a convenience wrapper around `.$select()` and `.$cbind()`.
Again, the original data set stored in the original `mlr3::DataBackend` is not altered in any way.

```{r 01-mlr3-basics-020}
task$cbind(data.table(foo = letters[1:3])) # add column foo
task$head()
```

## Learners {#learners}

Objects of class `mlr3::Learner` provide a unified interface to many popular machine-learning algorithms in R.
They consist of methods to train and predict on a `mlr3::Task`, and additionally provide meta information about the algorithms.

The package ships with only a rather minimal set of classification and regression learners, more are implemented in the [mlr3learners](https://mlr3learners.mlr-org.com) package.
Furthermore, [mlr3learners](https://mlr3learners.mlr-org.com) has some documentation on creating custom learners.

### Predefined Learners

Similar to `mlr3::mlr_tasks`, the `mlr3misc::Dictionary` `mlr3::mlr_learners` can be queried for available learners:

```{r 01-mlr3-basics-021}
mlr_learners
as.data.table(mlr_learners)
```

As listed in the output, each learner comes with the following information:

* `feature_types`: what kind of features can be processed.
* `packages`: which packages are required to run `train()` and `predict()`.
* `properties`: additional properties and capabilities. For example, a learner has the property "missings" if it is able to handle missing values, and "importance" if it is possible to extract feature importance values.
* `predict_types`: what predict types are possible. For example, a classification learner can predict labels ("response") or probabilities ("prob").

To extract a specific learner, use the corresponding `"id"`:

```{r 01-mlr3-basics-022}
learner = mlr_learners$get("classif.rpart")
print(learner)
```

In the output we see that all information from the previous table is also accessible via public slots (`id`, `feature_types`, `packages`, `properties`, `predict_types`).
Additionally, `predict_type` returns the currently selected predict type of the learner.

Slot `param_set` stores a description of hyperparameter settings:

```{r 01-mlr3-basics-023}
learner$param_set
```

The set of hyperparameter values is stored inside the parameter set in the `values` slot.
By assigning a named list to this slot, we change the active hyperparameters of the learner:

```{r 01-mlr3-basics-024}
learner$param_set$values = list(cp = 0.01)
learner
```

The slot `model` stores the result of the training step.
As we have not yet trained a model, this slot is `NULL`:

```{r 01-mlr3-basics-025}
learner$model
```

## Train & Predict {#train-predict}

In this chapter, we explain how [tasks and learners](#tasks-and-learners) can be used to train a model and predict to a new dataset.

The concept is demonstrated on a supervised classification using the iris dataset and the **rpart** learner (classification tree).

Additionally, this chapter includes the following use-cases

- Functional Data Analysis using <model name> (WIP)
- Regression Analysis using <model name> (WIP)
- Survival Analysis using <model name> (WIP)
- Spatial Analysis using <model name> (WIP)

### Basic concept

#### Creating Task and Learner Objects

The first step is to generate the following `mlr3` objects from the [task dictionary](#tasks) and the [learner dictionary](#learners), respectively:

1. The classification task
    ```{r 01-mlr3-basics-026}
    task = mlr_tasks$get("iris")
    ```
2. A learner for the classification tree
    ```{r 01-mlr3-basics-027}
    learner = mlr_learners$get("classif.rpart")
    ```

#### Setting up the train/test splits of the data (#split-data)

It is common to train on a majority of the data.
Here we use 80% of all available observations and predict on the remaining 20% observations.
For this purpose, we create two index vectors:

```{r 01-mlr3-basics-028}
train_set = sample(task$nrow, 0.8 * task$nrow)
test_set = setdiff(seq_len(task$nrow), train_set)
```

#### Defining the "Experiment"

The process of fitting a machine-learning model, predicting on test data and scoring the predictions by comparing predicted and true labels is what we call an "experiment" in `mlr`.
We start by initializing a new `Experiment` object by passing the created `r ref("TaskClassif")` and `r ref("LearnerClassif")`:

```{r 01-mlr3-basics-029}
e = Experiment$new(task = task, learner = learner)
print(e)
```

The output shows a summary of the state of the experiment.
We can see that the current state is "defined".
This means that the task and the learner have been stored, but nothing else happened so far.
If we query the `state` slot specifically, the (ordered) factor levels of the output show us all other possible states of an experiment:

```{r 01-mlr3-basics-030}
e$state
```

#### Training

Now we can finally train the learner on the task by calling the `.$train()` function of the experiment `e` we created:

```{r 01-mlr3-basics-031}
e$train(row_ids = train_set)
print(e)
```

The output indicates that the `Experiment` object was modified (its state is now `[trained]`).
Additionally, it was extended by a slot `model`:

```{r 01-mlr3-basics-032}
print(e$model)
```

#### Predicting

After the model was trained, we use the remaining part of the data for prediction.
Remember that we [initially split the data](#split-data) in `train_set` and `test_set`.

(Rather than using a subset of the initial data we could also pass a completetly new `data.frame` here.)

```{r 01-mlr3-basics-033}
e$predict(row_ids = test_set)
print(e)
```

Now we gained a new slot named `Predictions` that we holds the prediction results.
Since we are using R6 objects in `mlr3`, the result is again directly stored in object `e`.

A preview of the generated predictions can be retrieved by querying the `prediction` slot.

```{r 01-mlr3-basics-034}
e$prediction
```

If desired you can also extract the results to a normal `data.table` object:

```{r 01-mlr3-basics-035}
e_dt = as.data.table(e$prediction)
head(e_dt)
```

##### Performance assessment

The last step of the experiment is quantifying the performance of the model by comparing the predicted labels with the true labels using a performance measure.
The default measure for the classification tasks is the "mean misclassification error".

```{r 01-mlr3-basics-036}
task$measures
```

To conduct the performance assessment, we call the function `.$score()`.
We now get a new slot called `"performance"` in our object:

```{r 01-mlr3-basics-037}
e$score()
```

If we now print the `Experiment` object `e` again, we see that it consists of all six slots which store all important information of the experiment:

```{r 01-mlr3-basics-038}
print(e)
```

##### Chaining methods

The underlying R6 class structure makes it possible to chain all of the operations above (`$train()`, `$predict()` and `$score()`) in a single call:

```{r 01-mlr3-basics-039}
Experiment$new(task = task, learner = learner)$train(train_set)$predict(test_set)$score()
```

## Resampling {#resampling}

### Settings {#resamp-settings}

In this example we use the _iris_ task and a simple classification tree (package `rpart`).

```{r 01-mlr3-basics-040}
task = mlr_tasks$get("iris")
learner = mlr_learners$get("classif.rpart")
```

When performing resampling with a dataset, we first need to define which approach should be used.
The resampling strategies of _mlr3_ can be queried using the `.$keys()` function of the `mlr_resampling` dictionary.

```{r 01-mlr3-basics-041}
mlr_resamplings$keys()
```

Additional resampling methods for special use cases will be available via extension packages, such as [mlr3spatiotemporal](https://github.com/mlr-org/mlr3spatiotemporal) for spatial data (still in development).

The experiment conducted in the [train/predict/score](#train-predict) chapter is equivalent to "holdout", so let's consider this one first.

```{r 01-mlr3-basics-042}
resampling = mlr_resamplings$get("holdout")
print(resampling)
print(resampling$param_set$values)
```

Note that the `Instantianated` field is set to `FALSE`.
This means we did not actually apply the strategy on a dataset yet but just performed a dry-run.
Applying the strategy on a dataset is done in section next [Instantation](#instantation).

By default we get a .66/.33 split of the data.
There are two ways how the ratio can be changed:

1. Overwriting the slot in `.$param_set$values` using a named list.

  ```{r 01-mlr3-basics-043}
  resampling$param_set$values = list(ratio = 0.8)
  ```

2. Specifying the resampling parameters directly during creation using the `param_vals` argument:

  ```{r 01-mlr3-basics-044}
  mlr_resamplings$get("holdout", param_vals = list(ratio = 0.8))
  ```

### Instantation {#resamp-inst}

So far we just set the stage and selected the resampling strategy.
To actually perform the splitting, we need to apply the settings on a dataset.
This can be done in two ways:

1. Manually by calling the method `.$instantiate()` on a `r ref("Task")`

  ```{r 01-mlr3-basics-045}
  resampling = mlr_resamplings$get("cv", param_vals = list(folds = 3L))
  resampling$instantiate(task)
  resampling$iters
  resampling$train_set(1)
  ```

2. Automatically by passing the resampling object to `resample()`. Here, the splitting is done within the `resample()` call based on the supplied `r ref("Task")`.

  ```{r 01-mlr3-basics-046}
  learner1 = mlr_learners$get("classif.rpart") # simple classification tree
  learner2 = mlr_learners$get("classif.featureless") # featureless learner, prediction majority class
  rr1 = resample(task, learner1, resampling)
  rr2 = resample(task, learner2, resampling)

  setequal(rr1$experiment(1)$train_set, rr2$experiment(1)$train_set)
  ```

If you want to compare multiple learners, you should use the same resampling per task to reduce the variance of the performance estimation (**method 1**).
If you use **method 2**, the resampling splits will differ between both runs.

If you aim is to compare different `r ref("Task")`, `r ref("Learner")` or `r ref("Resampling")`, you are better off using the `r ref("benchmark()")` function.
It is basically a wrapper around `r ref("resample()")` simplifying the handling of multiple settings.

If you discover this only after you've run multiple `r ref("resample()")` calls, don't worry - you can transform multiple single `r ref("ResampleResult")` objects into a `r ref("BenchmarkResult")` using the `.$combine()` function.

```{r 01-mlr3-basics-047}
bmr = rr1$combine(rr2)
bmr$aggregated(objects = FALSE)
```

### Execution {#resamp-exec}

With a `r ref("Task")`, a `r ref("Learner")` and `r ref("Resampling")` object we can call `r ref("resample()")` and create a `r ref("ResampleResult")` object.

```{r 01-mlr3-basics-048}
rr = resample(task, learner, resampling)
print(rr)
```

Before we go into more detail, let's change the resampling to a "3-fold cross-validation" to better illustrate what operations are possible with a `r ref("ResampleResult")`.

```{r 01-mlr3-basics-049}
resampling = mlr_resamplings$get("cv", param_vals = list(folds = 3L))
rr = resample(task, learner, resampling)
print(rr)
```

The following operations are supported with `r ref("ResampleResult")` objects:

* Extract the performance for the individual resampling iterations:

  ```{r 01-mlr3-basics-050}
  rr$performance("classif.ce")
  ```

* Extract and inspect the resampling splits:

  ```{r 01-mlr3-basics-051}
  rr$resampling
  rr$resampling$iters
  rr$resampling$test_set(1)
  rr$resampling$train_set(3)
  ```

* Retrieve the experiment of a specific iteration and inspect it:

  ```{r 01-mlr3-basics-052}
  e = rr$experiment(iter = 1)
  e$model
  ```

### Custom resampling

Sometimes it is necessary to perform resampling with custom splits.
If you want to do that because you are coming from a specific modeling field, take a look first at the _mlr3_ extension packages to make sure your custom resampling method hasn't been implemented already.

If your custom resampling method is widely used in your field, feel welcome to integrate it into one of the existing _mlr3_ extension packages or create your own one.

A manual resampling instance can be created using the `"custom"` template from the `r ref("mlr_resamplings")` dictionary.

```{r 01-mlr3-basics-053}
resampling = mlr_resamplings$get("custom")
resampling$instantiate(task,
  list(c(1:10, 51:60, 101:110)),
  list(c(11:20, 61:70, 111:120))
)
resampling$iters
resampling$train_set(1)
resampling$test_set(1)
```

## Benchmarking {#benchmarking}

Comparing the performance of different learners on multiple tasks and/or different resampling schemes is a recurrent task.
This operation is usually referred to as "benchmarking" in the field of machine-learning.
`mlr3` offers the `r ref("benchmark")` function for convenience.

### Design Creation {#bm-design}

In _mlr3_ we require you to supply a "design" of your benchmark experiment.
By "design" we essentially mean the matrix of settings you want to execute.
A "design" consists of `r ref("Task")`, `r ref("Learner")` and `r ref("Resampling")`.
Additionally, you can supply different `r ref("Measure")` along side.

Here, we call `r ref("benchmark")` to perform a single holdout split on a single task and two learners.
We use the `r ref("expand_grid()")` function to create an exhaustive design and properly instantiate the resampling:

```{r 01-mlr3-basics-054}
library(data.table)
design = expand_grid(
  tasks = mlr_tasks$mget("iris"),
  learners = mlr_learners$mget(c("classif.rpart", "classif.featureless")),
  resamplings = mlr_resamplings$mget("holdout")
)
print(design)
bmr = benchmark(design)
```

Note that the holdout splits have been automatically instantiated for each row of the design.
As a result, the `rpart` learner used a different training set than the `featureless` learner.
However, for comparison of learners you usually want the learners to see the same splits into train and test sets.
To overcome this issue, the resampling strategy needs to be [**manually instantiated**](#resamp-inst) before creating the design.

While the interface of `benchmark()` allows full flexibility, the creation of such design tables can be tedious.
Therefore, `r gh_pkg("mlr-org/mlr3")` provides a convenience function to quickly generate design tables and instantiate resampling strategies in an exhaustive grid fashion: `r ref("expand_grid()")`.

```{r 01-mlr3-basics-055}
# get some example tasks
tasks = mlr_tasks$mget(c("pima", "sonar", "spam"))

# set measures for all tasks: accuracy (acc) and area under the curve (auc)
measures = mlr_measures$mget(c("classif.acc", "classif.auc"))
tasks = lapply(tasks, function(task) { task$measures = measures; task })

# get a featureless learner and a classification tree
learners = mlr_learners$mget(c("classif.featureless", "classif.rpart"))

# let the learners predict probabilities instead of class labels
learners$classif.featureless$predict_type = "prob"
learners$classif.rpart$predict_type = "prob"

# compare via 10-fold cross validation
resamplings = mlr_resamplings$mget("cv")

# create a BenchmarkDesign object
design = expand_grid(tasks, learners, resamplings)
print(design)
```

### Execution and Aggregation of Results {#bm-exec}

After the [benchmark design](#bm-design) is ready, we can directly call `r ref("benchmark()")`

```{r 01-mlr3-basics-056}
# execute the benchmark
bmr = benchmark(design)
```

Note in the code example above we used `mlr_resamplings$mget()` to instantiate the resampling instance for each `r ref("Task")`.

After the benchmark, we can access the aggregated with `.$aggregated()`:

```{r 01-mlr3-basics-057}
bmr$aggregated(objects = FALSE)
```

We can aggregate the results further.
For example, we might be interested which learner performed best over all tasks.
Since we have `r ref("data.table")` object here, we could do the following:

```{r 01-mlr3-basics-058}
bmr$aggregated(objects = FALSE)[, list(acc = mean(classif.acc), auc = mean(classif.auc)), by = "learner_id"]
```

Alternatively, we can also use the `r cran_pkg("tidyverse")` approach:

```{r 01-mlr3-basics-059}
library("magrittr")
requireNamespace("dplyr")
requireNamespace("tibble")

bmr$aggregated(objects = FALSE) %>%
  tibble::as_tibble() %>%
  dplyr::group_by(learner_id) %>%
  dplyr::summarise(acc = mean(classif.acc), auc = mean(classif.auc))
```

Unsurprisingly, the classification tree outperformed the featureless learner.

### Converting specific benchmark objects to resample objects

A `r ref("BenchmarkResult")` object is essentially a collection of multiple `r ref("ResampleResult")` objects.
As these are stored in a column of the aggregated `data.table()`, we can easily extract them:

```{r 01-mlr3-basics-060}
tab = bmr$aggregated(objects = FALSE)
rr = tab[task_id == "spam" & learner_id == "classif.rpart"]$resample_result[[1]]
print(rr)
```

We can now investigate this resampling and even single experiments using one of the approach shown in [the previous section](#bm-exec):

```{r 01-mlr3-basics-061}
rr$aggregated

# get the iteration with worst AUC
worst = rr %>%
  as.data.table() %>%
  tibble::as_tibble() %>%
  dplyr::slice(which.min(classif.auc)) %>%
  dplyr::select(classif.auc, iteration)

# get the corresponding experiment
e = rr$experiment(worst$iteration)
print(e)
```

## Binary classification {#binary}

### ROC

### Thresholds

## `mlr` -> `mlr3` transition guide

In case you have already worked with `mlr`, you may want quickstart with `mlr3` by looking up the specific equivalent of an element of `mlr` in the new version `mlr3`.
For this, you can use the following table.
This table is not complete but should give you an overview about how `mlr3` is organized.

### General / Helper {#trans-general}

```{r trans-table-general, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`getCacheDir()` / `deleteCacheDir()`",   "???",
  "`capLargeValues()`",                     "???",
  "`configureMlr`",                         "???",
  "`getMlrOptions()`",                      "???",
  "`createDummyFeatures()`",                "???",
  "`dropFeatures()`",                       "???",
  "`crossover()`",                          "???",
  "`downsample()`",                         "???",
  "`extractFDAFPCA()`",                     "???",
  "`extractFDAFeatures()`",                 "???",
  "`extractFDAFourier()`",                  "???",
  "`extractFDAMultiResFeatures()`",         "???",
  "`extractFDAWavelets()`",                 "???",
  "`generateCalibrationData()`",            "???",
  "`generateCritDifferencesData()`",        "???",
  "`generateFilterValuesData()`",           "???",
  "`generateLearningCurveData()`",          "???",
  "`generatePartialDependenceData()`",      "???",
  "`generateThreshVsPerfData()`",           "???",
  "`getCaretParamSet()`",                   "???",
  "`impute()`",                             "???")

t %>% knitr::kable()
```

### Tasks {#trans-tasks}

```{r trans-table-tasks, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "Task",                                       "mlr_tasks / Task",
  "`SurvTask`",                                 paste0("`TaskSurv` from ", gh_pkg('mlr-org/mlr3survival')),
  "`ClusterTask`",                              "Not yet implemented",
  "`MultilabelTask` / `CostSensTask`",          "Supported via `TaskClassif` and `TaskRegr`",
  "`SpatialTask`",                              "Not yet implemented",
  "Example tasks (`iris.task`, `mtcars.task`)", "`mlr_tasks$get('iris')`",
  "`convertMLBenchObjToTask()`",                "???",
  "`getTaskCosts()`",                           "???",
  "`getTaskData()`",                            "`Task$data()`",
  "`getTaskDesc()` / `getTaskDescription()`",   "???",
  "`getTaskFeatureNames()`",                    "`Task$feature_names`",
  "`getTaskFormula()`",                         "`Task$formula()`",
  "`getTaskId()`",                              "`Task$id`",
  "`getTaskNFeats()`",                          "`length(Task$feature_names)`",
  "`getTaskSize()`",                            "`Task$nrow`",
  "`getTaskTargetNames()`",                     "`Task$target_names`",
  "`getTaskTargets()`",                         "???",
  "`getTaskType()`",                            "`Task$task_type`")

t %>% knitr::kable()
```

### Learner {#trans-learner}
```{r trans-table-learner, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`helpLearner()`",                                    "???",
  "`helpLearnerParam()`",                               "???",
  "`getLearnerId()`",                                   "`Learner$id`",
  "`getLearnerModel()`",                                "???",
  "`getLearnerNote()`",                                 "???",
  "`getLearnerPackages()`",                             "`Learner$packages`",
  "`getLearnerParVals()` / `getLearnerParamSet()`",     "`Learner$param_set`",
  "`getLearnerPredictType()`",                          "`Learner$predict_type`",
  "`getLearnerShortName()`",                            "???",
  "`getLearnerType()`",                                 "`Learner$task_type` ?",
  "`getParamSet()`",                                    "`Learner$param_set`",
  "`generateLearningCurveData()`",                      "???",
  "`FailureModel`",                                     "???",
  "`getFailureModelDump()`",                            "???",
  "`getFailureModelMsg()`",                             "???",
  "`isFailureModel()`",                                 "???")

t %>% knitr::kable()
```

### Train/Predict/Resampling

```{r trans-table-exec, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`train()`, `predict()`",                             "`Experiment$train()`, `Experiment$predict()`",
  "`performance()`",                                    "`Experiment$score()`",
  "`makeResampleDesc()`",                               "Resampling, mlr_resamplings",
  "`resample()`",                                       "`resample()`",
  "`Aggregation` / `makeAggregation`",                  "???",
  "`asROCRPrediction()`",                               "???",
  "`getConfMatrix()` / `calculateConfusionMatrix`",     "???",
  "`calculateROCMeasures`",                             "???",
  "`estimateRelativeOverfitting()`",                    "???",
  "`estimateResidualVariance()`",                       "???",
  "`getDefaultMeasure()`",                              "???")
t %>% knitr::kable()
```

### Benchmark

```{r trans-table-benchmark, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`benchmark()`",                                                                  "`benchmark()`",
  "`batchmark()` / `reduceBatchmarkResults()`",                                     "not used anymore",
  "`BenchmarkResult`",                                                              "`BenchmarkResult`",
  "`convertBMRToRankMatrix()`",                                                     "not yet implemented",
  "`convertMLBenchObjToTask()`",                                                    "not yet implemented",
  "`getBMRAggrPerformances()`",                                                     "`BenchmarkResult$aggregated()`",
  "`getBMRFeatSelResults()`",                                                       "not yet implemented -> _mlr3featsel_",
  "`getBMRFilteredFeatures()`",                                                     "not yet implemented -> _mlr3featsel_",
  "`getBMRLearners()` / `getBMRLearnerIds()` / `getBMRLearnerShortNames()`",        "`BenchmarkResult$learners`",
  "`getBMRMeasures()` / `getBMRMeasureIds()`",                                      "`BenchmarkResult$measures`",
  "`getBMRModels()`",                                                               "not yet implemented",
  "`getBMRPerformances()`",                                                         "`BenchmarkResult$data$performance` (convenience getter needed?)",
  "`getBMRTaskDescriptions()` / `getBMRTaskDescs()` / `getBMRTaskIds()`",           "`BenchmarkResult$tasks`",
  "`getBMRTuneResults()`",                                                          "not yet implemented -> _mlr3tuning_",
  "`friedmanTestBMR`",                                                              "???",
  "`friedmanPostHocTestBMR()",                                                      "???",
  "`mergeBenchmarkResults()`",                                                      "`BenchmarkResult$combine()`",
  "`plotBMRBoxplots()`",                                                            "not yet implemented -> _mlr3viz_",
  "`plotBMRRanksAsBarChart()`",                                                     "not yet implemented -> _mlr3viz_",
  "`plotBMRSummary()`",                                                             "not yet implemented -> _mlr3viz_",
  "`plotResiduals()`",                                                              "not yet implemented -> _mlr3viz_")
t %>% knitr::kable()
```

### Parameter Specification

```{r trans-table-params, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`ParamHelpers::makeNumericParam()`",     "`paradox::ParamDbl$new()`",
  "`ParamHelpers::makeIntegerParam()`",     "`paradox::ParamInt$new()`",
  "`ParamHelpers::makeDiscreteParam()`",    "`paradox::ParamFct$new()`",
  "`ParamHelpers::makeLogicalParam()`",     "`paradox::ParamLgl$new()`")
t %>% knitr::kable()
```

### Preprocessing {#trans-preproc}

```{r trans-table-preproc, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "---", "---")
t %>% knitr::kable()
```

### Feature Selection {#trans-featsel}

Feature Selection with _mlr3_ is done by using the package _mlr3featsel_.

```{r trans-table-featsel, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`makeFeatSelControlExhaustive()`",     "not used anymore",
  "`makeFeatSelControlRandom()`",         "not used anymore",
  "`makeFeatSelControlSequential()`",     "not used anymore",
  "`makeFeatSelControlGA()`",             "not used anymore",
  "`makeFilter()`",                       "???",
  "`FeatSelResult`",                      "`FilterResult`",
  "`listFilterMethods()`",                "`mlr_filters`",
  "`analyzeFeatSelResult()`",             "???",
  "`getBMRFeatSelResults()`",             "???",
  "`getBMRFilteredFeatures()`",           "???",
  "`getFeatSelResult()`",                 "???",
  "`getFeatureImportance()`",             "???",
  "`getFilteredFeatures()`",              "???",
  "`makeFeatSelWrapper()`",               "not yet implemented",
  "`makeFilterWrapper()`",                "???",
  "`getResamplingIndices()`",             "???",
  "`selectFeatures()`",                   "???",
  "`filterFeatures()`",                   "???",
  "`generateFilterValuesData()`",         "???")
t %>% knitr::kable()
```

### Parallelization {#trans-parallel}

```{r trans-table-parallel, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`ParallelMap::parallelStart*()`, `parallelMap::parallelStop()`",         "`future::plan()` / `future` package")
t %>% knitr::kable()
```

### Plotting {#trans-viz}

```{r trans-table-viz, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`plotBMRBoxplots()`",                "not yet implemented -> _mlr3viz_",
  "`plotBMRRanksAsBarChart()`",         "not yet implemented -> _mlr3viz_",
  "`plotBMRSummary()`",                 "not yet implemented -> _mlr3viz_",
  "`plotCalibration()`",                "not yet implemented -> _mlr3viz_",
  "`plotCritDifferences()`",            "not yet implemented -> _mlr3viz_",
  "`plotFilterValues()`",               "not yet implemented -> _mlr3viz_",
  "`plotHyperParsEffect()`",            "not yet implemented -> _mlr3viz_",
  "`plotLearnerPrediction()`",          "not yet implemented -> _mlr3viz_",
  "`plotLearningCurve()`",              "not yet implemented -> _mlr3viz_",
  "`plotPartialDependence()`",          "not yet implemented -> _mlr3viz_",
  "`plotResiduals()`",                  "not yet implemented -> _mlr3viz_",
  "`plotROCCurves()`",                  "not yet implemented -> _mlr3viz_",
  "`plotThreshVsPerf()`",               "not yet implemented -> _mlr3viz_",
  "`plotTuneMultiCritResult()`",        "not yet implemented -> _mlr3viz_")
t %>% knitr::kable()
```

### Getters {#trans-get}

```{r trans-table-getters, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "`getTuneResult()`",              "???",
  "`getTuneResultOptPath()`",       "???")
t %>% knitr::kable()
```

### Setters {#trans-set}

```{r trans-table-setters, echo = FALSE}
t = mlr3misc::rowwise_table(
  ~mlr, ~mlr3,
  "---", "---")
t %>% knitr::kable()
```
