## Tasks {#tasks}

Tasks are objects that contain the data and additional meta-data for a machine learning problem.
The meta-data is for example the name of the target variable (the prediction) for supervised machine learning problems, or the type of the dataset (e.g. a _spatial_ or _survival_).
This information is used for specific operations that can be performed on a task.

### Task Types {#tasks-types}

To create a task from a `r ref("data.frame()")` or `r ref("data.table()")` object, the task type needs to be specified:

**Classification Task**: The target is a label (stored as `character()`or`factor()`) with only few distinct values.
<br/>→ `r ref("mlr3::TaskClassif")`

**Regression Task**: The target is a numeric quantity (stored as `integer()` or `double()`).
<br/>→ `r ref("mlr3::TaskRegr")`

**Survival Task**: The target is the (right-censored) time to an event.
<br/>→ `r ref("mlr3proba::TaskSurv")` in add-on package `r mlr_pkg("mlr3proba")`

**Ordinal Regression Task**: The target is ordinal.
<br/>→ `TaskOrdinal` in add-on package `r gh_pkg("mlr-org/mlr3ordinal")`

**Cluster Task**: An unsupervised task type; there is no target and the aim is to identify similar groups within the feature space.
<br/>→ Not yet implemented

**Spatial Task**: Observations in the task have spatio-temporal information (e.g. coordinates).
<br/>→ Not yet implemented, but started in add-on package `r mlr_pkg("mlr3spatiotemporal")`

### Task Creation {#tasks-creation}

As an example, we will create a regression task using the `mtcars` data set from the package `datasets` and predict the target `"mpg"` (miles per gallon).

First, we load the data and preprocess it.
We only consider the first two features in the dataset for brevity.

```{r 02-basics-tasks-001}
str(datasets::mtcars[, 1:3])
```

Next, we create the task of class `r ref("TaskRegr")` by calling the constructor helper `r ref("as_task_regr()")` with the following information:

1. `backend`: An abstract backend for data. For now, just consider this a `data.frame()`
   (which internally gets converted to a `r ref("DataBackend")`).
2. `target`: The name of the target column for the regression problem.
3. `id`: An arbitrary identifier for the task, used in plots and summaries.
   It defaults to the variable name of the `backend`.

```{r 02-basics-tasks-002}
library("mlr3")
mtcars = as_task_regr(datasets::mtcars[, 1:3], target = "mpg")
```

The `print()` method gives a short summary of the task:

```{r}
print(mtcars)
```
It has `r mtcars$nrow` observations and `r mtcars$ncol` columns, of which `r length(mtcars$feature_names)` are features.

We can also plot the task using the `r mlr_pkg("mlr3viz")` package, which gives a graphical summary of its properties:

```{r 02-basics-tasks-003}
library("mlr3viz")
autoplot(mtcars, type = "pairs")
```

Note that it is often more convenient to just load the package `r mlr_pkg("mlr3verse")` instead of loading multiple package from the mlr3 ecosystem one by one.
The `r mlr_pkg("mlr3verse")` internally loads all packages and re-exports those functions which are required for standard data science and machine learning workflows.

### Predefined tasks {#tasks-predefined}

`r mlr_pkg("mlr3")` ships with a few predefined machine learning tasks.
All tasks are stored in an R6 `r ref("Dictionary")` (a key-value store) named `r ref("mlr_tasks")`.
Printing it gives the keys (the names of the datasets):

```{r 02-basics-tasks-004}
mlr_tasks
```

We can get a more informative summary of the example tasks by converting the dictionary to a `data.table()` object:

```{r 02-basics-tasks-005}
as.data.table(mlr_tasks)
```
In the above display, the columns "lgl" (logical), "int" (integer), "dbl" (double), "chr" (character), "fct" (factor), "ord" (ordinal), "psc" (time in `r ref("POSIXct")`) display the number of features (or columns) in the dataset with the corresponding datatype.

To get a task from the dictionary, one can use the documented getters (see `r ref("Dictionary")`).
However, since `mlr3` arranges the instances of various objects in dictionaries and retrieving these instances is the most common task, there is a shortcut for this.
For tasks, the shortcut function is called `r ref("tsk()")`:
```{r 02-basics-tasks-007}
penguins = tsk("penguins")
penguins
```
Here, we retrieve the `r ref("mlr_tasks_penguins", text = "penguins")` data set from the dictionary.

### Task API {#tasks-api}

All task properties and characteristics can be queried using the task's public fields and methods (see `r ref("Task")`).
Methods are also used to change the behavior of the task.

#### Retrieving Data {#tasks-retrieving}

The data stored in a task can be retrieved directly from fields, for example:

```{r 02-basics-tasks-008}
penguins$nrow
penguins$ncol
```

More information can be obtained through methods of the object, for example:

```{r 02-basics-tasks-009}
penguins$data()
```

In `r mlr_pkg("mlr3")`, each row (observation) has a unique identifier, stored as an `integer()`.
These can be passed as arguments to the `$data()` method to select specific rows:

```{r 02-basics-tasks-010}
head(penguins$row_ids)

# retrieve data for rows with ids 1, 51, and 101
penguins$data(rows = c(100, 200, 300))
```

Similarly, target and feature columns also have unique identifiers, i.e. names.
These names are stored in the public slots `$feature_names` and `$target_names`.
Here "target" refers to the variable we want to predict and "feature" to the predictors for the task.

```{r 02-basics-tasks-011}
penguins$feature_names
penguins$target_names
```

The `row_ids` and column names can be combined when selecting a subset of the data:

```{r 02-basics-tasks-012}
# retrieve data for rows 1, 51, and 101 and only select column "Species"
penguins$data(rows = c(100, 200, 300), cols = "species")
```

To extract the complete data from the task, one can simply convert it to a `data.table`:

```{r 02-basics-tasks-013}
tab = as.data.table(penguins)
summary(tab$species)
```

#### Roles (Rows and Columns) {#tasks-roles}

It is possible to assign roles to rows and columns.
These roles affect the behavior of the task for different operations.
Furthermore, these roles provide additional meta-data for it.

For example, the previously-constructed _mtcars_ task has the following column roles:

```{r 02-basics-tasks-014}
print(mtcars$col_roles)
```
The column role `"feature"` contains the names of the two features, the role `"target"` the name of the target column.
All columns which are not designated as the target column will assigned the role `"feature"` during task construction.
To demonstrate how to change the role, we first re-create the `mtcars` task with an additional column for the row names:

```{r 02-basics-tasks-015}
# with `keep.rownames`, data.table stores the row names in an extra column "rn"
data = as.data.table(datasets::mtcars[, 1:3], keep.rownames = TRUE)
mtcars = as_task_regr(data, target = "mpg")

# there is a new feature called "rn"
mtcars$feature_names
```

The row names are now a feature whose values are stored in the column `"rn"`.
We include this column here for educational purposes only.
Generally speaking, there is no point in having a feature that uniquely identifies each row.
Furthermore, the character data type will cause problems with many types of machine learning algorithms.
The identifier may be useful to label points in plots and identify outliers however.
To use the new column for only this purpose, we will change the role of the `"rn"` column and remove it from the set of active features.
This is done by simply modifying the field `$col_roles`, which is a named list of vectors of column names.
Each vector in this list corresponds to a column role, and the column names contained in that vector are designated as having that role.
Supported column roles can be found in the manual of `r ref("Task")`.

```{r 02-basics-tasks-016}
# supported column roles, see ?Task
names(mtcars$col_roles)

# "rn" listed as feature
mtcars$col_roles[c("target", "feature", "name")]

# assign column "rn" the role "name" and remove it from all other roles
mtcars$set_col_roles("rn", "name")

# rn moved from "feature" to "name"
mtcars$col_roles[c("target", "feature", "name")]

# "rn" not listed as feature anymore
mtcars$feature_names

# "rn" also does not appear anymore when we access the data
mtcars$head(2)
```

Note that changing the role does not change the underlying data.
Changing the role only changes the view on it.
The data is not copied or modified in the code above.
The view is changed in-place though, i.e. the task object itself is modified.

Just like columns, it is also possible to assign different roles to rows.

Rows can have two different roles:

1. Role `use`:
Rows that are generally available for model fitting (although they may also be used as test set in resampling).
This role is the default role.

2. Role `validation`:
Rows that are not used for training.
Rows that have missing values in the target column during task creation are automatically set to the validation role.

There are several reasons to hold some observations back or treat them differently:

1. It is often good practice to validate the final model on an external validation set to identify possible overfitting.
2. Some observations may be unlabeled, e.g. in competitions like [Kaggle](https://www.kaggle.com/).

These observations cannot be used for training a model, but can be used to get predictions.

#### Task Mutators {#tasks-mutators}

As shown above, modifying `$col_roles` or `$row_roles` changes the view on the data.
The additional convenience method `$filter()` subsets the current view based on row ids and `$select()` subsets the view based on feature names.

```{r 02-basics-tasks-017}
penguins = tsk("penguins")
task$select(c("Sepal.Width", "Sepal.Length")) # keep only these features
task$filter(1:3) # keep only these rows
task$head()
```

While the methods discussed above allow to subset the data, the methods `$rbind()` and `$cbind()` allow to add extra rows and columns to a task.
Again, the original data is not changed.
The additional rows or columns are only added to the view of the data.

```{r 02-basics-tasks-018}
task$cbind(data.table(foo = letters[1:3])) # add column foo
task$head()
```

### Plotting Tasks {#autoplot-task}

The `r mlr_pkg("mlr3viz")` package provides plotting facilities for many classes implemented in `r mlr_pkg("mlr3")`.
The available plot types depend on the inherited class, but all plots are returned as `r cran_pkg("ggplot2")` objects which can be easily customized.

For classification tasks (inheriting from `r ref("TaskClassif")`), see the documentation of `r ref("mlr3viz::autoplot.TaskClassif")` for the implemented plot types.
Here are some examples to get an impression:

```{r 02-basics-tasks-019, warning = FALSE, message = FALSE}
library("mlr3viz")

# get the pima indians task
task = tsk("pima")

# subset task to only use the 3 first features
task$select(head(task$feature_names, 3))

# default plot: class frequencies
autoplot(task)

# pairs plot (requires package GGally)
autoplot(task, type = "pairs")

# duo plot (requires package GGally)
autoplot(task, type = "duo")
```

Of course, you can do the same for regression tasks (inheriting from `r ref("TaskRegr")`) as documented in `r ref("mlr3viz::autoplot.TaskRegr")`:

```{r 02-basics-tasks-020, warning = FALSE, message = FALSE}
library("mlr3viz")

# get the mtcars task
task = tsk("mtcars")

# subset task to only use the 3 first features
task$select(head(task$feature_names, 3))

# default plot: boxplot of target variable
autoplot(task)

# pairs plot (requires package GGally)
autoplot(task, type = "pairs")
```
